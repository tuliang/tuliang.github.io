---
layout: post
title: 松本行弘的程序世界
category: read
---
<img class="cover" alt="9787115255075" src="/images/2013/05/9787115255075-223x300.jpg" width="223" height="300" />

ISBN: 9787115255075

作者:  松本行弘

译者:  柳德燕 / 李黎明 / 夏倩 / 张文旭

出版社: 人民邮电出版社

出版时间: 2011-8

评价: ☆☆☆☆

（P2）语言体现了人类思考的本质。在地球上，没有任何超越人类智慧的生物，也只有人类能够使用语言。所以，正是因为语言，才体现了人类和别的生物的区别；正是因为语言，人和人之间才能传递知识和交流思想，才能做深入的思考。

（P5）这些特性的共同点是，它们都表明了程序语言让程序员最大限度地获得了扩展能力。编程语言不是从安全性角度考虑以减少程序员犯错误，而是在程序员自己负责的前提下为他提供最大限度发挥能力的灵活性。

我发现越像Lisp的语言越灵活和强大，难怪在Paul Graham在《黑客与画家》中大肆宣传Lisp。这些语言都有一个问题，越灵活越强大就越难学习。结果就导致寻找掌握了这些语言的程序员非常难找，从而企业在商业上考虑就会支持那些易学的语言，这样像Ruby和Lisp这种语言的职位就非常少。不过这也意味着如果一个程序员他能掌握Ruby，甚至Lisp，水平也不会差到那里去。（P6）所谓Lisp流，其语言核心部分仅仅提供极为有限的特性和构造，其余的控制结构都是在编译时通过用宏来组装其核心特性来实现的。这也就意味着，由于有了这种无与伦比的扩展性，只要掌握了Lisp基本语法S式（从本质上讲就是括号表达式），就可以开发出千奇百怪的语言。Common Lisp的读取宏提供了在读取S式的同时进行语法变换的功能，这就在实际上摆脱了S式的束缚，任何语法的语言都可以用Lisp实现。

（P6）“可是一旦引入了宏定义，看起来像是方法调用，而实际上可能是控制结构，也可能是赋值，也可能有非常严重的副作用，这就需要我们去查阅每个函数和方法的文档，解读程序就会变得相当困难。”

（P21）我们已经看到，程序的重复是一切问题的根源。重复的程序在需要修改的时候，所涉及的范围就会更广，费用也就更高。当多个重复的地方都需要修改时，哪怕是漏掉其中之一，程序也将无法正常工作。所以重复降低了程序的可靠性。

Ruby支持Min-in，Min-in可以称为模块（module）。模块拥有两个特性，即: 

*  不能生成实例；
*  不能从普通类继承。

实例代码: 

{% highlight ruby %}
class Stream < Object
end

module Readable
def read
end
end

#继承Stream
class ReadStream < Stream
#包含Readable模块
include Readable
end
{% endhighlight %}

Ruby利用Min-in，即模块功能，实现了多重继承的问题。

把实际对象进行封装这只是面向对象的表象，真正的核心的对数据的封装。不论是对象的属性，还是对象的方法。对象的属性就是数据，这个不必多说。而对象的方法是处理对象自己的一些数据，换句话说就是方法其实是在处理对象某些的“数据块”。（P32）面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上了对数据的结构化。（P34）因为继承只不过是抽象的功能利用方法，所以不必把对继承的理解束缚在“继承是对现实事物的分类的反映”。实际上这样的想法反而妨碍了我们对继承的理解。

Ruby中我们不必在乎它是不是某种对象，而需要确定它是否有那个方法。（P45）如果以类为基准进行数据类型检查的话，就会像静态编程语言一样失去灵活性。无论如何都想检查的时候，也不要检查对象是否属于某个类，而是要检查对象是否有某个方法。

设计语言并不可能，普通开发就是一定程度上的设计语言。设计编程语言，只是更加深层次的抽象。（P53）DSL是针对特定领域，所以在这个特定领域都需要什么处理，需要用词汇来表现。针对特定领域，如果用Ruby来定义需要的类和方法，那么就可以认为Ruby是这个领域的专用语言。这些类和方法可以称为这个领域的词汇。

借用著名的程序员Dava Thomas的话，“所有应用程序的开发过程都可以说是设计语言的过程。”从这个观点来看，开发应用程序就是针对应用程序的问题领域定义各种词汇，最后用这些词汇来描述解决问题的方法。

为了避免文件异常，导致没有被关闭。我们经常需要使用异常来处理，例如: 

{% highlight ruby %}
f = open(path)
begin
…
ensure
f.close
end
{% endhighlight %}

而这种情况可以使用Ruby的程序块来解决: 

{% highlight ruby %}
open(path) { |f|
...
}
{% endhighlight %}

如果给open方法传递了块，那么在结束时文件即可以自动关闭。

（P91）设计模式有了名字，人们就可以认识到它存在。对于没有名字的东西，人们几乎不可能认识到它的存在，并对之进行讨论。这种不能用语言表达的知识我们称之为内隐知识。给这些在软件中经常反复出现的模式命名，使得这些本来只有经验丰富的程序员才能认识到的软件设计模式能被广泛认识和讨论。这样的知识称为形式知识。把迄今为止普通人难于学习和吸收的内隐知识变成形式知识的功绩是无与伦比的。

开放-封闭原则（open-closed principle, OCP）: 对模块扩展必须开放（Open）,对修改必须封闭（Closed）。

（P245）在进行性能优化时，按下述步骤去改善。先找出瓶颈，明确知道应当改善哪里后，再考虑算法和数据结构的选择。去除多余的代入，把反复计算的值放入变量中，这些都是小技巧，性能顶多改善几成。但是，若能选用一个好的算法，有时会改善数十倍，甚至上百倍。

Ruby高速优化的规则: 
减少对象
减少方法调用

开源看上去挺像共产主义的。（P385）“从长远的观点看来，程序员成为自由程序员，是走向完美世界的第一步，在那样一个世界里，谁都不用再为维持生机而像奴隶一样劳动。人们每星期只要工作10个小时，比如在完成制定法律、家族交流、机器人修理或小行星探测等必要的工作之后，就可以自由地专注与编程这一充满乐趣的活动。再也不用为维持生计而编程了。”
