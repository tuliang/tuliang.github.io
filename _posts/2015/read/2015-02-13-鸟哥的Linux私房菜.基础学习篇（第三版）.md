---
layout: post
title: 鸟哥的Linux私房菜.基础学习篇（第三版）
category: read
---
<img class="cover" src="/images/2015/9787115226266.jpg" />

ISBN：9787115226266

作者：鸟哥 

出版社：人民邮电出版社

出版时间：2010-6

评价：☆☆☆☆

modification time (mtime)：
当该档案的『内容数据』变更时，就会更新这个时间！内容数据指的是档案的内容，而不是档案的属性或权限喔！

status time (ctime)：
当该档案的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。

access time (atime)：
当『该档案的内容被取用』时，就会更新这个读取时间 (access)。举例来说，我们使用 cat 去读 取 /etc/man.config ， 就会更新该档案的 atime 了。


不过，需要留意的是， ~/.bash_history 记录的是前一次登入以前所执行过的指令， 而至于这一次登入所执行的指令都被暂存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中！

command not found 一般来说都是因为 PATH 这个环境变量的问题。

env 查看环境变量，export 设置环境变量。

有些朋友在练习 linux 的时候喜欢同时开好几个 bash 接口，这些 bash 的身份都是 root 。 这样会有 ~/.bash_history 癿写入问题吗？想一想，因为这些 bash 在同时以 root 的身份登入， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到注销时才会更新记录文件，所以啰， 最后注销的那个 bash 才会是最后写入的数据。唔！如此一来其他 bash  的指令操作就不会被记录下来了 (其实有被记录，只是被后来的最后一个 bash 所覆盖更新了) 。

一般来说，login shell 其实只会读取这两个配置文件：
1. /etc/profile：这是系统整体的讴定，你最好不要修改这个档案；
2. ~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里！

在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：
1. ~/.bash_profile
2. ~/.bash_login
3. ~/.profile
其实 bash 的 login shell 设定只会读取上面三个档案的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个档案不论有无存在，都不会被读取。

当你取得 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已啦！

数据流重定向可以将standard output（简称stdout）与standard error output（简称stderr）分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：
标准输入（stdin）：代码为0，使用<或<<
标准输出（stdout）：代码为1，使用>或>>
标准错误输出（stderr）：代码为2，使用2>或者2>>
<、>、2>以覆盖的方法将数据输出到指定的文件或者设备上，<<、>>、2>>以累加的方法将数据输出到指定的文件或者设备上。

管道命令使用的是 | 这个界定符号。它和连续执行命令是不一样的。它将前一个命令的输出作为后一个命令的输入连接起来。

shell文件必需要具备可读与可执行（rx）的权限。第一行#!/bin/bash声明这个script使用的shell名称。

通常,造成僵尸进程的成因是因为该进程应该已经执行完毕,或者是因故应该要终止了, 但是该进程的父进程却无法完整的将该进程结束掉,而造成那个进程一直存在内存当中。 如果你发现在某个进程的 CMD 后面还接上 <defunct> 时, 就代表该进程是僵尸进程啦。

当执行 make 时,make 会在当时的目录下搜寻 Makefile (or makefile) 这个文本文件,而 Makefile 里面则记录了原始码如何编译的详细信息! make 会自动的判别原始码是否经过变动了,而自动更新执行档,是软件工程师相当好用的一个辅助工具呢!
咦!make 是一支程序,会去找 Makefile ,那 Makefile 怎么写? 通常软件开发商都会写一支侦测程序来侦测用户的作业环境, 以及该作业环境是否有软件开发商所需要的其他功能,该侦测程序侦测完毕 后,就会主动的建立这个 Makefile 的规则档案啦!通常这支侦测程序的文件名为 configure 或者是 config 。

make 有这些好处:

* 简化编译时所需要下达的指令;
* 若在编译完成之后,修改了某个原始码档案,则 make 仅会针对被修改了的档案进行编译,其他 的 object file 不会被更动;
* 最后可以依照相依性来更新 (update) 执行档。

大部分的 tarball 软件之安装的指令下达方式:

1. ./configure
这个步骤就是在建立 Makefile 这个档案啰!通常程序开发者会写一支 scripts 来检查你的 Linux 系统、相关的软件属性等等,这个步骤相当的重要, 因为未来你的安装信息都是这一步骤内完成的!另外,这个步骤的相关信息应该要参考一下该目录下的 README 戒 INSTALL 相关的档案!
2. make clean
make 会读取 Makefile 中关于 clean 的工作。这个步骤不一定会有,但是希望执行一下,因为 他可以去除目标档案!因为谁也不确定原始码里面到底有没有包含上次编译过的目标档案 (*.o) 存在,所以当然还是清除一下比较妥当的。 至少等一下新编译出来的执行档我们可以确定是使用 自己的机器所编译完成的嘛!
3. make
make 会依据 Makefile 当中的预设工作进行编译的行为!编译的工作主要是进行 gcc 来将原始码编译成为可以被执行的 object files ,但是这些 object files 通常还需要一些函数库之类的 link 后,才能产生一个完整的执行档!使用 make 就是要将原始码编译成为可以被执行的可执行 文件,而这个可执行文件会放置在目前所在的目录之下, 尚未被安装到预定安装的目录中;
4. make install
通常这就是最后的安装步骤了,make 会依据 Makefile 这个档案里面关于 install 的项目,将上一个步骤所编译完成的数据给他安装到预定的目录中,就完成安装啦!

静态函数库的特色:

􏰀扩展名:(扩展名为 .a)
这类的函数库通常扩展名为 libxxx.a 的类型;

􏰀编译行为: 这类函数库在编译的时候会直接整和到执行程序当中,所以利用静态函数库编译成的档案会比较 大一些喔;

􏰀独立执行的状态: 这类函数库最大的优点,就是编译成功的可执行文件可以独立执行,而不需要再向外部要求读取 函数库的内容 (请参照动态函数库的说明)。

􏰀升级难易度:
虽然执行档可以独立执行,但因为函数库是直接整和到执行档中, 因此若函数库升级时,整个执 行档必须要重新编译才能将新版的函数库整和到程序当中。 也就是说,在升级方面,只要函数库 升级了,所有将此函数库纳入的程序都需要重新编译!

动态函数库的特色:

􏰀扩展名:
(扩展名为 .so)
这类函数库通常扩展名为 libxxx.so 的类型;

􏰀编译行为:
动态函数库不静态函数库的编译行为差异挺大的。 与静态函数库被整个捉到程序中不同的,动态 凼式库在编译的时候,在程序里面只有一个『指向 (Pointer)』的位置而已。也就是说,动态函数库的内容并没有被整和到执行档当中,而是当执行档要使用到函数库的机制时, 程序才会去读取函数库来使用。由于执行文件当中仅具有指向动态库所在的指标而已, 并不包含函数库的内容,所以他的档案会比较小一点。

􏰀独立执行的状态:
这类型的函数库所编译出来的程序不能被独立执行, 因为当我们使用到函数库的机制时,程序才 会去读取函数库,所以函数库档案『必须要存在』才行,而且,函数库的『所在目录也不能改变』,因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函数库时, 程序会主动去某个路径下读取,呵呵!所以动态函数库可不能随意移动或删除,会影响很多相依的程序软件喔!

􏰀升级难易度:
虽然这类型的执行档无法独立运作,然而由于是具有指向的功能, 所以,当函数库升级后,执行 档根本不需要进行重新编译的行为,因为执行档会直接指向新的函数库档案 (前提是函数库新旧 版本的档名相同喔!)。

目前的 Linux distribution 比较倾向于使用动态函数库,因为如同上面提到的最重要的一点, 就是函数库的升级方便!由于 Linux 系统里面的软件相依性太复杂了,如果使用太多的静态函数库,那么升级某一个函数库时, 都会对整个系统造成很大的冲击!因为其他相依的执行档也要同时重新编译啊! 这个 时候动态函数库可就有用多了,因为只要动态函数库升级就好,其他的软件根本无须变动。