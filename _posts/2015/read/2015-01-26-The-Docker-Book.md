---
layout: post
title: 第一本 Docker 书
category: read
---
<img class="cover" src="/images/2015/9787115377333.jpg" />

原作名：The Docker Book

ISBN：9787115377333

作者：[澳]詹姆斯•特恩布尔（James Turnbull） 

译者：李兆海 刘斌 巨震   

出版社：人民邮电出版社

出版时间：2014-12

评价：☆☆☆

在传统的 Linux 引导过程中， root 文件系统会最先以只读的方式加载，当引导结束并完成了完整性检查之后，它才会被切换为读写模式。但是在 Docker 里， root 文件系统永远只能是只读状态，并且 Docker 利用联合加载（union mount）技术又会在 root 文件系统层上加载更多的只读文件系统。联合加载会将各层文件系统叠加到一起，这样最终的文件系统会包含所有底层的文件和目录。

Docker 将这样的文件系统成为镜像。一个镜像可以放到另一个镜像的顶部。位于下面的镜像称为父镜像（parent image），可以以此类推，知道镜像栈的最底部，最底部的镜像称为基础镜像（base image）。最后，当从一个镜像启动容器时， Docker 会在该镜像的最顶层加载一个读写文件系统。我们想在 Docker 中运行的程序就是在这个读写层中执行的。

当 Docker 第一次启动一个容器时，初始的读写层是空的。当文件系统发生变化时，这些变化都会应用到这一层上。比如，如果想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层。该文件的只读版本依然存在，但是已经被读写层中的该文件副本所隐藏。

通常这种机制被称为写时复制（copy on write），这也是使 Docker 如此强大的技术之一。每个只读镜像层都是只读的，并且以后永远不会改变。当创建一个新容器时，Docker 会构建出一个镜像栈，并在栈的最顶端添加一个读写层。这个读写层再加上其下面的镜像层以及一些配置数据，就构成了一个容器。容器是可以修改的，他们都有自己的状态，并且可以启动和停止的。容器的这种特点加上镜像分层框架（image-layering framework），使我们可以快速构建镜像并运行包含我们自己的应用程序和服务的容器。


EXPOSE 指令告诉 Docker 该容器内的应用将会使用容器的指定端口。这并不意味着可以自动访问任意容器运行中服务的端口。处于安全问题，Docker 并不会自动打开该端口，而是需要你在使用 docker run 运行容器时来指定需要打开哪些端口。


CMD 指令用于指定一个容器启动时要运行的命令。这有点类似于 RUN 指令，只是 RUN 指令是指定镜像被构建时要运行的命令，而 CMD 是指定容器被启动时要运行的命令。

如果我们在 Dockerfile 里指定了 CMD 指令，而同时在 docker run 命令行中也指定了要运行的命令，命令行中指定的命令会覆盖 Dockerfile 中的 CMD 指令。

在 Dokcerfile 中只能指定一条 CMD 指令。如果指定了多条 CMD 指令，也只有最后一条 CMD 指令会被使用。