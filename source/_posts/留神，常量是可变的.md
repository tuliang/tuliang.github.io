---
title: 留神，常量是可变的
date: 2018-10-31 15:16:49
categories: 后端
tags:
  - Ruby
---
> 总是将常量冻结 `freeze`，从而防止其被改变。

不使用 `freeze` ，常量可以修改。

```ruby
MY_CONSTANT = "foo"
MY_CONSTANT << "bar"
puts MY_CONSTANT #=> "foobar"
```

使用 `freeze` ，常量无法修改。

```ruby
MY_CONSTANT = "foo".freeze
MY_CONSTANT << "bar" #=> FrozenError (can't modify frozen String)
```

> 如果常量引用了一个集合对象比如数组或散列，那么冻结整个集合及其所有元素。

这个 `tip` 已经落伍，在 `Ruby 2.2` 及后续版本会自动冻结整个集合及其所有元素。

```ruby
# in Ruby >= 2.1
NETWORKS = ["192.168.1", "192.168.2"].freeze
NETWORKS << "192.168.3" #=> FrozenError (can't modify frozen Array)
NETWORKS[0] = "192.168.3" #=> FrozenError (can't modify frozen Array)

user = { "name" => "name" }.freeze
user["email"] = "email" #=> FrozenError (can't modify frozen Hash)
user["name"] = "name2" #=> FrozenError (can't modify frozen Hash)
```

> 要防止常量被重新赋值，可以冻结定义它的那个模块。

常量使用 `freeze`，`ruby` 出现 `warning` 但是依然能够被重新赋值。

```ruby
module Defaults
  TIMEOUT = 5.freeze
end

Defaults::TIMEOUT = 6 
#=> warning: already initialized constant Defaults::TIMEOUT
#=> warning: previous definition of TIMEOUT was here

puts Defaults::TIMEOUT #=> 6
```

冻结模块后，常量无法赋值。

```ruby
module Defaults
  TIMEOUT = 5
end

Defaults.freeze

Defaults::TIMEOUT = 6 #=> FrozenError (can't modify frozen Module)
```