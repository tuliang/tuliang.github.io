---
title: 在改变作为参数的集合之前复制它们
date: 2018-11-01 15:59:22
categories: 后端
tags:
  - Ruby
---
> `Ruby` 中参数是按引用传递的，而不是值传递。这个规则有一个例外值得注意：它不适用于 `Fixnum` 对象。
> 
> 在改变集合之前先复制它们。

`Ruby` 语言自带了两个用来复制对象的方法：`dup` 和 `clone`。它们都会基于接收者创建新的对象，但是与 `dup` 方法不同的是，`clone` 方法会保留原始对象的两个附加特性。

首先，`clone` 方法会保留接收者的冻结状态。如果原始对象的状态是冻结的，那么生成的副本也是冻结的。而 `dup` 方法就不同了，它永远不会返回冻结的对象。

其次，如果接收者中存在单例方法，使用 `clone` 方法也会复制单例类。由于 `dup` 方法不会这样做，所以当使用 `dup` 方法时，原始对象和使用 `dup` 方法创建的副本对于相同消息的响应可能是不同的。

多数情况下应使用 `dup` 方法而不是 `clone` 方法，特别是当你希望修改结果对象时。冻结对象时无法修改或是解冻的，所以 `clone` 方法可能会返回一个不可变的对象。由于我们要去对新对象进行修改，因此 `dup` 方法显然是更合适的选择。

> `dup` 方法和 `clone` 方法只会进行浅拷贝。

复制传入集合是一种常见的模式。但要小心，使用这样的方法存在潜在的危险。你要知道 `dup` 方法和 `clone` 方法返回的是浅拷贝对象。对于像 `Array` 一样的集合，这意味着仅仅复制了容器本身而没有复制其中的元素。

可以在不影响原始集合的情况下增添或移除其中的元素，但修改元素本身则是有影响的。原始集合及其副本引用了相同的元素对象。修改任一元素都会影响到集合本身，同样也会影响到任何引用这一元素的对象。

```ruby
a = ["Polar"]

b = a.dup << "Bear"
#=> ["Polar", "Bear"]

b.each {|x| x.sub!('lar', 'oh')}
#=> ["Pooh", "Bear"]

a
#=> ["Pooh"]
```

> 对于多数对象来说，可以使用 `Marshal` 来完成深拷贝。

可以使用 `Marshal` 类将一个集合及其所持有的元素序列化，然后再反序列化：

```ruby
a = ["Monkey", "Brains"]

b = Marshal.load(Marshal.dump(a))
#=> ["Monkey", "Brains"]

b.each(&:upcase!)
#=> ["MONKEY", "BRAINS"]

a
#=> ["Monkey", "Brains"]
```

使用 `Marshal` 来解决这一问题这某种程度上有一定的局限性。抛开对对象序列化和反序列化的时间不说，你还得考虑这一过程中需要的内存。毫无疑问，对象的副本会持有其本身的内存空间，而使用 `Marshal::dump` 中序列化时创建的字节流也是会占用内存的。转储和加载大对象会使程序消耗大内存更多。

一个潜在的更加严峻的问题时并非所有对象都可以被 `Marshal` 序列化。那些持有闭包的对象以及那些具有单例方法的对象时无法被序列化的。`Ruby` 的一些核心类也是不能被 `Marshal` 序列化的。这包括 `IO` 以及 `File` 等类型。对于所有这样的情形，在使用 `Marshal::dump` 进行序列化时会抛出一个 `TypeError` 异常。