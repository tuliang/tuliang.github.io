<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go 语言的 goroutine</title>
      <link href="/go-yu-yan-de-goroutine/"/>
      <url>/go-yu-yan-de-goroutine/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-语言的-goroutine"><a href="#Go-语言的-goroutine" class="headerlink" title="Go 语言的 goroutine"></a>Go 语言的 goroutine</h1><p><code>Go</code> 语言中，主 <code>goroutine</code> 中的代码执行完毕，当前程序就会立刻结束运行，无论其他 <code>goroutine</code> 是否正在运行。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行上面的代码，会发现在绝大部分情况下，是什么都没有输出的。</p><p>其他 <code>goroutine</code> 还没有执行到 <code>fmt.Println(i)</code> 时，主 <code>goroutine</code> 中的代码就执行完毕了，让当前程序立刻结束运行。</p><p>如何让其他 goroutine 先执行完呢？最简单的方法，是让主 <code>goroutine</code> 等待一下。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>问题解决了，但是，等待多久是合适的呢？这是一个新的问题。</p><p>这种情况，我们应该用 <code>sync.WaitGroup</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> waitgroup sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    waitgroup<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>      waitgroup<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  waitgroup<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我们看到 <code>sync.WaitGroup</code> 解决了等待的问题，但是打印的全是 10，顺序不确定线程也不安全。</p><p>那么问题来了，如何让多个 <code>goroutine</code> 按顺序执行并且线程安全？</p><p>一般来说，我们使用锁解决这种问题，而自旋锁就是一种具体的实现。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fun <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>      <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">go</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 <code>GO</code> 语言中，通道是一种比锁更简单的实现。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  message <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      message <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>message<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="通道和锁"><a href="#通道和锁" class="headerlink" title="通道和锁"></a>通道和锁</h2><p>通道的能力是让数据流动起来，擅长的是数据流动的场景。</p><ul><li>传递数据的所有权，即把某个数据发送给其他协程</li><li>分发任务，每个任务都是一个数据</li><li>交流异步结果，结果是一个数据</li></ul><p>锁的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景。</p><ul><li>缓存</li><li>状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈 Go 语言作用域</title>
      <link href="/qian-tan-go-yu-yan-zuo-yong-yu/"/>
      <url>/qian-tan-go-yu-yan-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈-Go-语言作用域"><a href="#浅谈-Go-语言作用域" class="headerlink" title="浅谈 Go 语言作用域"></a>浅谈 Go 语言作用域</h1><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">var</span> block <span class="token operator">=</span> <span class="token string">"package"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  block <span class="token operator">:=</span> <span class="token string">"function"</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// := 会声明一个新变量并且将其初始化</span>    block <span class="token operator">:=</span> <span class="token string">"inner"</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The block is %s.\n"</span><span class="token punctuation">,</span> block<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The block is %s.\n"</span><span class="token punctuation">,</span> block<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre class=" language-shell"><code class="language-shell">The block is inner.The block is function.</code></pre><p>在这里 <code>block := &quot;inner&quot;</code> 等价于 <code>var block = &quot;inner&quot;</code>，它声明了一个新变量并且将其初始化。</p><p>在 <code>{}</code> 这个代码块中新的变量 <code>block</code> 和<code>main</code> 中声明的 <code>block</code> 名称相同。</p><ul><li>在 <code>{}</code> 这个代码块中，它的优先级更高。</li><li>它的作用范围只在 <code>{}</code> 这个代码块中。</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">var</span> block <span class="token operator">=</span> <span class="token string">"package"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  block <span class="token operator">:=</span> <span class="token string">"function"</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// = 会覆盖 block</span>    block <span class="token operator">=</span> <span class="token string">"inner"</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The block is %s.\n"</span><span class="token punctuation">,</span> block<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The block is %s.\n"</span><span class="token punctuation">,</span> block<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre class=" language-shell"><code class="language-shell">The block is inner.The block is inner.</code></pre><p>这种情况很好理解：在 <code>{}</code> 这个代码块中，使用 <code>=</code> 改变了变量 <code>block</code> 的值。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 1. Two Sum</title>
      <link href="/leetcode-1-two-sum/"/>
      <url>/leetcode-1-two-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode 1. Two Sum</a></h1><blockquote><p>Easy</p></blockquote><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre class=" language-code"><code class="language-code">Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><h2 id="Go-Code"><a href="#Go-Code" class="headerlink" title="Go Code"></a>Go Code</h2><p>最容易理解的双循环穷举，时间复杂度 <code>O(n^2)</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> length <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token operator">&lt;</span> length <span class="token punctuation">{</span>        <span class="token keyword">var</span> j <span class="token builtin">int</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token operator">&lt;</span> length <span class="token punctuation">{</span>            <span class="token keyword">if</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> j<span class="token punctuation">}</span>            <span class="token punctuation">}</span>            j<span class="token operator">++</span>        <span class="token punctuation">}</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span></code></pre><p>使用 HashMap 查找元素时间为 <code>O(1)</code> 的特性，时间复杂度 <code>O(2n)</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>  length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>  <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    m<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i  <span class="token punctuation">}</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    index <span class="token operator">:=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 排除 i 和 m[index] 相等的情况</span>    <span class="token keyword">if</span> num<span class="token punctuation">,</span> ok <span class="token operator">:=</span> m<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> num <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> num<span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span></code></pre><p>进一步优化，时间复杂度 <code>O(n)</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> index<span class="token punctuation">,</span> ok <span class="token operator">:=</span> m<span class="token punctuation">[</span>target <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>index<span class="token punctuation">,</span> i<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        m<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 344. Reverse String</title>
      <link href="/leetcode-344-reverse-string/"/>
      <url>/leetcode-344-reverse-string/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-344-Reverse-String"><a href="#LeetCode-344-Reverse-String" class="headerlink" title="LeetCode 344. Reverse String"></a><a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">LeetCode 344. Reverse String</a></h1><blockquote><p>Easy</p></blockquote><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array</strong> <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank" rel="noopener">printable ascii characters</a>.</p><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><pre class=" language-code"><code class="language-code">Input: ["h","e","l","l","o"]Output: ["o","l","l","e","h"]</code></pre><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><pre class=" language-code"><code class="language-code">Input: ["H","a","n","n","a","h"]Output: ["h","a","n","n","a","H"]</code></pre><h2 id="Go-Code"><a href="#Go-Code" class="headerlink" title="Go Code"></a>Go Code</h2><p>使用双索引技术，时间复杂度 <code>O(n/2)</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">var</span> length <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> head <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">var</span> tail <span class="token builtin">int</span> <span class="token operator">=</span> length<span class="token number">-1</span>    <span class="token keyword">for</span> head <span class="token operator">&lt;</span> tail <span class="token punctuation">{</span>        s<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>tail<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>head<span class="token punctuation">]</span>        head<span class="token operator">++</span>        tail<span class="token operator">--</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis Cluster 实践</title>
      <link href="/redis-cluster-shi-jian/"/>
      <url>/redis-cluster-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Cluster-实践"><a href="#Redis-Cluster-实践" class="headerlink" title="Redis Cluster 实践"></a>Redis Cluster 实践</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/redis/redis-rb" target="_blank" rel="noopener">redis</a> 这个 gem 在最新的 4.1 版中开始支持 Redis Cluster。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>我们需要在开发环境搭建一个 Redis Cluster，最方便快捷的方法是使用 docker 和 docker-compose，并且使用配置好的 image。</p><p>在 docker-compose.yml 中添加下列代码</p><pre class=" language-yml"><code class="language-yml">version: '3'services:  redis-cluster:    image: grokzen/redis-cluster    environment:     - IP=0.0.0.0    ports:      - '7000-7007:7000-7007'</code></pre><p>使用 <code>docker-compose up -d</code> 启动服务即可。</p><h3 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h3><p>在 Gemfile 中设置 redis gem 的版本为 4.1</p><pre class=" language-ruby"><code class="language-ruby">gem <span class="token string">"redis"</span><span class="token punctuation">,</span> <span class="token string">"~> 4.1"</span></code></pre><p>在 application.rb 中修改 session_store 和 cache_store</p><pre class=" language-ruby"><code class="language-ruby"><span class="token constant">Rails</span><span class="token punctuation">.</span>application<span class="token punctuation">.</span>configure <span class="token keyword">do</span>  <span class="token comment" spellcheck="true"># Redis Session Store (redis-rails Gem)</span>  config<span class="token punctuation">.</span>session_store <span class="token symbol">:redis_store</span><span class="token punctuation">,</span> servers<span class="token punctuation">:</span> <span class="token punctuation">{</span> cluster<span class="token punctuation">:</span> <span class="token string">%w[redis://127.0.0.1:7000]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> expires_in<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">.</span>month  <span class="token comment" spellcheck="true"># Redis Cache Store (redis-rails Gem)</span>  config<span class="token punctuation">.</span>cache_store <span class="token operator">=</span> <span class="token symbol">:redis_store</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> cluster<span class="token punctuation">:</span> <span class="token string">%w[redis://127.0.0.1:7000]</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># Redis Cache Store (ActiveSupport)</span>  config<span class="token punctuation">.</span>cache_store <span class="token operator">=</span> <span class="token symbol">:redis_cache_store</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> cluster<span class="token punctuation">:</span> <span class="token string">%w[redis://127.0.0.1:7000]</span> <span class="token punctuation">}</span><span class="token keyword">end</span></code></pre><p>在其他地方使用 Redis Cluster</p><pre class=" language-ruby"><code class="language-ruby">redis <span class="token operator">=</span> <span class="token constant">Redis</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>cluster<span class="token punctuation">:</span> <span class="token string">%w[redis://127.0.0.1:7000]</span><span class="token punctuation">)</span></code></pre><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>从单机变成集群之后，数据分片了，分散到不同机器，但是实际需求要求相关联的 <code>key</code> 分配到相同机器。</p><p>因为业务或者性能问题，我们会使用 Redis 的 pipelined、multi 和 Rails.cache.read_multi，这些场景下都需要 <code>key</code> 分配到相同机器。</p><p>但是 Redis Cluster 的分片方案是服务端提供分片，规则不是客户端控制的。</p><p>针对这些场景 Redis Cluster 提供了 <a href="https://redis.io/topics/cluster-spec#keys-hash-tags" target="_blank" rel="noopener">Keys hash tags</a> 的功能，简单来说是：</p><blockquote><p>当一个 key 包含 {} 的时候，就不对整个 key 做 hash，而仅对 {} 包括的字符串做 hash。</p></blockquote><pre class=" language-ruby"><code class="language-ruby">redis <span class="token operator">=</span> <span class="token constant">Redis</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>cluster<span class="token punctuation">:</span> <span class="token string">%w[redis://127.0.0.1:7000]</span><span class="token punctuation">)</span>redis<span class="token punctuation">.</span><span class="token function">mget</span><span class="token punctuation">(</span><span class="token string">'key1'</span><span class="token punctuation">,</span> <span class="token string">'key2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#=> Redis::CommandError (CROSSSLOT Keys in request don't hash to the same slot)</span>redis<span class="token punctuation">.</span><span class="token function">mget</span><span class="token punctuation">(</span><span class="token string">'{key}1'</span><span class="token punctuation">,</span> <span class="token string">'{key}2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#=> [nil, nil]</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文只是一个简单的例子，不能在生产环境中直接使用。</p><p>在生产环境需要考虑 Redis 的各个客户端，同时要考虑数据迁移和兼容的问题，升级到 Redis Cluster 要非常谨慎和细心。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li><a href="https://github.com/redis/redis-rb/wiki/Cluster-mode" target="_blank" rel="noopener">Cluster mode</a></li><li><a href="https://github.com/Grokzen/docker-redis-cluster" target="_blank" rel="noopener">Grokzen/docker-redis-cluster</a></li><li><a href="https://made.livesense.co.jp/entry/2018/10/17/135245" target="_blank" rel="noopener">RubyのRedis Client LibraryをCluster Modeに対応させた話</a></li><li><a href="https://github.com/redis/redis-rb/pull/716" target="_blank" rel="noopener">Add Redis Cluster support</a></li><li><a href="http://blog.text.wiki/2015/09/20/redis-hash-tag.html" target="_blank" rel="noopener">Redis技巧:分片技术和Hash Tag</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>octopus MySQL read only</title>
      <link href="/octopus-mysql-read-only/"/>
      <url>/octopus-mysql-read-only/</url>
      
        <content type="html"><![CDATA[<h1 id="octopus-MySQL-read-only"><a href="#octopus-MySQL-read-only" class="headerlink" title="octopus MySQL read only"></a>octopus MySQL read only</h1><p>最近在线上遇到一个问题，使用 <code>rails db:migrate</code> 时，会去写只读库。</p><p>经过排查发现是 <a href="https://github.com/thiagopradi/octopus" target="_blank" rel="noopener">octopus</a> 这个 gem 造成的。</p><p>查看相关文档，并没有什么收获，倒是 <a href="https://github.com/thiagopradi/octopus/issues/345" target="_blank" rel="noopener">Issues</a> 里有一堆反映问题的。</p><p>既然 <code>octopus</code> 改变了 <code>rails db:migrate</code> 的原始行为，那么在源码中通过 <code>migrate</code> 之类的关键字肯定能找到。</p><p>很快，就在 <code>lib/octopus/migration.rb</code> 中找到了。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># https://github.com/thiagopradi/octopus/blob/master/lib/octopus/migration.rb#L70</span>alias_method <span class="token symbol">:migrate_without_octopus</span><span class="token punctuation">,</span> <span class="token symbol">:migrate</span>alias_method <span class="token symbol">:migrate</span><span class="token punctuation">,</span> <span class="token symbol">:migrate_with_octopus</span></code></pre><p>可以看到它使用 <code>alias_method</code> 这种别名，替换了 <code>migrate</code> 函数。</p><p>这里有一种解决方案是使用 <code>alias_method</code>，反向替换回去，但是并不一定好，毕竟我们还要继续使用 <code>octopus</code>。</p><p>先看看 <code>migrate_with_octopus</code> 到底做了什么？</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># https://github.com/thiagopradi/octopus/blob/master/lib/octopus/migration.rb#L157</span><span class="token keyword">def</span> <span class="token function">migrate_with_octopus</span><span class="token punctuation">(</span>migrations_paths<span class="token punctuation">,</span> target_version <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>block<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">migrate_without_octopus</span><span class="token punctuation">(</span>migrations_paths<span class="token punctuation">,</span> target_version<span class="token punctuation">,</span> <span class="token operator">&amp;</span>block<span class="token punctuation">)</span> <span class="token keyword">unless</span> connection<span class="token punctuation">.</span>is_a<span class="token operator">?</span><span class="token punctuation">(</span><span class="token constant">Octopus</span><span class="token punctuation">:</span><span class="token symbol">:Proxy</span><span class="token punctuation">)</span>  connection<span class="token punctuation">.</span><span class="token function">send_queries_to_multiple_shards</span><span class="token punctuation">(</span>connection<span class="token punctuation">.</span>shard_names<span class="token punctuation">)</span> <span class="token keyword">do</span>    <span class="token function">migrate_without_octopus</span><span class="token punctuation">(</span>migrations_paths<span class="token punctuation">,</span> target_version<span class="token punctuation">,</span> <span class="token operator">&amp;</span>block<span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>在 <code>migrate_with_octopus</code> 中，循环执行 <code>migrate_without_octopus</code>，而它就是 <code>migrate</code> 的别名，即<code>migrate_with_octopus</code> 中，在循环执行 <code>migrate</code>。</p><p>那么我们把 <code>connection.shard_names</code> 打出来看看，你想的没错，它是一个数组</p><pre class=" language-ruby"><code class="language-ruby">p connection<span class="token punctuation">.</span>shard_names<span class="token comment" spellcheck="true"># ["slave", "master"]</span></code></pre><p>找到了关键点，那么解决方案就很简单了，在 <code>rails</code> 启动时去修改它，比如写一个 <code>monkey patch</code></p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># config/initializers/octopus.rb</span><span class="token keyword">return</span> <span class="token keyword">unless</span> <span class="token constant">Octopus</span><span class="token punctuation">.</span>enabled<span class="token operator">?</span><span class="token keyword">module</span> <span class="token constant">Octopus</span>  <span class="token keyword">class</span> <span class="token class-name">ProxyConfig</span>    <span class="token comment" spellcheck="true"># cover shard_names method</span>    <span class="token keyword">def</span> shard_names      <span class="token comment" spellcheck="true"># support db those commands</span>      <span class="token keyword">if</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/^db:/</span><span class="token punctuation">)</span><span class="token punctuation">.</span>present<span class="token operator">?</span>        <span class="token punctuation">[</span><span class="token string">"master"</span><span class="token punctuation">]</span>      <span class="token keyword">else</span>        <span class="token comment" spellcheck="true"># default</span>        shards<span class="token punctuation">.</span>keys      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><h2 id="为什么本地开发环境不会遇到这个问题？"><a href="#为什么本地开发环境不会遇到这个问题？" class="headerlink" title="为什么本地开发环境不会遇到这个问题？"></a>为什么本地开发环境不会遇到这个问题？</h2><p>使用 <code>show global variables like &quot;%read_only%&quot;;</code> 查看</p><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">'%read_only%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span><span class="token operator">|</span> Variable_name    <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span><span class="token operator">|</span> innodb_read_only <span class="token operator">|</span> <span class="token keyword">OFF</span>   <span class="token operator">|</span><span class="token operator">|</span> read_only        <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">|</span> super_read_only  <span class="token operator">|</span> <span class="token keyword">OFF</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span></code></pre><p><code>read_only</code> 的确是 <code>ON</code> 啊，为什么不生效？</p><p>一同显示的还有 <code>innodb_read_only</code> 和 <code>super_read_only</code> 它们是什么？</p><p>查看<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_read_only" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>When the read_only system variable is enabled, the server permits no client updates except from users who have the CONNECTION_ADMIN or SUPER privilege. This variable is disabled by default.</p><p>The server also supports a super_read_only system variable (disabled by default), which has these effects:</p><ul><li><p>If super_read_only is enabled, the server prohibits client updates, even from users who have the SUPER privilege.</p></li><li><p>Setting super_read_only to ON implicitly forces read_only to ON.</p></li><li><p>Setting read_only to OFF implicitly forces super_read_only to OFF.</p></li></ul></blockquote><p>对，我们找到了原因，本地开发环境一般使用 <code>root</code> 账号，它拥有 <code>SUPER privilege</code>，<code>read_only</code> 自然管不住它。</p><p>在本地开发环境复现问题很简单，使用一个没有 <code>SUPER privilege</code> 权限的账号，或者使用 <code>set global super_read_only=ON;</code> 将 <code>SUPER</code> 也限制为只读。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Docker Compose 搭建一个 MySQL 主从服务</title>
      <link href="/shi-yong-docker-compose-da-jian-yi-ge-mysql-zhu-cong-fu-wu/"/>
      <url>/shi-yong-docker-compose-da-jian-yi-ge-mysql-zhu-cong-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Docker-Compose-搭建一个-MySQL-主从服务"><a href="#使用-Docker-Compose-搭建一个-MySQL-主从服务" class="headerlink" title="使用 Docker Compose 搭建一个 MySQL 主从服务"></a>使用 Docker Compose 搭建一个 MySQL 主从服务</h1><h2 id="安装-Docker-for-Mac"><a href="#安装-Docker-for-Mac" class="headerlink" title="安装 Docker for Mac"></a>安装 Docker for Mac</h2><p>先安装 <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a></p><h2 id="准备好文件"><a href="#准备好文件" class="headerlink" title="准备好文件"></a>准备好文件</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><pre class=" language-yml"><code class="language-yml">version: '3'services:  mysql-master:    environment:      - MYSQL_ALLOW_EMPTY_PASSWORD=yes    ports:      - "3306:3306"    build:      context: .      dockerfile: ./docker/mysql/master/DockerFile    links:      - mysql-slave  mysql-slave:    environment:      - MYSQL_ALLOW_EMPTY_PASSWORD=yes    ports:      - "3406:3306"    build:      context: .      dockerfile: ./docker/mysql/slave/DockerFile</code></pre><h3 id="docker-mysql-master-DockerFile"><a href="#docker-mysql-master-DockerFile" class="headerlink" title="docker/mysql/master/DockerFile"></a>docker/mysql/master/DockerFile</h3><pre class=" language-DockerFile"><code class="language-DockerFile">FROM mysql:5.6.40WORKDIR /COPY docker/mysql/master/my.cnf /etc/my.cnf</code></pre><h3 id="docker-mysql-master-my-cnf"><a href="#docker-mysql-master-my-cnf" class="headerlink" title="docker/mysql/master/my.cnf"></a>docker/mysql/master/my.cnf</h3><pre class=" language-conf"><code class="language-conf">[mysqld]# [必须]启用二进制日志log-bin=mysql-bin # [必须]服务器唯一ID，默认是1，一般取IP最后一段  server-id=1## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql</code></pre><h3 id="docker-mysql-slave-DockerFile"><a href="#docker-mysql-slave-DockerFile" class="headerlink" title="docker/mysql/slave/DockerFile"></a>docker/mysql/slave/DockerFile</h3><pre class=" language-DockerFile"><code class="language-DockerFile">FROM mysql:5.6.40WORKDIR /COPY docker/mysql/slave/my.cnf /etc/my.cnf</code></pre><h3 id="docker-mysql-slave-my-cnf"><a href="#docker-mysql-slave-my-cnf" class="headerlink" title="docker/mysql/slave/my.cnf"></a>docker/mysql/slave/my.cnf</h3><pre class=" language-conf"><code class="language-conf">[mysqld]# [必须]服务器唯一ID，默认是1，一般取IP最后一段  server-id=2</code></pre><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><pre class=" language-shell"><code class="language-shell">docker-compose build</code></pre><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre class=" language-shell"><code class="language-shell">docker-compose up -d</code></pre><h2 id="MySQL-主从设置"><a href="#MySQL-主从设置" class="headerlink" title="MySQL 主从设置"></a>MySQL 主从设置</h2><h3 id="进入-MySQL-Master"><a href="#进入-MySQL-Master" class="headerlink" title="进入 MySQL Master"></a>进入 MySQL Master</h3><h4 id="创建同步用户"><a href="#创建同步用户" class="headerlink" title="创建同步用户"></a>创建同步用户</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> repl<span class="token punctuation">;</span></code></pre><h4 id="设置同步用户的权限"><a href="#设置同步用户的权限" class="headerlink" title="设置同步用户的权限"></a>设置同步用户的权限</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'repl'</span>@'<span class="token operator">%</span><span class="token string">' IDENTIFIED BY '</span>repl'<span class="token punctuation">;</span></code></pre><h4 id="显示-master-状态"><a href="#显示-master-状态" class="headerlink" title="显示 master 状态"></a>显示 master 状态</h4><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> master <span class="token keyword">status</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+----------+--------------+------------------+-------------------+</span><span class="token operator">|</span> <span class="token keyword">File</span>             <span class="token operator">|</span> Position <span class="token operator">|</span> Binlog_Do_DB <span class="token operator">|</span> Binlog_Ignore_DB <span class="token operator">|</span> Executed_Gtid_Set <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+----------+--------------+------------------+-------------------+</span><span class="token operator">|</span> mysql<span class="token operator">-</span>bin<span class="token number">.000004</span> <span class="token operator">|</span>      <span class="token number">397</span> <span class="token operator">|</span>              <span class="token operator">|</span> mysql            <span class="token operator">|</span>                   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+----------+--------------+------------------+-------------------+</span></code></pre><p>记住 <code>File</code> 和 <code>Position</code> 里面的值，比如 <code>mysql-bin.000004</code> 和 <code>397</code>。</p><h3 id="进入-MySQL-Slave"><a href="#进入-MySQL-Slave" class="headerlink" title="进入 MySQL Slave"></a>进入 MySQL Slave</h3><h4 id="设置连接-Master-的参数"><a href="#设置连接-Master-的参数" class="headerlink" title="设置连接 Master 的参数"></a>设置连接 Master 的参数</h4><p>记得修改 <code>MASTER_LOG_FILE</code> 和 <code>MASTER_LOG_POS</code> 的值。</p><pre class=" language-sql"><code class="language-sql">CHANGE MASTER <span class="token keyword">TO</span>    MASTER_HOST<span class="token operator">=</span><span class="token string">'mysql-master'</span><span class="token punctuation">,</span>    MASTER_USER<span class="token operator">=</span><span class="token string">'repl'</span><span class="token punctuation">,</span>    MASTER_PASSWORD<span class="token operator">=</span><span class="token string">'repl'</span><span class="token punctuation">,</span>    MASTER_LOG_FILE<span class="token operator">=</span><span class="token string">'mysql-bin.000004'</span><span class="token punctuation">,</span>    MASTER_LOG_POS<span class="token operator">=</span><span class="token number">397</span><span class="token punctuation">;</span></code></pre><h4 id="启动-slave-服务"><a href="#启动-slave-服务" class="headerlink" title="启动 slave 服务"></a>启动 slave 服务</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">start</span> slave<span class="token punctuation">;</span></code></pre><h4 id="显示-slave-状态"><a href="#显示-slave-状态" class="headerlink" title="显示 slave 状态"></a>显示 slave 状态</h4><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> slave <span class="token keyword">status</span>\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>               Slave_IO_State: Waiting <span class="token keyword">for</span> master <span class="token keyword">to</span> send event                  Master_Host: mysql<span class="token operator">-</span>master                  Master_User: repl                  Master_Port: <span class="token number">3306</span>                Connect_Retry: <span class="token number">60</span>              Master_Log_File: mysql<span class="token operator">-</span>bin<span class="token number">.000004</span>          Read_Master_Log_Pos: <span class="token number">397</span>               Relay_Log_File: mysqld<span class="token operator">-</span>relay<span class="token operator">-</span>bin<span class="token number">.000002</span>                Relay_Log_Pos: <span class="token number">596</span>        Relay_Master_Log_File: mysql<span class="token operator">-</span>bin<span class="token number">.000004</span>             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: <span class="token number">0</span>                   Last_Error:                 Skip_Counter: <span class="token number">0</span>          Exec_Master_Log_Pos: <span class="token number">710</span>              Relay_Log_Space: <span class="token number">770</span>              Until_Condition: None               Until_Log_File:                Until_Log_Pos: <span class="token number">0</span>           Master_SSL_Allowed: <span class="token keyword">No</span>           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: <span class="token number">0</span>Master_SSL_Verify_Server_Cert: <span class="token keyword">No</span>                Last_IO_Errno: <span class="token number">0</span>                Last_IO_Error:               Last_SQL_Errno: <span class="token number">0</span>               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: <span class="token number">1</span>                  Master_UUID: <span class="token number">c67c8183</span><span class="token operator">-</span><span class="token number">feb2</span><span class="token operator">-</span><span class="token number">11e8</span><span class="token operator">-</span><span class="token number">9a5e</span><span class="token operator">-</span><span class="token number">0242ac120006</span>             Master_Info_File: <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>master<span class="token punctuation">.</span>info                    SQL_Delay: <span class="token number">0</span>          SQL_Remaining_Delay: <span class="token boolean">NULL</span>      Slave_SQL_Running_State: Slave has <span class="token keyword">read</span> <span class="token keyword">all</span> relay log<span class="token punctuation">;</span> waiting <span class="token keyword">for</span> the slave I<span class="token operator">/</span>O thread <span class="token keyword">to</span> <span class="token keyword">update</span> it           Master_Retry_Count: <span class="token number">86400</span>                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: <span class="token number">0</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span></code></pre><p>当 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 为 <code>Yes</code> 时，说明同步服务正常。</p><p>这时候就可以运行一些 <code>SQL</code> 语句来验证同步服务是否正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis 持久化</title>
      <link href="/redis-chi-jiu-hua/"/>
      <url>/redis-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>Redis 提供了两种不同的持久化方法来将数据存储到硬盘里面。一种方法叫快照（snapshotting），它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file，AOF），它会在执行写命令时，将被执行的写命令复制到硬盘里面。这两种持久化方式可以同时使用，也可以单独使用，甚至都不使用。</p><h2 id="快照持久化"><a href="#快照持久化" class="headerlink" title="快照持久化"></a>快照持久化</h2><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p><p>创建快照的办法有以下几种。</p><ul><li>客户端通过发送 BGSAVE 命令来创建一个快照。Redis 会调用 fork 来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li><li>客户端还可以发送 SAVE 命令来创建一个快照，接到命令的 Redis 在快照创建完毕之前将不再响应任何其它命令。</li><li>如果设置了 save 配置，比如 save 60 10000，那么从 Redis 最近一次创建快照之后算起，当 “60 秒之内有 10000 次写入” 这个条件被满足时，Redis 就会自动触发 BGSAVE 命令。如果设置了多个 save 配置选项，那么当任意一个配置的条件被满足时，就会触发一次 BGSAVE 命令。</li><li>当 Redis 通过 SHUTDOWN 命令接收到关闭服务器的请求时，或者接收到标准 TERM 信号时，会执行一个 SAVE 命令，并在命令执行完毕之后关闭。</li><li>当一个 Redis 连接另一个 Redis，并向对方发送 SYNC 命令开始一次复制操作的时候，那么主服务器会执行 BGSAVE 命令。</li></ul><p>在只使用快照持久化来保存数据时，一定要记住：如果系统真的发生崩溃，用户将丢失最近一次快照之后更改的所有数据。因此，快照持久化只适用于那些即使丢失一部分数据也不会造成问题的程序，而不能接受这种数据损失的程序则可以使用 AOF 持久化。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>简单来说，AOF 持久化会将被执行的写命令写到 AOF 文件的末尾，以此来记录数据发生的变化。因此，Redis 只要从头到尾重新执行一次 AOF 文件包含的所有写命令，就可以恢复 AOF 文件所记录的数据集。AOF 可以通过设置 appendonly yes 配置选项来打开。</p><p>appendonly 选项及同步频率</p><ul><li>always 每个 Redis 写命令都要同步写入硬盘。这样做会严重降低速度。</li><li>everysec 每秒执行一次同步，显式地将多个写命令同步到硬盘。</li><li>no 让操作系统来决定应该何时进行同步。</li></ul><h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><p>在向硬盘写入文件时，至少会发生 3 件事。当调用 file.write() 方法（或者其他编程语言里面的类似操作）对文件进行写入时，写入的内容首先会被存储到缓冲区，然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘，而数据只有在被写入硬盘之后，才算是真正地保存到了硬盘里面。用户可以通过调用 file.flush() 方法来请求操作系统尽快地将缓冲区存储地数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。除此之外，用户还可以命令操作系统将文件同步（fsync）到硬盘，同步操作会一直阻塞直到指定的文件被写入硬盘为止。</p><h3 id="警告-固态硬盘和-appendfsync-always"><a href="#警告-固态硬盘和-appendfsync-always" class="headerlink" title="警告 固态硬盘和 appendfsync always"></a>警告 固态硬盘和 appendfsync always</h3><p>使用固体硬盘的用户请谨慎使用 appendfsync always 选项，因为这个选项让 Redis 每次只写入一个命令，而不是像其他选项那样一次写入多个命令，这种不断写入少量数据的做法有可能会引发严重的写入放大（write amplification）问题，在某些情况下甚至会将固体硬盘的寿命从原来的几年降低为几个月。</p><h3 id="重写-压缩-AOF-文件"><a href="#重写-压缩-AOF-文件" class="headerlink" title="重写/压缩 AOF 文件"></a>重写/压缩 AOF 文件</h3><p>为了解决 AOF 文件不断增大的问题，用户可以发送 BGREWRITEAOF 命令，这个命令会通过移除 AOF 文件中的冗余命令来重写文件。BGREWRITEAOF 的工作原理和 BGSAVE 创建快照的工作原理非常相似，会创建一个子进程，然后由子进程负责对 AOF 文件进行重写。</p><p>AOF 持久化也可以通过设置 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 选项来自动执行 BGREWRITEAOF。</p><h2 id="Redis-复制的启动过程"><a href="#Redis-复制的启动过程" class="headerlink" title="Redis 复制的启动过程"></a>Redis 复制的启动过程</h2><h3 id="表-1-从服务器连接主服务器时的步骤"><a href="#表-1-从服务器连接主服务器时的步骤" class="headerlink" title="表 1 从服务器连接主服务器时的步骤"></a>表 1 从服务器连接主服务器时的步骤</h3><table><thead><tr><th>步骤</th><th>主服务器操作</th><th>从服务器操作</th></tr></thead><tbody><tr><td>1</td><td>等待命令</td><td>连接主服务器，发送 SYNC 命令</td></tr><tr><td>2</td><td>开始执行 BGSAVE，并使用缓冲区记录 BGSAVE 之后执行的所有写命令</td><td>根据配置来决定是继续使用现有的数据来处理客户端的命令，还是向发送请求的客户端返回错误</td></tr><tr><td>3</td><td>BGSAVE 执行完毕，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令</td><td>丢弃所有旧数据，开始载入主服务器发来的快照文件</td></tr><tr><td>4</td><td>快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令</td><td>完成对快照文件的解释操作，开始接受命令请求</td></tr><tr><td>5</td><td>缓冲区存储的写命令发送完毕。从现在开始，每执行一个写命令，就向从服务器发送相同的写命令</td><td>执行主服务器发来的所有存储在缓冲区里面的写命令。并从现在开始，接收并执行主服务器传来的每个写命令</td></tr></tbody></table><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p><strong>从服务器在进行同步，会清空自己的所有数据</strong> 从服务器在于主服务器进行初始连接时，数据库中原有的所有数据都将丢失，并被替换成主服务器发来的数据。</p><p><strong>Redis 不支持主主复制（master-master replication）</strong> 被相互设置为主服务器的两个 Redis 实例只会持续地占用大量资源并且持续不断地尝试与对方进行通信，根据客户端连接的服务器不同，客户端的请求可能会得到不一致的数据，或者得不到数据。</p><h3 id="多个从服务器"><a href="#多个从服务器" class="headerlink" title="多个从服务器"></a>多个从服务器</h3><h4 id="表-2-当有新的从服务器连接主服务器时，有时可以重用已有的快照文件"><a href="#表-2-当有新的从服务器连接主服务器时，有时可以重用已有的快照文件" class="headerlink" title="表 2 当有新的从服务器连接主服务器时，有时可以重用已有的快照文件"></a>表 2 当有新的从服务器连接主服务器时，有时可以重用已有的快照文件</h4><table><thead><tr><th>当有新的从服务器连接主服务器时</th><th>主服务器操作</th></tr></thead><tbody><tr><td>表 1 中步骤 3 尚未执行</td><td>所有从服务器会接收到相同的快照文件和相同的缓冲区写命令</td></tr><tr><td>表 1 中步骤 3 正在执行或者已经执行完毕</td><td>当主服务器与较早进行连接的从服务器执行完复制所需的 5 个步骤之后，主服务器会与新连接的从服务器执行一次新的复制流程</td></tr></tbody></table><h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>当读请求的重要性明显高于写请求的重要性，并且读请求的数量远远超出一台服务器可以处理的范围时，用户就需要添加新的从服务器来处理读请求。随着负载不断上升，主服务器可能会无法快速地更新所有从服务器，或者因为重新连接和重新同步从服务器而导致系统超载。为了缓解这个问题，用户可以创建一个由 Redis 主从节点（master/slave node）组成的中间层来分担服务器的复制工作，如果下图所示。</p><p><img src="https://www.tuliang.org/images/2018/QQ20181209-182956@2x.png" alt="image"></p><p>因为 Redis 的主服务器和从服务器并没有特别不同的地方，所以从服务器也可以拥有自己的从服务器，并形成主从链（master/slave chaining）。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx 进程和信号</title>
      <link href="/nginx-jin-cheng-he-xin-hao/"/>
      <url>/nginx-jin-cheng-he-xin-hao/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-进程和信号"><a href="#Nginx-进程和信号" class="headerlink" title="Nginx 进程和信号"></a>Nginx 进程和信号</h1><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>一般来说 Nginx 有一个父进程 Master，和一个或多个子进程。</p><p>子进程分两类，一种是 Worker 进程，另一种是 Cache 相关的进程。</p><p>Cache 在多个 Worker 间共享使用。同时被进程 Cache manager 和 Cache loader 使用。Cache loader 做缓存的载入，Cache manager 做缓存的管理。这些进程间的通讯都是使用共享内存来解决的。</p><p>为什么不用多线程？因为线程之间是共享地址空间的，当某一个第三方模块引发了地址空间的段错误时，地址越界出现时，会导致整个进程挂掉。</p><p>Nginx 希望每个 Worker 进程从头到尾占有一个 CPU，所以往往不止要把 Worker 进程的数量配置与服务器的 CPU 核数一致以外，还需要把每一个 Worker 进程与某一个 CPU 核绑定在一起。这样可以更好的每个 CPU 核上面的 CPU 缓存来减少缓存失效的命中率。</p><p>不仅仅是缓存的原因，一个进程从头到尾占有一个 CPU，减少 CPU 上下文切换的次数和耗时，让 CPU 更多的时间用在运行进程上。</p><h3 id="Master-进程"><a href="#Master-进程" class="headerlink" title="Master 进程"></a>Master 进程</h3><p>监控 Worker 进程，接受信号</p><ul><li>CHLD，子进程终止的时候会向父进程发送 CHLD。Master 进程通过这个信号维持 Worker 进程的数量。</li></ul><p>管理 Worker 进程，发送信号</p><ul><li>TERM/INT，立刻停止进程。</li><li>QUIT，优雅的退出，等请求处理完才退出，用户无感知。</li><li>HUP，重载配置文件。</li><li>USR1，重新打开日志文件，做日志文件的切割。</li></ul><p>下面 2 个信号，Nginx 命令行中没有对应的操作，只能通过 kill 直接向 Master 进程发送</p><ul><li>USR2，热升级第一阶段，启动新进程。旧的 Nginx 主进程 Master 将会把自己的进程文件改名为 .oldbin，然后执行新版 Nginx。此时新旧 Nginx 会同时运行，共同处理请求。</li><li>WINCH，热升级第二阶段，停止老进程。逐步停止旧版 Nginx 的 Worker 进程就都会随着任务执行完毕而退出，新版的 Nginx 的 Worker 进程会逐渐取代旧版 Worker 进程。</li></ul><h3 id="Worker-进程"><a href="#Worker-进程" class="headerlink" title="Worker 进程"></a>Worker 进程</h3><p>和上面对应，接受信号</p><ul><li>TERM/INT</li><li>QUIT</li><li>USR1</li><li>WINCH</li></ul><h3 id="Nginx-命令行"><a href="#Nginx-命令行" class="headerlink" title="Nginx 命令行"></a>Nginx 命令行</h3><p>启动 Nginx 以后，Nginx 会把 Master 进程的 pid 记录到一个文件中，一般是 Nginx 安装目录下 logs/nginx.pid。</p><p>我们平时使用的命令行其实就是对这个 pid 发送对应的信号。</p><ul><li>reload: HUP</li><li>reopen: USR1</li><li>stop: TERM</li><li>quit: QUIT</li></ul><h3 id="reload-流程"><a href="#reload-流程" class="headerlink" title="reload 流程"></a>reload 流程</h3><ol><li>向 Master 进程发送 HUP 信号（reload 命令）</li><li>Master 进程校验配置语法是否正确</li><li>Master 进程更新监听端口（比如新配置增加了监听 443 端口）</li><li>Master 进程用新配置启动新的 Worker 子进程</li><li>Master 进程向老 Worker 子进程发送 QUIT 信号</li><li>老 Worker 子进程关闭监听句柄，处理完当前连接后结束进程</li></ol><p>在 1.11.11 的版本中，增加了 worker_shutdown_timeout 参数来设置优雅退出 Worker 进程的超时时间。</p><h3 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h3><ol><li>将旧 Nginx 文件换成新 Nginx 文件（注意备份）</li><li>向 Master 进程发送 USR2 信号</li><li>Master 进程修改 pid 文件名，加后缀 .oldbin</li><li>Master 进程用新 Nginx 文件启动新 Master 进程</li><li>向老 Master 进程发送 WINCH 信号，老 Master 进程会优雅关闭老 Worker 进程</li><li>此时老 Master 进程依然存活，如果出现问题需要回滚。向老 Master 进程发送 HUP，然后向新 Master 发送 QUIT 即可。（注意恢复备份文件）</li><li>正常升级后，通过 kill -QUIT 信号关闭老 Master 进程</li></ol><p>新老 Master 进程，同时存在，那么是怎么同时监听端口的？</p><p>新老 Master 进程是父子进程，所以可以同时监听。</p><h3 id="优雅关闭-Worker-进程"><a href="#优雅关闭-Worker-进程" class="headerlink" title="优雅关闭 Worker 进程"></a>优雅关闭 Worker 进程</h3><p>优雅关闭是指 HTTP 请求，如果代理的是 WebSocket、TCP、UDP，这时候 Nginx 是无法进行优雅关闭的。</p><ol><li>设置定时器（这个功能默认不开启，配置文件有设置 worker_shutdown_timeout 才会生效）</li><li>关闭监听句柄</li><li>关闭空闲连接</li><li>在循环中等待全部连接关闭（如果设置了 worker_shutdown_timeout，超时后会强制关闭全部连接）</li><li>退出进程</li></ol><p>更多信息可以参考官方文档 <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/commandline/" target="_blank" rel="noopener">Starting, Stopping, and Restarting NGINX</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈 Markdown 编译器</title>
      <link href="/qian-tan-markdown-bian-yi-qi/"/>
      <url>/qian-tan-markdown-bian-yi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈-Markdown-编译器"><a href="#浅谈-Markdown-编译器" class="headerlink" title="浅谈 Markdown 编译器"></a>浅谈 Markdown 编译器</h1><p>作者不是科班出身，基础比较差。一直在补习一些基础知识，也包括编译原理。最近和朋友交流的时候有提到 <code>AST(抽象语法树)</code>，虽然以前也零散的看了一些文章，实际上还是比较模糊的。</p><p>在这一篇文章中，我会尝试谈一下编译器。虽然参考了诸多资料，不过文中观点难免掺入主观想法，我也希望文中的错误与不足之处能被各位指出。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>编译原理是计算机专业的一门重要专业课，旨在介绍编译程序构造的一般原理和基本方法。内容包括语言和文法、词法分析、语法分析、语法制导翻译、中间代码生成、存储管理、代码优化和目标代码生成。</p><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>解释器根据程序中的算法执行运算。简单来讲，它是一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似于机器语言的程序设计语言写成，这种软件也能称为虚拟机。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>编译器能将某种语言写成的程序转换为另一种语言的程序。通常它会将原程序转换为机器语言。编译器转换程序的行为称为编译，转换前的程序称为源代码或源程序。如果编译器没有把源代码直接转换为机器语言，一般称为源代码转换器或源码转换器（source code translator）。</p><p>过去人们提到编译器时，首先会联想到费时的编译过程。不过由于编译后实际执行的是机器语言，因此执行速度很快。而对于解释器，人们通常认为它会在程序输入的同时立即执行，执行速度较慢。这就是两者的基本区别。现代的解释器内部常采用各种类型的编译器，已经越来越没有必要将解释器和编译器区分看待。</p><h3 id="语言处理器的结构"><a href="#语言处理器的结构" class="headerlink" title="语言处理器的结构"></a>语言处理器的结构</h3><p>无论是解释器还是编译器，语言处理器前半部分的程序结构都大同小异。如下图所示</p><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000312@2x.png" alt="image"></p><h3 id="分割单词"><a href="#分割单词" class="headerlink" title="分割单词"></a>分割单词</h3><p>语言处理器的第一个组成部分是词法分析器（lexical analyzer、lexer 或 scanner）。程序的源代码最初只是一长串字符串。从内部来看，源代码中的换行也能用专门的（不可见）换行符表示，因此整个源代码是一种相连的长字符串。这样的长字符串很难处理，语言处理器通常会首先将字符串中的字符以单词为单位分组，切割成多个字符串。这就是词法分析。</p><p>词法分析器将把程序源代码视作字符串，并把它分割为若干单词（token）。分割后得到的单词并不是简单地用 <code>String</code> 对象表示，而是使用 <code>Token</code> 对象。这种对象除了记录该单词对应的字符串，还会保存单词的类型、单词所处位置的行号等信息。</p><h3 id="用于表示程序的对象"><a href="#用于表示程序的对象" class="headerlink" title="用于表示程序的对象"></a>用于表示程序的对象</h3><p>语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树（AST，Abstract Syntax Tree）。抽象语法树是一种用于表示程序结构的树形结构。</p><p>构造抽象语法树的过程称为语法分析，依然属于语言处理器的前半阶段。经过词法分析后，程序已经被分解为一个个单词。语法分析的主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处理左右括号（单词）的配对等问题。语法分析的结果能够通过抽象语法树来表示。这一阶段还会检查程序中是否含有语法错误。</p><p>以 <code>13 + x * 2</code> 为例</p><h4 id="单词序列"><a href="#单词序列" class="headerlink" title="单词序列"></a>单词序列</h4><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000259@2x.png" alt="image"></p><h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000241@2x.png" alt="image"></p><p>抽象语法树仅用于表示语法分析的结果，因此通过语法分析得到的单词并不一定要与抽象语法树的节点一一对应。抽象语法树是一种去除了多余信息的抽象树形结构。例如</p><p><code>(13 + x) * 2</code></p><p>这样一个表达式来说，它与之前的例子不同，包含了括号。乘法运算的左值不再是 <code>x</code> 而是 <code>13 + x</code>。那么它的抽象语法树是</p><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000231@2x.png" alt="image"></p><p>程序中的括号等信息不必出现在抽象语法树中。除了括号，句尾的分号等无关紧要的单词通常也不会出现在抽象语法树中。</p><blockquote><p>抽象化原本指的就是去除多余的内容，抽取出事物的本质。</p></blockquote><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="分割单词-1"><a href="#分割单词-1" class="headerlink" title="分割单词"></a>分割单词</h3><p>使用正则表达式来分割单词，支持</p><blockquote><p># ## ### ```</p></blockquote><p>以下面为例</p><blockquote><p># 标题</p><p>```</p><p>x = 1</p><p>y = x + 2</p><p>```</p></blockquote><h4 id="单词序列-1"><a href="#单词序列-1" class="headerlink" title="单词序列"></a>单词序列</h4><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000609@2x.png" alt="image"></p><p>部分代码</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@regex</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">^</span><span class="token comment" spellcheck="true">###)|(^##)|(^#)|(^```)|(.+)/</span><span class="token keyword">def</span> read  <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">readlines</span><span class="token punctuation">(</span><span class="token variable">@filename</span><span class="token punctuation">)</span><span class="token punctuation">.</span>each_with_index <span class="token keyword">do</span> <span class="token operator">|</span>line<span class="token punctuation">,</span> i<span class="token operator">|</span>    <span class="token comment" spellcheck="true"># i 从 0 开始 需要先 + 1</span>    <span class="token variable">@line_number</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>    <span class="token function">readline</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">readline</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>  array <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token variable">@regex</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> array<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span>    array<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>item<span class="token operator">|</span>      <span class="token function">add_token</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">add_token</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token keyword">if</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nil</span>    token <span class="token operator">=</span> <span class="token constant">Token</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'H3'</span><span class="token punctuation">,</span> <span class="token variable">@line_number</span><span class="token punctuation">)</span>  <span class="token keyword">elsif</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nil</span>    token <span class="token operator">=</span> <span class="token constant">Token</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'H2'</span><span class="token punctuation">,</span> <span class="token variable">@line_number</span><span class="token punctuation">)</span>  <span class="token keyword">elsif</span> item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nil</span>    token <span class="token operator">=</span> <span class="token constant">Token</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'H1'</span><span class="token punctuation">,</span> <span class="token variable">@line_number</span><span class="token punctuation">)</span>  <span class="token keyword">elsif</span> item<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nil</span>    token <span class="token operator">=</span> <span class="token constant">Token</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'Code'</span><span class="token punctuation">,</span> <span class="token variable">@line_number</span><span class="token punctuation">)</span>  <span class="token keyword">elsif</span> item<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">nil</span>    token <span class="token operator">=</span> <span class="token constant">Token</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'Text'</span><span class="token punctuation">,</span> <span class="token variable">@line_number</span><span class="token punctuation">,</span> item<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">else</span>    <span class="token keyword">raise</span> <span class="token string">"bad token at line <span class="token interpolation"><span class="token delimiter tag">#{</span>@line_number<span class="token delimiter tag">}</span></span>"</span>  <span class="token keyword">end</span>  <span class="token variable">@queue</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> token<span class="token keyword">end</span></code></pre><h3 id="构造抽象语法树"><a href="#构造抽象语法树" class="headerlink" title="构造抽象语法树"></a>构造抽象语法树</h3><p>抽象语法树使用栈转树的方式实现</p><h4 id="抽象语法树-1"><a href="#抽象语法树-1" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p><img src="https://www.tuliang.org/images/2018/QQ20181119-000209@2x.png" alt="image"></p><p>部分代码</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> ast_runner  index <span class="token operator">=</span> <span class="token number">0</span>  ast <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 遍历队列</span>  <span class="token keyword">while</span> <span class="token variable">@queue</span><span class="token punctuation">.</span>length <span class="token operator">></span> index <span class="token keyword">do</span>    token <span class="token operator">=</span> <span class="token variable">@queue</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">case</span> token<span class="token punctuation">.</span>type    <span class="token keyword">when</span> <span class="token string">'H1'</span><span class="token punctuation">,</span> <span class="token string">'H2'</span><span class="token punctuation">,</span> <span class="token string">'H3'</span>      <span class="token comment" spellcheck="true"># H1 H2 H3 规则</span>      node <span class="token operator">=</span> <span class="token constant">ASTList</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># index 向后移动 1 位 指向下个节点 </span>      index <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>      next_node <span class="token operator">=</span> <span class="token variable">@queue</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 去除左边的空格</span>      next_node<span class="token punctuation">.</span>text<span class="token punctuation">.</span>lstrip<span class="token operator">!</span>      <span class="token comment" spellcheck="true"># 将节点附加到 children 末尾</span>      node<span class="token punctuation">.</span>children <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token constant">ASTLeaf</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>next_node<span class="token punctuation">)</span>    <span class="token keyword">when</span> <span class="token string">'Text'</span>      <span class="token comment" spellcheck="true"># Text 规则 </span>      <span class="token comment" spellcheck="true"># 直接生成叶子节点</span>      node <span class="token operator">=</span> <span class="token constant">ASTLeaf</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>    <span class="token keyword">when</span> <span class="token string">'Code'</span>      <span class="token comment" spellcheck="true"># Code 规则 </span>      node <span class="token operator">=</span> <span class="token constant">ASTList</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Code 未闭合前一直循环</span>      <span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>        <span class="token comment" spellcheck="true"># index 向后移动 1 位 指向下个节点 </span>        index <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        next_node <span class="token operator">=</span> <span class="token variable">@queue</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>        <span class="token keyword">if</span> next_node<span class="token punctuation">.</span>type <span class="token operator">==</span> <span class="token string">'Code'</span>          <span class="token comment" spellcheck="true"># 当前节点为闭合节点 退出循环</span>          <span class="token keyword">break</span>        <span class="token keyword">else</span>          <span class="token comment" spellcheck="true"># 将节点附加到 children 末尾</span>          node<span class="token punctuation">.</span>children <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token constant">ASTLeaf</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>next_node<span class="token punctuation">)</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>    <span class="token keyword">else</span>      <span class="token keyword">raise</span> <span class="token string">"bad token type at line <span class="token interpolation"><span class="token delimiter tag">#{</span>token<span class="token punctuation">.</span>line_number<span class="token delimiter tag">}</span></span>"</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true"># 将节点附加到 ast 末尾</span>    ast <span class="token operator">&lt;</span><span class="token operator">&lt;</span> node    <span class="token comment" spellcheck="true"># index 向后移动 1 位 进行下个迭代</span>    index <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>  <span class="token keyword">end</span>  ast<span class="token keyword">end</span></code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre class=" language-shell"><code class="language-shell">$ ruby lexer.rbH1 └── Ruby Markdown一个使用 Ruby 实现的 Markdown 编译器H2 └── 解释器与编译器H3 └── 解释器解释器根据程序中的算法执行运算。简单来讲，它是一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似于机器语言的程序设计语言写成，这种软件也能称为虚拟机。H3 └── 编译器编译器能将某种语言写成的程序转换为另一种语言的程序。通常它会将原程序转换为机器语言。编译器转换程序的行为称为编译，转换前的程序称为源代码或源程序。如果编译器没有把源代码直接转换为机器语言，一般称为源代码转换器或源码转换器（source code translator）。过去人们提到编译器时，首先会联想到费时的编译过程。不过由于编译后实际执行的是机器语言，因此执行速度很快。而对于解释器，人们通常认为它会在程序输入的同时立即执行，执行速度较慢。这就是两者的基本区别。现代的解释器内部常采用各种类型的编译器，已经越来越没有必要将解释器和编译器区分看待。H2 └── 运行Code └── ruby lexer.rbCode ├── lexer = Lexer.new("README.md") ├── parser = lexer.parser ├── parser.show └── puts parser.to_html</code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Ruby Markdown<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>一个使用 Ruby 实现的 Markdown 编译器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>解释器与编译器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>解释器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>解释器根据程序中的算法执行运算。简单来讲，它是一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似于机器语言的程序设计语言写成，这种软件也能称为虚拟机。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>编译器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>编译器能将某种语言写成的程序转换为另一种语言的程序。通常它会将原程序转换为机器语言。编译器转换程序的行为称为编译，转换前的程序称为源代码或源程序。如果编译器没有把源代码直接转换为机器语言，一般称为源代码转换器或源码转换器（source code translator）。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>过去人们提到编译器时，首先会联想到费时的编译过程。不过由于编译后实际执行的是机器语言，因此执行速度很快。而对于解释器，人们通常认为它会在程序输入的同时立即执行，执行速度较慢。这就是两者的基本区别。现代的解释器内部常采用各种类型的编译器，已经越来越没有必要将解释器和编译器区分看待。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>运行<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>ruby lexer.rb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>lexer = Lexer.new("README.md")<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>parser = lexer.parser<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>parser.show<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>puts parser.to_html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 <code>分割单词</code> 获得单词序列到 <code>构造抽象语法树</code>，再到<code>生成代码</code>，基本上实现了一个最简单的编译器。</p><p>在做的过程中你会发现编译原理的确是大作业，细做的话每一步，有太多东西，另外解释器也不简单。</p><ul><li><a href="https://www.tuliang.org/qian-tan-markdown-bian-yi-qi/" target="_blank" rel="noopener">博客地址 浅谈 Markdown 编译器</a></li><li><a href="https://github.com/tuliang/ruby-markdown" target="_blank" rel="noopener">项目代码 ruby-markdown</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/25908672/" target="_blank" rel="noopener">两周自制脚本语言</a></li><li><a href="https://www.bilibili.com/video/av17649289" target="_blank" rel="noopener">编译原理（哈工大）</a></li><li><a href="http://rednaxelafx.iteye.com/blog/492667" target="_blank" rel="noopener">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览数实践</title>
      <link href="/liu-lan-shu-shi-jian/"/>
      <url>/liu-lan-shu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览数实践"><a href="#浏览数实践" class="headerlink" title="浏览数实践"></a>浏览数实践</h1><p>我们分析一下，浏览数更新很频繁，那么使用传统的关系型数据库并不合适。</p><p>那么使用 <code>Memcached</code> 呢？也不太合适，有 <code>2</code> 点，一是 <code>Memcached</code> 没有原子性的增量 increment 能力，二是数据持久化的问题。</p><p>综上所述，<code>Redis</code> 是最好的选择。</p><p>添加 <code>gem</code></p><pre class=" language-ruby"><code class="language-ruby">gem <span class="token string">'redis'</span><span class="token punctuation">,</span> <span class="token string">'~> 4.0'</span></code></pre><p>在 <code>config</code> 中新建文件 <code>redis.rb</code></p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">"redis"</span><span class="token variable">$redis</span> <span class="token operator">=</span> <span class="token constant">Redis</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>host<span class="token punctuation">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token punctuation">:</span> <span class="token number">6379</span><span class="token punctuation">)</span></code></pre><p>在对应的 <code>Modle</code> 中添加方法</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> up_hits  <span class="token variable">$redis</span><span class="token punctuation">.</span><span class="token function">hincrby</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"hits"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">def</span> hits  <span class="token variable">$redis</span><span class="token punctuation">.</span><span class="token function">hget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"hits"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_i<span class="token keyword">end</span><span class="token keyword">def</span> key  <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span>downcase<span class="token delimiter tag">}</span></span>_<span class="token interpolation"><span class="token delimiter tag">#{</span>id<span class="token delimiter tag">}</span></span>"</span><span class="token keyword">end</span></code></pre><p>在对应的 <code>Controller</code> 中使用</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@example</span><span class="token punctuation">.</span>up_hits</code></pre><p>在对应的 <code>View</code> 中使用</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@example</span><span class="token punctuation">.</span>hits</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grep 显示标题</title>
      <link href="/grep-xian-shi-biao-ti/"/>
      <url>/grep-xian-shi-biao-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="grep-显示标题"><a href="#grep-显示标题" class="headerlink" title="grep 显示标题"></a>grep 显示标题</h1><p>我们使用 <code>grep</code> 获取信息时，结果会丢失标题。</p><pre class=" language-shell"><code class="language-shell">$ ps aux | head -1; ps aux | grep nginxdeploy   25879  0.0  0.0   9000   376 pts/0    R+   18:38   0:00 grep --color=auto nginxroot     32065  0.0  0.0  36836  5932 ?        Ss   Nov10   0:00 nginx: master process nginx -g daemon off;systemd+ 32128  0.0  0.0  37340  3840 ?        S    Nov10   0:00 nginx: worker process</code></pre><p><code>Google</code> 一下可以找到一个方法：</p><p>先用命令本身加 <code>head -1</code> 取到标题，然后再使用该命令输出内容，两者叠加输出即得到所要结果。</p><pre class=" language-shell"><code class="language-shell">$ ps aux | head -1; ps aux | grep nginxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDdeploy   25879  0.0  0.0   9000   376 pts/0    R+   18:38   0:00 grep --color=auto nginxroot     32065  0.0  0.0  36836  5932 ?        Ss   Nov10   0:00 nginx: master process nginx -g daemon off;systemd+ 32128  0.0  0.0  37340  3840 ?        S    Nov10   0:00 nginx: worker process</code></pre><p>这种方法似乎就是我们想要的解决方案了，但是问题是命令要运行 2 次。</p><p>我们回想一下 <code>grep</code> 的本质是什么？它其实是使用正则表达式去获取信息。</p><p>以上面的命令为例，丢失标题问题的本质是因为我们使用时，告诉 <code>grep</code> 去查找包含 <code>nginx</code> 的信息，而标题里面并没有 <code>nginx</code>。</p><p>想清楚了这一点，那么只要我们同时匹配标题的一部分，只运行 <code>1</code> 次命令，也可以实现同样的效果。</p><pre class=" language-shell"><code class="language-shell">$ ps aux | grep -E 'PID|nginx'USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDdeploy   25879  0.0  0.0   9000   376 pts/0    R+   18:38   0:00 grep --color=auto nginxroot     32065  0.0  0.0  36836  5932 ?        Ss   Nov10   0:00 nginx: master process nginx -g daemon off;systemd+ 32128  0.0  0.0  37340  3840 ?        S    Nov10   0:00 nginx: worker process</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>成为技术领导者</title>
      <link href="/cheng-wei-ji-zhu-ling-dao-zhe/"/>
      <url>/cheng-wei-ji-zhu-ling-dao-zhe/</url>
      
        <content type="html"><![CDATA[<h1 id="成为技术领导者"><a href="#成为技术领导者" class="headerlink" title="成为技术领导者"></a>成为技术领导者</h1><blockquote><p>所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。</p></blockquote><h2 id="领导方式模型"><a href="#领导方式模型" class="headerlink" title="领导方式模型"></a>领导方式模型</h2><blockquote><p>想要让人变化，环境中必须包含三个因素。</p></blockquote><ul><li>M 激励 <code>motivation</code> —— 奖品或是磨难，用来激励或惩罚相关的人。</li><li>O 组织 <code>organization</code> —— 现实的组织结构，将想法化为实践。</li><li>I 头脑或创新 <code>ideas or innovation</code> —— 种子，对未来图景的想象。</li></ul><blockquote><p>领导力也可能意味着阻碍变化。如果你希望阻止某些变化，那么做到以下三条之一就可以了。</p></blockquote><ul><li>打击激励 —— 让人觉得变化是不受欢迎的；替他们包办，这样他们就不必自己执行；如果人们处于兴趣而乐意去做事，要扫他们的兴。</li><li>增添混乱 —— 鼓励恶性竞争，让合作变得不可想象；提供的资源应该比必需的最低限度还要少一点；封锁具有公有价值的信息，或是用无聊的谈话和文件埋没它。</li><li>阻碍思维 —— 如果能批评，就不要倾听；你的想法要在第一位，声音要最大；惩罚那些提出建议的家伙；不让人们在一起工作；最重要的是，坚决禁止说笑。</li></ul><h2 id="创新的三大障碍"><a href="#创新的三大障碍" class="headerlink" title="创新的三大障碍"></a>创新的三大障碍</h2><ul><li>看不到自己，看不到自己的行为，所以没有机会改变。</li><li>没问题综合症，欺骗自己，以为早就知道所有问题的答案。</li><li>相信经院心理学的中心教条，看不见其他办法，即时你不需要他人帮助就能找到的这些办法。</li></ul><blockquote><p>任何实际问题都存在不止一个方法，只是目前还没人知道。</p></blockquote><h2 id="帮助其他人会发生的问题"><a href="#帮助其他人会发生的问题" class="headerlink" title="帮助其他人会发生的问题"></a>帮助其他人会发生的问题</h2><ul><li>希望帮助他人可能是高尚的动机，但这不会降低帮助的难度。</li><li>如果对方不希望接受你的帮助，无论你多么聪明、多么出色，都不能成功地帮助他们。</li><li>有效帮助的开始，只能是双方都同意对问题的清晰定义。</li><li>一定要多加检查，确认对方是否需要你的帮助。</li><li>即便人们承认他们需要你的帮助，这种承认也是会变的。</li><li>希望帮助其他人的人，通常都希望有所回报，虽然他们可能并没有察觉到这一点。</li><li>大多数人都知道，提供帮助的人也是自私的，却又认为自己是例外。</li><li>无论看起来多奇怪，大多数人其实是希望帮助他人的。</li></ul><h2 id="学会激励他人"><a href="#学会激励他人" class="headerlink" title="学会激励他人"></a>学会激励他人</h2><blockquote><p>保持真诚（无论你是否刻意）。</p></blockquote><h2 id="解决问题团队的有效组织形式"><a href="#解决问题团队的有效组织形式" class="headerlink" title="解决问题团队的有效组织形式"></a>解决问题团队的有效组织形式</h2><p>问题的关键在于，要知道的不是<strong>最好</strong>的方法，而是在<strong>当前情况下</strong>最好的方法。情况变了，团队也需要跟着改变。没有哪种组织方式永远是最好的，也没有哪种组织方式能够在长时间内<strong>保持</strong>最好。最高效有力的领导是这样的人：他们能够帮助团队认识环境的变化，并找到合适的组织决策方式。</p><h2 id="学习成为组织者"><a href="#学习成为组织者" class="headerlink" title="学习成为组织者"></a>学习成为组织者</h2><p>成为有力的组织者需要<strong>实践</strong>，而且要反复实践。理论是重要的，但它无法杜绝所有错误。组织人的理论可能互相矛盾，如果没有实践经验作为指导，你甚至都无法理解它们。</p><p>简单地说，参加任何一类活动，你都能体会到，不同的组织形式下不同职位上的感觉。如果你发现自己说：“啊，我干不了<strong>这个</strong>”，这就是最好的起点。借此，你能填补自己经历中最大的空白。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在准备说或者做可能后悔的事情之前，先试着镇静一段时间，然后问自己三个问题：</p><ol><li>我为什么要做这件事？</li><li>我有什么资本？</li><li>我有什么不足？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 方法论 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 个人管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective Ruby 改善Ruby程序的48条建议</title>
      <link href="/effective-ruby-gai-shan-ruby-cheng-xu-de-48-tiao-jian-yi/"/>
      <url>/effective-ruby-gai-shan-ruby-cheng-xu-de-48-tiao-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-Ruby-改善Ruby程序的48条建议"><a href="#Effective-Ruby-改善Ruby程序的48条建议" class="headerlink" title="Effective Ruby 改善Ruby程序的48条建议"></a>Effective Ruby 改善Ruby程序的48条建议</h1><h2 id="留神，常量是可变的"><a href="#留神，常量是可变的" class="headerlink" title="留神，常量是可变的"></a>留神，常量是可变的</h2><blockquote><p>总是将常量冻结 <code>freeze</code>，从而防止其被改变。</p></blockquote><p>不使用 <code>freeze</code> ，常量可以修改。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token constant">MY_CONSTANT</span> <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token constant">MY_CONSTANT</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"bar"</span>puts <span class="token constant">MY_CONSTANT</span> <span class="token comment" spellcheck="true">#=> "foobar"</span></code></pre><p>使用 <code>freeze</code> ，常量无法修改。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token constant">MY_CONSTANT</span> <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">.</span>freeze<span class="token constant">MY_CONSTANT</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"bar"</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen String)</span></code></pre><blockquote><p>如果常量引用了一个集合对象比如数组或散列，那么冻结整个集合及其所有元素。</p></blockquote><p>这个 <code>tip</code> 已经落伍，在 <code>Ruby 2.2</code> 及后续版本会自动冻结整个集合及其所有元素。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># in Ruby >= 2.1</span><span class="token constant">NETWORKS</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"192.168.1"</span><span class="token punctuation">,</span> <span class="token string">"192.168.2"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>freeze<span class="token constant">NETWORKS</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"192.168.3"</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen Array)</span><span class="token constant">NETWORKS</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"192.168.3"</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen Array)</span>user <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"name"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"name"</span> <span class="token punctuation">}</span><span class="token punctuation">.</span>freezeuser<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"email"</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen Hash)</span>user<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"name2"</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen Hash)</span></code></pre><blockquote><p>要防止常量被重新赋值，可以冻结定义它的那个模块。</p></blockquote><p>常量使用 <code>freeze</code>，<code>ruby</code> 出现 <code>warning</code> 但是依然能够被重新赋值。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token constant">Defaults</span>  <span class="token constant">TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">.</span>freeze<span class="token keyword">end</span><span class="token constant">Defaults</span><span class="token punctuation">:</span><span class="token symbol">:TIMEOUT</span> <span class="token operator">=</span> <span class="token number">6</span> <span class="token comment" spellcheck="true">#=> warning: already initialized constant Defaults::TIMEOUT</span><span class="token comment" spellcheck="true">#=> warning: previous definition of TIMEOUT was here</span>puts <span class="token constant">Defaults</span><span class="token punctuation">:</span><span class="token symbol">:TIMEOUT</span> <span class="token comment" spellcheck="true">#=> 6</span></code></pre><p>冻结模块后，常量无法赋值。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token constant">Defaults</span>  <span class="token constant">TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">end</span><span class="token constant">Defaults</span><span class="token punctuation">.</span>freeze<span class="token constant">Defaults</span><span class="token punctuation">:</span><span class="token symbol">:TIMEOUT</span> <span class="token operator">=</span> <span class="token number">6</span> <span class="token comment" spellcheck="true">#=> FrozenError (can't modify frozen Module)</span></code></pre><h2 id="推荐使用-Struct-而非-Hash-存储结构化数据"><a href="#推荐使用-Struct-而非-Hash-存储结构化数据" class="headerlink" title="推荐使用 Struct 而非 Hash 存储结构化数据"></a>推荐使用 Struct 而非 Hash 存储结构化数据</h2><blockquote><p>在处理结构化数据时，如果创建一个新类不那么合适时，推荐使用 <code>Struct</code> 而非 <code>Hash</code></p><p>将 <code>Struct::new</code> 的返回值赋给常量，并像类一样使用它。</p></blockquote><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># Hash</span>reading <span class="token operator">=</span> <span class="token punctuation">{</span> date<span class="token punctuation">:</span> <span class="token string">"2018-10-30"</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">mean</span><span class="token punctuation">(</span>reading<span class="token punctuation">)</span>  <span class="token punctuation">(</span>reading<span class="token punctuation">[</span><span class="token symbol">:high</span><span class="token punctuation">]</span> <span class="token operator">+</span> reading<span class="token punctuation">[</span><span class="token symbol">:low</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token keyword">end</span><span class="token function">mean</span><span class="token punctuation">(</span>reading<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#=> 25.0</span><span class="token comment" spellcheck="true"># Struct</span><span class="token constant">Reading</span> <span class="token operator">=</span> <span class="token builtin">Struct</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token symbol">:date</span><span class="token punctuation">,</span> <span class="token symbol">:high</span><span class="token punctuation">,</span> <span class="token symbol">:low</span><span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token keyword">def</span> <span class="token function">mean</span>    <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span class="token constant">Reading</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">"2018-10-30"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean <span class="token comment" spellcheck="true">#=> 25.0</span></code></pre><h2 id="在改变作为参数的集合之前复制它们"><a href="#在改变作为参数的集合之前复制它们" class="headerlink" title="在改变作为参数的集合之前复制它们"></a>在改变作为参数的集合之前复制它们</h2><blockquote><p><code>Ruby</code> 中参数是按引用传递的，而不是值传递。这个规则有一个例外值得注意：它不适用于 <code>Fixnum</code> 对象。</p><p>在改变集合之前先复制它们。</p></blockquote><p><code>Ruby</code> 语言自带了两个用来复制对象的方法：<code>dup</code> 和 <code>clone</code>。它们都会基于接收者创建新的对象，但是与 <code>dup</code> 方法不同的是，<code>clone</code> 方法会保留原始对象的两个附加特性。</p><p>首先，<code>clone</code> 方法会保留接收者的冻结状态。如果原始对象的状态是冻结的，那么生成的副本也是冻结的。而 <code>dup</code> 方法就不同了，它永远不会返回冻结的对象。</p><p>其次，如果接收者中存在单例方法，使用 <code>clone</code> 方法也会复制单例类。由于 <code>dup</code> 方法不会这样做，所以当使用 <code>dup</code> 方法时，原始对象和使用 <code>dup</code> 方法创建的副本对于相同消息的响应可能是不同的。</p><p>多数情况下应使用 <code>dup</code> 方法而不是 <code>clone</code> 方法，特别是当你希望修改结果对象时。冻结对象时无法修改或是解冻的，所以 <code>clone</code> 方法可能会返回一个不可变的对象。由于我们要去对新对象进行修改，因此 <code>dup</code> 方法显然是更合适的选择。</p><blockquote><p><code>dup</code> 方法和 <code>clone</code> 方法只会进行浅拷贝。</p></blockquote><p>复制传入集合是一种常见的模式。但要小心，使用这样的方法存在潜在的危险。你要知道 <code>dup</code> 方法和 <code>clone</code> 方法返回的是浅拷贝对象。对于像 <code>Array</code> 一样的集合，这意味着仅仅复制了容器本身而没有复制其中的元素。</p><p>可以在不影响原始集合的情况下增添或移除其中的元素，但修改元素本身则是有影响的。原始集合及其副本引用了相同的元素对象。修改任一元素都会影响到集合本身，同样也会影响到任何引用这一元素的对象。</p><pre class=" language-ruby"><code class="language-ruby">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Polar"</span><span class="token punctuation">]</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>dup <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Bear"</span><span class="token comment" spellcheck="true">#=> ["Polar", "Bear"]</span>b<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> x<span class="token punctuation">.</span>sub<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">'lar'</span><span class="token punctuation">,</span> <span class="token string">'oh'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#=> ["Pooh", "Bear"]</span>a<span class="token comment" spellcheck="true">#=> ["Pooh"]</span></code></pre><blockquote><p>对于多数对象来说，可以使用 <code>Marshal</code> 来完成深拷贝。</p></blockquote><p>可以使用 <code>Marshal</code> 类将一个集合及其所持有的元素序列化，然后再反序列化：</p><pre class=" language-ruby"><code class="language-ruby">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Monkey"</span><span class="token punctuation">,</span> <span class="token string">"Brains"</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token constant">Marshal</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token constant">Marshal</span><span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#=> ["Monkey", "Brains"]</span>b<span class="token punctuation">.</span><span class="token keyword">each</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token symbol">:upcase!</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#=> ["MONKEY", "BRAINS"]</span>a<span class="token comment" spellcheck="true">#=> ["Monkey", "Brains"]</span></code></pre><p>使用 <code>Marshal</code> 来解决这一问题这某种程度上有一定的局限性。抛开对对象序列化和反序列化的时间不说，你还得考虑这一过程中需要的内存。毫无疑问，对象的副本会持有其本身的内存空间，而使用 <code>Marshal::dump</code> 中序列化时创建的字节流也是会占用内存的。转储和加载大对象会使程序消耗大内存更多。</p><p>一个潜在的更加严峻的问题时并非所有对象都可以被 <code>Marshal</code> 序列化。那些持有闭包的对象以及那些具有单例方法的对象时无法被序列化的。<code>Ruby</code> 的一些核心类也是不能被 <code>Marshal</code> 序列化的。这包括 <code>IO</code> 以及 <code>File</code> 等类型。对于所有这样的情形，在使用 <code>Marshal::dump</code> 进行序列化时会抛出一个 <code>TypeError</code> 异常。</p><h2 id="了解如何通过-reduce-方法折叠集合"><a href="#了解如何通过-reduce-方法折叠集合" class="headerlink" title="了解如何通过 reduce 方法折叠集合"></a>了解如何通过 reduce 方法折叠集合</h2><blockquote><p>总是要给累加器一个初值。</p><p>给予 <code>reduce</code> 的块总是要返回一个累加器。对当前累加器的修改是可行的，要记住从块中返回。</p></blockquote><p>假设我们有一个存储用户的数组，我们希望从中筛选出那些年龄大于或者等于 <code>21</code> 岁的人群。之后我们希望将这个用户数组转换成一个姓名数组。在没有使用 <code>reduce</code> 的时候，你可能会这样写：</p><pre class=" language-ruby"><code class="language-ruby">users<span class="token punctuation">.</span>select <span class="token punctuation">{</span><span class="token operator">|</span>u<span class="token operator">|</span> u<span class="token punctuation">.</span>age <span class="token operator">>=</span> <span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token symbol">:name</span><span class="token punctuation">)</span></code></pre><p>当然这么做肯定是可行的，但并不高效。<code>select</code> 方法会遍历整个用户数组并返回新数组。这个新数组之后会再次进行遍历并映射成另一个值只包含名字的新数组。如果我们使用 <code>reduce</code> ，则无需创建或遍历多个数组：</p><pre class=" language-ruby"><code class="language-ruby">users<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>names<span class="token punctuation">,</span> user<span class="token operator">|</span>  names <span class="token operator">&lt;</span><span class="token operator">&lt;</span> user<span class="token punctuation">.</span>name <span class="token keyword">if</span> user<span class="token punctuation">.</span>age <span class="token operator">>=</span> <span class="token number">21</span>  names<span class="token keyword">end</span></code></pre><h2 id="力争代码被有效测试过"><a href="#力争代码被有效测试过" class="headerlink" title="力争代码被有效测试过"></a>力争代码被有效测试过</h2><blockquote><p>使用模糊测试和属性测试工具，帮助测试代码的快乐路径和异常路径。</p></blockquote><p>在测试中，一个常犯的错误是我们只写快乐路径 <code>happy path</code> 测试。这是刚写完开发代码之后写测试时常见的情况。快乐路径测试，是指被测代码的前提条件都被满足的前提下，仅测试有效出入的测试方法。</p><p>有时候我们可能没有验证输入的合法性，而且中数据库中也没有添加不可为空的约束。快乐路径测试是有价值的，但是这不足以帮我们发现所有的 <code>bug</code>，因为制定的测试只测试了我们期望代码该做的事。</p><p>解决这个问题的一种方法是加入异常路径 <code>exception path</code> 测试，输入各种各样的值并保证代码的每一个分支都被执行过。例如模糊测试 <code>fuzz testing</code> 和属性测试 <code>property testing</code>。</p><p>这两种测试既互有联系，但又有不同的目的。基本思想都是，给我们的代码输入大量不同类型的数据，保证我们的代码依然能够正常工作。一般来说，模糊测试主要是应用于安全领域。向一个程序或者特定的方法输入大量随机的数据，是找出程序崩溃或暴露安全漏洞的一种非常好的方法。</p><p>采用模糊测试方法，我们的关注点从测试结果是通过还是失败，转移到是否能找到程序崩溃或者是异常问题上。这个过程通常需要一个随机值的发生器 <code>generator</code> 和我们需要测试的代码片段。举个例子，假如我们想知道 <code>URL::HTTP::build</code> 方法是否会在输入完全随机的无效主机名 <code>host name</code> 后崩溃？针对这个问题我们可以使用 <code>Ruby</code> 模糊测试库中的一个名为 <code>FuzzBert</code> 的 <code>Gem</code>。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'fuzzbert'</span><span class="token punctuation">)</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'uri'</span><span class="token punctuation">)</span><span class="token function">fuzz</span><span class="token punctuation">(</span><span class="token string">'URI::HTTP::build'</span><span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"random server names"</span><span class="token punctuation">)</span> <span class="token keyword">do</span>    <span class="token constant">FuzzBert</span><span class="token punctuation">:</span><span class="token symbol">:Generators</span><span class="token punctuation">.</span>random  <span class="token keyword">end</span>  deploy <span class="token keyword">do</span> <span class="token operator">|</span>data<span class="token operator">|</span>    <span class="token constant">URI</span><span class="token punctuation">:</span><span class="token symbol">:HTTP</span><span class="token punctuation">:</span><span class="token symbol">:build</span><span class="token punctuation">(</span>host<span class="token punctuation">:</span> data<span class="token punctuation">,</span> path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>模糊测试虽说非常有趣，但并不适合日常使用。部分原因是，像 <code>FuzzBert</code> 这样的工具会持续不断地运行测试，除非你手动终止。为了让模糊测试更加高效，有时需要它连续运行好几天。<code>FuzzBert</code> 提供了配置选项，允许我们设置模糊测试运行的时间，不过测试运行的时间越长，你将越有信心相信代码里没有让系统崩溃的 <code>bug</code> 存在。</p><p>与模糊测试相似，属性测试也使用随机输入来测试你的代码，但所添加测试的期望是确定的。属性测试相对来说，显得更加实际，因为测试是有限的，而且可以与自动化单元测试一起运行。我们可以使用 <code>MrProper</code> 进行属性测试。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'mrproper'</span><span class="token punctuation">)</span><span class="token function">properties</span><span class="token punctuation">(</span><span class="token string">'Version'</span><span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">Integer</span><span class="token punctuation">,</span> <span class="token builtin">Integer</span><span class="token punctuation">,</span> <span class="token builtin">Integer</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token function">property</span><span class="token punctuation">(</span><span class="token string">"new(str).to_s == str"</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>data<span class="token operator">|</span>    str <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>    <span class="token function">assert_equal</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token constant">Version</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span>to_s<span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><blockquote><p>测试覆盖率工具会给你一种虚假的安全感，因为被执行过的代码不代表这行代码是正确的。</p></blockquote><p>代码覆盖率工具可以生成测试报告，告诉你测试时哪些代码被执行过。<code>SimpleCov</code> 能生成非常详细的 <code>HTML</code> 报告，涵盖工程中所有的源代码。但是它会给你一种虚假的安全感，因为被执行过的代码不代表这行代码是正确的。你仍然需要确保对执行的代码分支编写了有效的测试。</p><blockquote><p>在编写特性的同时就加上测试，会让测试容易很多。</p></blockquote><p>无论使用哪种测试工具，都有一些规则需要你遵守。最重要的一点是，尽早写测试，越早越好。等到接近项目尾声再写为时已晚。一方面，这会让测试脱离现有的项目，成为单独的项目；另一方面，到那时候你可能已经忘了哪些重要的属性需要被测试。所以说，在编写特性的同时就加上测试，会让测试容易很多。</p><blockquote><p>这你开始寻找导致 <code>bug</code> 的根本原因之前，先写一个针对该 <code>bug</code> 的测试。</p></blockquote><p>在寻找导致 <code>bug</code> 的根本原因之前，先写一个能够重现这个 <code>bug</code> 的测试。重现 <code>bug</code> 是修复 <code>bug</code> 的第一步，若有专门针对这个 <code>bug</code> 的测试，就可以保证在我们修复  <code>bug</code> 之后，它不会再次出现。</p><blockquote><p>尽可能多地自动化你的测试。</p></blockquote><p>最后，尽可能多地自动化你的测试。有最好的测试，但不去运行他们，那么这些测试也毫无用处。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>容器基础-隔离和限制</title>
      <link href="/rong-qi-ji-chu-ge-chi-he-xian-zhi/"/>
      <url>/rong-qi-ji-chu-ge-chi-he-xian-zhi/</url>
      
        <content type="html"><![CDATA[<p>容器技术的核心功能，就是通过修改和约束进程的动态表现，从而为其创造出一个“空间”。</p><p>对于 <code>Docker</code> 等大多数 <code>Linux</code> 容器来说，<code>Namespace</code> 技术是用来修改进程视图的主要方法，而 <code>Cgroups</code> 技术是用来制造约束的主要手段 。</p><h4 id="障眼法"><a href="#障眼法" class="headerlink" title="障眼法"></a>障眼法</h4><p>每当我们在主机上运行一个程序，操作系统都会给它分配一个进程编号，比如 <code>PID=100</code>，这个编号是进程的唯一标识。</p><p>而我们通过 <code>Docker</code> 把这个程序运行在一个容器当中时，<code>Docker</code> 就会对这个进程的空间做手脚。使得这些进程只能看到重新计算过的进程编号，比如 <code>PID=1</code>。可实际上，它们在宿主机的操作系统里，还是原来 <code>PID=100</code> 进程。</p><p>这种技术，就是 <code>Linux</code> 里面的 <code>Namespace</code> 机制。</p><p>而除了我们刚刚用到的 <code>PID Namespace</code>，<code>Linux</code> 操作系统还提供了 <code>Mount</code>、<code>UTS</code>、<code>IPC</code>、 <code>Network</code> 和 <code>User</code> 这些 <code>Namespace</code> ，用来对各种不同的进程上下文进行“障眼法”操作。</p><p>比如，<code>Mount Nmaespace</code>，用于 让被隔离进程只看到当前 <code>Namespace</code> 里的挂载点信息；<code>Network Namespace</code>，用于让被隔离进程看到当前 <code>Namespace</code> 里的网络设备和配置。</p><p>这就是 <code>Linux</code> 容器最基本的实现原理。</p><p>所以，<code>Docker</code> 容器这个听起来模糊的概念，实际上是最创建容器进程时，指定了这个进程所需要启用的一组 <code>Namespace</code> 参数。这样，容器就只能“看”到当前 <code>Namespace</code> 所限定的资源、文件、设备、状态、配置等等。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p><blockquote><p>到此，我们明白了。容器，其实是一种特殊的进程而已。</p></blockquote><h4 id="紧箍咒"><a href="#紧箍咒" class="headerlink" title="紧箍咒"></a>紧箍咒</h4><p>上面提到，容器，其实是一种特殊的进程。那么我们使用  <code>Namespace</code>  技术只是让容器进程看不到外界，在宿主机上，它和其他所有进程之间依然是平等的竞争关系。这就是意味着，虽然容器进程表面上被隔离了，但是它依然可以使用宿主机的所有资源，或者是它的资源被宿主机上其他进程抢占。这些情况，显然都不是我们想要的。</p><p><code>Cgroups</code> 就是 <code>Linux</code> 内核中用来为进程设置资源限制的一个重要功能。它的全称是 <code>Linux Control Group</code>，作用就是限制一个进程组能够使用的资源上限，包括 <code>CPU</code>、内存、磁盘、网络带宽等等。此外，它还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。</p><p><code>Cgroups</code> 的设计还是比较易用的，简单地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。具体对于 <code>Docker</code> 来说，只需要在每个子系统下面，为每个容器创建一个控制组，然后在启动容器进程之后，把这个进程的 <code>PID</code> 填写到对应控制组的 <code>tasks</code> 文件中就可以了。</p><p>至于在这些控制组下面的资源文件填上什么值，就靠用户执行 <code>docker run</code> 时的参数指定了，比如这样一条命令：</p><pre class=" language-bash"><code class="language-bash">$ docker run -it --cpu-period<span class="token operator">=</span>100000 --cpu-quota<span class="token operator">=</span>20000 ubuntu /bin/bash</code></pre><p>在启动这个容器后，我们可以通过查看 <code>Cgroups</code> 文件系统下，<code>CPU</code> 子系统中，<code>docker</code> 这个控制组里面的资源限制文件来确认：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 100000$ <span class="token function">cat</span> /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 20000</code></pre><p>这就是意味着这个 <code>Docker</code> 容器，只能使用到 20% 到 <code>CPU</code> 带宽。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过以上讲述，我们理解了一个 <code>Docker</code> 容器，其实就是一个启用了 <code>Namespace</code> 的进程，而这个进程使用到资源受到 <code>Cgroups</code>  限制。</p><blockquote><p>这是容器技术中一个非常重要的概念，即：容器是一个“单进程”模型。</p></blockquote><p>这是因为容器本身的设计，就是希望容器和应用能够同生命周期，这个概念对容器编排非常重要。否则，一旦出现类似“容器上正常运行的，但是里面的应用挂了”的情况，编排系统处理起来就非常麻烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何高效学习</title>
      <link href="/ru-he-gao-xiao-xue-xi/"/>
      <url>/ru-he-gao-xiao-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>整体性学习策略强调将信息编织到知识网络中，而不是给自己加上机械记忆的负担，这个策略的基础有以下几方面。</p><ol><li>结构 —— 关于某个学科的知识之间联系的总和，它是你大脑中的城市。</li><li>模型 —— 将信息压缩成最基本的单元，模型是结构的种子。形成模型的方法包括比喻法、内在化和图表法，模型是你的知识道路交通图中主要的几个十字路口。</li><li>高速公路 —— 不同结构之间的联系，有助于创造性的思考。“跳出盒子之外思考”很好地描述了这种跳出原有结构，从其他结构来观察原有结构的思考方式。</li></ol><p>整体性学习有 5 个步骤，但是并非按部就班，只是大体按此顺序进行，不能拘泥于这种顺序。</p><ol><li>获取 —— 通过感官获取信息。</li><li>理解 —— 明白信息的表面意思。</li><li>拓展 —— 与其他信息建立联系，拓展有三种主要方法。<ul><li>深度拓展 —— 探究知识的背景。</li><li>横向拓展 —— 探究知识的关系。</li><li>纵向拓展 —— 与其他结构联系后，从其他结构的角度探究知识。</li></ul></li><li>纠错 —— 剔除错误联系。</li><li>应用 —— 将知识应用到各种情景中去，包括现实生活。</li></ol><p>信息的消化吸收类似于食物的消化吸收，不管你吃的是什么，过程是一样的，但是吃的东西可以大不相同。认清不同的信息类型有助于选择不同的学习方法，信息的类型有以下五种。</p><ol><li>随意信息 —— 事实、日期、列表、规则以及某种顺序。信息特点是没有逻辑分类或相互关系不强。</li><li>观点信息 —— 信息的唯一目的就是支持或者反对某种观点。容量中这儿是最重要的，二不是能记住。</li><li>过程信息 —— 它是指某种技能的信息。需要反复练习，但是容易记住。</li><li>具体信息 —— 容易视觉化的信息，一般是与实际紧密联系的信息，容易有自己的经验。</li><li>抽象信息 —— 信息不容易有自己的经验。数学、哲学和物理学都是非常抽象的领域。</li></ol><h3 id="技术一览"><a href="#技术一览" class="headerlink" title="技术一览"></a>技术一览</h3><h4 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h4><ol><li>指读法</li><li>练习阅读。</li><li>积极阅读，改善边读边学的效率。</li></ol><h4 id="笔记流"><a href="#笔记流" class="headerlink" title="笔记流"></a>笔记流</h4><ol><li>不要呆板、僵硬、貌似层次分明的笔记。</li><li>中写下来的观点之间建立联系。</li></ol><h4 id="比喻法"><a href="#比喻法" class="headerlink" title="比喻法"></a>比喻法</h4><p>寻找历史中的故事、图像或是过程，它与我们现在学习的东西有某种类似。</p><h4 id="内在化"><a href="#内在化" class="headerlink" title="内在化"></a>内在化</h4><ol><li>为你正在学习的东西创造脑海中的图像。</li><li>在这幅图像上加上其他感官和情感。</li><li>寻找图像不合适或不足的地方，防止产生错误的联系。</li></ol><h4 id="图表法"><a href="#图表法" class="headerlink" title="图表法"></a>图表法</h4><p>创造流程图、概念图或图像，将若干观念联系在一起。</p><h4 id="联想法"><a href="#联想法" class="headerlink" title="联想法"></a>联想法</h4><ol><li>创造一系列容易视觉化的符号。</li><li>在条目之间创造联系，这种联系是可以“看得见的奇特场景”。</li><li>在第一个条目和触发物之间建立联系。</li></ol><h4 id="挂钩法"><a href="#挂钩法" class="headerlink" title="挂钩法"></a>挂钩法</h4><p>与联想法相似，只不过我们是把每一个条目与事先建立好、容易回忆的 0～12 的视觉符号相联系。</p><h4 id="信息压缩"><a href="#信息压缩" class="headerlink" title="信息压缩"></a>信息压缩</h4><p>3 种主要形式：</p><ol><li>记忆术 —— 压缩若干知识，用一个单词代替。</li><li>图像联系 —— 创造一幅能联系若干知识的图像。</li><li>笔记压缩法 —— 用寥寥几页纸缩写内容庞大的笔记。</li></ol><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>寻找将知识用于你日常生活的途径。</p><h4 id="模型纠错"><a href="#模型纠错" class="headerlink" title="模型纠错"></a>模型纠错</h4><p>经常性地解决各种问题，以发现整体性知识网络中的潜在错误。</p><h4 id="以项目为基础的学习"><a href="#以项目为基础的学习" class="headerlink" title="以项目为基础的学习"></a>以项目为基础的学习</h4><p>建立一个大约需要 1～3 个月完成的项目，从而逼迫自己不断学习、实践和解决各种各样的问题。这对自我教育来说是有用的练习，特别是在没有什么知识结构可以指导时。</p><h4 id="高效率学生"><a href="#高效率学生" class="headerlink" title="高效率学生"></a>高效率学生</h4><ol><li>管理能量。<ul><li>保持体型，健康饮食，不要熬夜。</li><li>一周休息一天。</li></ul></li><li>不要“学习”。</li><li>绝不拖延<ul><li>建立每周目标和每日目标清单以保持注意力。</li></ul></li><li>将那些类似的、散在的工作集中起来批量完成。</li><li>有组织。<ul><li>拥有一个日历和做事清单，永远随身携带一个笔记本。</li></ul></li></ol><h4 id="自我教育"><a href="#自我教育" class="headerlink" title="自我教育"></a>自我教育</h4><p>自我教育费用低廉、方便迅速、收益大，但是实行起来也有很多难点。它缺乏系统安排，较传统教育学起来难度更大，提高自学能力大主要办法有以下几种。</p><ol><li>养成良好习惯。</li><li>克服挫折障碍。</li><li>设定学习目标，记录学习过程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 中 NGINX 挂载应用的静态文件</title>
      <link href="/docker-zhong-nginx-gua-zai-ying-yong-de-jing-tai-wen-jian/"/>
      <url>/docker-zhong-nginx-gua-zai-ying-yong-de-jing-tai-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Docker</code> 中 <code>NGINX</code> 如何获得应用的静态文件呢？</p><p>一般来说这种共享文件的需求，我们需要使用 <code>volumes</code></p><p>假如静态文件的地址是 <code>/home/app/app_name/public</code></p><p>那么我们在中 <code>docker-compose.yml</code> 中设置 <code>volumes</code></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token key atrule">public</span><span class="token punctuation">:</span> <span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span>        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> public<span class="token punctuation">:</span>/home/app/app_name/public  <span class="token key atrule">web</span><span class="token punctuation">:</span>        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> public<span class="token punctuation">:</span>/home/app/app_name/public</code></pre><p>记得在 <code>nginx.conf</code> 设置 <code>root</code></p><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true"># define the public application root  </span>   <span class="token keyword">root</span>  <span class="token operator">/</span>home<span class="token operator">/</span>app<span class="token operator">/</span>app_name<span class="token operator">/</span>public<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul><li><a href="https://docs.docker.com/compose/compose-file/#volumes" target="_blank" rel="noopener">Compose file version 3 reference</a></li><li><a href="https://docs.docker.com/storage/volumes/#start-a-container-with-a-volume" target="_blank" rel="noopener">Use volumes</a></li><li><a href="https://stackoverflow.com/questions/42232051/docker-compose-volumes-from-equivalent-with-version-3" target="_blank" rel="noopener">docker-compose volumes_from equivalent with version 3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大型网站系统与 Java 中间件开发实践</title>
      <link href="/da-xing-wang-zhan-xi-tong-yu-java-zhong-jian-jian-kai-fa-shi-jian/"/>
      <url>/da-xing-wang-zhan-xi-tong-yu-java-zhong-jian-jian-kai-fa-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>阿姆达尔定律（Amdahl’s law）告诉我们，程序中可并行代码的比例决定你增加处理器所能带来的速度提升上限，是否能达到这个上限，还取决于很多其他因素。</p><p>例如，当 P=0.5 时，我们可以计算出速度提升的上限就是 2。而如果 P=0.2，速度提升的上限就是1.25。可见，在多核的时代，并发程序的开发或者说提升程序的并发性是多么重要。</p><p>$$S(N) = \frac{1}{(1-P)+\frac{P}{N}}$$</p><p>其中，P 指的是程序中科并行部分的程序在单核上执行时间的占比，N 表示处理器的个数（总核心数）。S(N) 是指程序在 N 个处理器相对在单个处理器中的速度提升比。</p><hr><p>对于单机系统来说，我们如果不使用多进程方式的话，基本不会遇到独立的故障。就是说在单机系统上的单进程程序，如果是机器问题、OS问题或者程序自身的问题，基本的结果就是我们的程序整体不能用了，不会出现一些模块不行另一些模块可以的情况。而在分布式系统中，整个系统的一部分有问题而其他部分正常是经常出现的情况，我们称之为故障独立性。我们在实现分布式系统的时候，必须要找到应对和解决故障独立性的办法。</p><hr><p>搜索集群（Search Cluster）的使用方式和读库的使用方式是一样的。只是构建索引的过程基本都是需要我们自己来实现的。可以从两个维度对于搜索系统构建索引的方式进行划分，一种是按照全量/增量划分，一种是按照实时/非实时划分。全量方式用于第一次建立索引（可能是新建，也可能是重建），而增量方式用于在全量的基础上持续更新索引。当然，增量构建索引的挑战非常大，一般会加入每日的全量作为补充。实时/非实时的划分方式则体现在索引更新的时间上了。我们当然更倾向于实时的方式，之所以有非实时方式，主要是考虑到对数据源头的保护。</p><hr><p>在 Java 中，我们主要使用的线程池就是 ThreadPoolExecutor，此外还有定时的线程池 ScheduledThreadPoolExecutor。需要注意的是对于 Executors.newCachedThreadPool() 方法返回的线程池的使用，该方法返回的线程池是没有线程上限的，在使用时一定要当心，因为没有办法控制总体的线程数量，而每个线程都是消耗内存的，这可能会导致过多的内存被占用。建议尽量不要用这个方法返回的线程池，而要使用有固定线程上限的线程池。</p><hr><p>与 synchronized 及 ReentrantLock 等提供的互斥相比，volatile 只是提供了变量的可见性支持。同一个变量线程间的可见性与多个线程中操作互斥是两件事情，操作互斥是提供了操作整体的原子性，千万不要混淆了。</p><p>volatile 可以立刻在其他线程看到新的值，因为 volatile 保证了只有一份主存中的数据。synchronized 调用后必须在修饰的方法或代码块中读取才可以看到最新值，因为 synchronized 不仅会把当前线程修改的变量的本地副本同步给主存，还会从主存读取数据更新本地副本，这样 synchronized 保证了代码块的串行执行。</p><hr><p>服务注册查找中心并不处在调用者和服务提供者之间，服务注册查找中心对于调用者来说，只是提供可用的服务提供者的列表，这有点像日常生活中类似 114 的查号服务。不过处于效率的考虑，我们并不是在每次调用远程服务前都通过这个服务注册查找中心来查找可用地址，而是把地址缓存在调用者本地，当有变化时主动从服务注册查找中心发起通知，告诉调用者可用的服务提供者列表的变化。</p><hr><p>在不靠升级硬件的情况下，能够想到的处理方案就是给现有数据库减压。减压的思路有三个，一是优化应用，看看是否有不必要的压力给了数据库（应用优化）；二是看看有没有其他方法可以降低数据库的压力，例如引入缓存、加搜索引擎等；最后一种思路就是把数据库的数据和访问分到多台数据库上，分开支持，这也是我们的核心思路和逻辑。</p><p>数据库拆分有两种方式，一个是垂直拆分，一个水平拆分。垂直拆分就是把一个数据库中不同业务单元的数据分到不同的数据库里面，水平拆分是根据一定的规则把同一业务单元的数据拆分到多个数据库中。先论是垂直拆分还是水平拆分，最后的结果都是将原来在一个数据库中的数据拆分到了不同的数据库中。所以原来单机数据库可以支持的特性现在就未必支持了。</p><p>垂直拆分会带来如下影响: </p><ul><li>单机的 ACID 保证被打破了。数据到了多机后，原来在单机通过事务来进行处理逻辑会受到很大的影响。我们面临的选择是，要么放弃原来的单机事务，修改实现，要么引入分布式事务。</li><li>一些 join 操作会变得比较困难，因为数据可能已经在两个数据库中了，所以不能很方便地利用数据库本身 join 了，需要应用或者其他方式来解决。</li><li>靠外键去进行约束的场景会受影响。</li></ul><p>水平拆分会带来如下影响: </p><ul><li>同样有可能有 ACID 被打破的情况。</li><li>同样有可能有 join 操作被影响的情况。</li><li>靠外键去进行约束的场景会受影响。</li><li>依赖单库的自增序列生成唯一 ID 会受影响。</li><li>针对单个逻辑意义上的表的查询要跨库了。</li></ul><p>PS: ACID，指数据库事务正确执行的四个基本要素的缩写。包含: 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。</p><hr><p>一致性哈希所带来的最大变化是把节点对应的哈希值变为了一个范围，而不再是离散的。在一致性哈希中，我们会把整个哈希值的范围定义得非常大，然后把这个范围分配给现有的节点。如果有节点加入，那么这个新节点会从原有的某个节点上分管一部分范围的哈希值；如果有节点退出，那么这个节点原来管理的哈希值会给它的下一个节点来管理。</p><p>新增一个节点时，除了新增的节点外，只有一个节点受影响，这个新增节点和受影响的节点的负载是明显比其他节点低的；减少一个节点时，除了减去的节点外，只有一个节点受影响，它要承担自己原来的和减去的节点的工作，压力明显比其他节点要高。这似乎要增加一倍节点或减去一半节点才能保持各个节点的均衡负载。如果真是这样，一致性哈希的优势就不明显了。</p><p>为了应对上述问题，我们引入虚拟节点的概念。即多个物理节点可以变为很多个虚拟节点，每个虚拟节点支持连续的哈希环上的一段。而这时如果加入一个物理节点，就会相应加入很多虚拟节点，这些新的虚拟节点是相对均匀地插入到整个哈希环上的，这样，就可以很好地分担现有物理节点的压力了；如果减少了一个物理节点，对应的很多虚拟节点就会失效，这样就会有很多剩余的虚拟节点来承担之前虚拟节点的工作，但是对于物理节点来说，增加的负载相对是均衡的。所以可以通过一个物理 节点对应非常多的虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布的方式来解决增加或减少节点时负载不均衡的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby thread pool</title>
      <link href="/ruby-thread-pool/"/>
      <url>/ruby-thread-pool/</url>
      
        <content type="html"><![CDATA[<p>有时候会遇到一个情况需要在多个远程服务获取数据。</p><p>例如服务 <code>a</code> 需要 <code>2</code> 秒，服务 <code>b</code> 需要 <code>5</code> 秒，按照正常处理总共就需要 <code>2+5</code> 总共 <code>7</code> 秒了。</p><p>如果 <code>a</code> 和 <code>b</code> 之间并没有相互依赖关系，我们可以使用 <code>thread pool</code> 来并发获取数据，将总体耗时由 <code>a + b</code> 降低到 <code>a、b</code> 两者中的最大值。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'thread/pool'</span><span class="token keyword">require</span> <span class="token string">'thread/future'</span><span class="token keyword">require</span> <span class="token string">'benchmark'</span><span class="token keyword">def</span> a  sleep <span class="token number">2</span>  <span class="token string">'a'</span><span class="token keyword">end</span><span class="token keyword">def</span> b  sleep <span class="token number">5</span>  <span class="token string">'b'</span><span class="token keyword">end</span><span class="token constant">Benchmark</span><span class="token punctuation">.</span>bmbm <span class="token keyword">do</span> <span class="token operator">|</span>x<span class="token operator">|</span>  x<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"normal"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     puts <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span>a<span class="token delimiter tag">}</span></span><span class="token interpolation"><span class="token delimiter tag">#{</span>b<span class="token delimiter tag">}</span></span>"</span>  <span class="token punctuation">}</span>  x<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"Thread.future"</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>     pool <span class="token operator">=</span> <span class="token builtin">Thread</span><span class="token punctuation">.</span>pool <span class="token number">2</span>    f1 <span class="token operator">=</span> pool<span class="token punctuation">.</span>future <span class="token punctuation">{</span>      a    <span class="token punctuation">}</span>    f2 <span class="token operator">=</span> pool<span class="token punctuation">.</span>future <span class="token punctuation">{</span>      b    <span class="token punctuation">}</span>    puts <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token operator">~</span>f1<span class="token delimiter tag">}</span></span><span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token operator">~</span>f2<span class="token delimiter tag">}</span></span>"</span>  <span class="token punctuation">}</span><span class="token keyword">end</span></code></pre><p>使用 Benchmark 对比，和我们设想的完全一样。</p><pre><code>Rehearsal -------------------------------------------------normal        ab  0.000000   0.000000   0.000000 (  7.010414)Thread.future ab  0.000000   0.000000   0.000000 (  5.002781)---------------------------------------- total: 0.000000sec                    user     system      total        realnormal        ab  0.000000   0.000000   0.000000 (  7.004402)Thread.future ab  0.000000   0.000000   0.000000 (  5.003263)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby synchronized</title>
      <link href="/ruby-synchronized/"/>
      <url>/ruby-synchronized/</url>
      
        <content type="html"><![CDATA[<p>最近学习 <code>Java</code> 的时候了解到在 <code>Java</code> 中 <code>synchronized</code> 关键字可以保证代码块的串行执行。</p><p>在 <code>ruby</code> 开发中往往使用第三方来保证，比如使用数据库或文件系统。其实 <code>ruby</code> 也有类似的方式来保证代码块的串行执行，它就是 <code>Mutex</code> 的 <code>synchronize</code>。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'thread'</span>semaphore <span class="token operator">=</span> <span class="token constant">Mutex</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token class-name">a</span> <span class="token operator">=</span> <span class="token builtin">Thread</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span>  semaphore<span class="token punctuation">.</span>synchronize <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># access shared resource</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>b <span class="token operator">=</span> <span class="token builtin">Thread</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span>  semaphore<span class="token punctuation">.</span>synchronize <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># access shared resource</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rails Singular Resources</title>
      <link href="/rails-singular-resources/"/>
      <url>/rails-singular-resources/</url>
      
        <content type="html"><![CDATA[<p><code>Rails</code> 中 <code>Controller</code> 如果不是复数，写 <code>path</code> 或 <code>url</code> 的时候就必须加上 <code>index</code>，这样看上去就很 <code>low</code>。</p><pre class=" language-ruby"><code class="language-ruby">resources <span class="token symbol">:photo</span> <span class="token keyword">do</span>    collection <span class="token keyword">do</span>    get <span class="token string">'search'</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment" spellcheck="true"># search_photo_index GET    /photo/search(.:format)</span></code></pre><p>我们查看 <a href="http://guides.rubyonrails.org/routing.html#singular-resources" target="_blank" rel="noopener">文档</a>，发现可以这样做</p><pre class=" language-ruby"><code class="language-ruby">resource <span class="token symbol">:photo</span><span class="token punctuation">,</span> controller<span class="token punctuation">:</span> photo <span class="token keyword">do</span>    collection <span class="token keyword">do</span>    get <span class="token string">'search'</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment" spellcheck="true"># search_photo GET    /photo/search(.:format)</span></code></pre><p>需要注意的是经过这样修改后，访问 <code>/photo</code> 不再调用 <code>index action</code> 而是调用 <code>show action</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网页渲染数学公式</title>
      <link href="/wang-ye-xuan-ran-shu-xue-gong-shi/"/>
      <url>/wang-ye-xuan-ran-shu-xue-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>数学公式一般使用 LaTeX，但是在网页上一般将 LaTeX 渲染成为图片。</p><p>在一堆文字中放进几个图片难看又麻烦，稍微找了一下发现一个神器: <a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a></p><p>使用它很简单: </p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config<span class="token punctuation">=</span>TeX-MML-AM_CHTML<span class="token punctuation">'</span></span> <span class="token attr-name">async</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>现在你可以在 <code>$$</code> 和 <code>$$</code> 之间书写 LaTeX 了: </p><pre><code>$$J_\alpha(x) = \sum\limits_{m=0}^\infty \frac{(-1)^m}{m! \, \Gamma(m + \alpha + 1)}{\bigl({\frac{x}{2}}\bigr)}^{2 m + \alpha}$$</code></pre><p>$$<br>J_\alpha(x) = \sum\limits_{m=0}^\infty \frac{(-1)^m}{m! \, \Gamma(m + \alpha + 1)}{\bigl({\frac{x}{2}}\bigr)}^{2 m + \alpha}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象设计实践指南-Ruby语言描述</title>
      <link href="/mian-xiang-dui-xiang-she-ji-shi-jian-zhi-nan-ruby-yu-yan-miao-shu/"/>
      <url>/mian-xiang-dui-xiang-she-ji-shi-jian-zhi-nan-ruby-yu-yan-miao-shu/</url>
      
        <content type="html"><![CDATA[<p>设计是保留可变性的艺术，而非达到完美性的行为。</p><p>编写出的代码应该具有如下几个特点:   </p><ul><li>透明性（Transportation）: 在所更改的代码，以及在远处依赖于它的代码里，更改所产生的后果应该显而易见。  </li><li>合理性（Reasonable）: 任何更改所产生的成本都应该于更改所要带来的效益成正比。  </li><li>可用性（Usable）: 现有代码在新的环境和意想不到的环境里都能使用。  </li><li>典范性（Exemplary）: 代码本身应该鼓励那些为了延续这些特点面对它进行的更改。  </li></ul><p>这四个特点简写为TRUE。</p><p>选择依赖方向:   </p><ul><li>有些类比其他类更容易发生需求变化。  </li><li>具体类比抽象类更容易发生变化。  </li><li>更改拥有许多依赖关系的类会造成广泛的影响。  </li></ul><p>从基于消息的角度比从基于类的角度更能产生出灵活的应用程序。将那个基本设计问题从“我知道我需要这个类，那该怎么办？”转变为“我需要发送这条消息，谁该响应它呢？”<br>你发送消息不是因为你有对象，你有了对象是因为你要发送消息。</p><p>请询问“要什么”，别告知“如何做”。<br>“我知道我需要什么，并且我知道你是怎么做的。” &gt;&gt; “我知道我需要什么，并且我知道你会做什么。” &gt;&gt; “我知道你需要什么，并且我相信你回做好你的本职工作。”<br>这种模式可以不用修改调用者，便能达到扩展它的目的。<br>PS: 感觉这个和做管理是同样的道理，面对新手是第一句，面对胜任者是第二句，面对专家则是第三句。</p><p>子类是其父类的特殊化。子类应该包含父类的一切内容，外加更多内容。任何期待父类的对象都应该能与子类进行交互，完全不需要知道它实际的类。</p><p>有些问题需要在其他不相关的对象之间共享行为。这种公共行为对类来说正交的，它是对象所扮演的角色。这些关系与经典继承要求的子类/父类关系有所不同。许多语言都提供了某种方式，可以一次定义一组命名方法。这些命名方法独立于类，并且可以混入任何对象。在Ruby里，这种混入内容都被称为模块（module）。</p><p>继承和模块的差别在于“是一个”还是“像一个”。</p><p>抽象父类里的所有代码都应该适用于每一个继承它的类。父类不应该包含只适用于部分（而非全部）子类的代码。这个限制也适用于模块: 在模块里的代码必须能够适用于所有使用它的那些类型。</p><p>钩子方法的局限性在于它仅适用于创建浅层结构。为了把自身的钩子和父类的钩子进行组合，子类将被迫改写钩子，并在其内部发送super消息。  </p><ul><li>将继承用于“是什么”关系  </li><li>将鸭子类型用于“表现得像什么”关系  </li><li>将组合用于“有什么”关系  </li></ul><p>保留未使用的代码比删除之后再恢复它们所花费的成本更高。</p><p>测试应该把私有方法隐藏起来，而不应该将它们暴露出来。  </p><ul><li>这种测试有些冗余  </li><li>私有方法不稳定  </li><li>测试私有方法会误导人去使用它们  </li></ul><p>如果你的对象拥有大量私有方法，以至于你必须对它们进行测试，那么请考虑将这些方法提取为新对象。提取出来的方法可以作为这个新对象的责任核心，并因此构成它的公共接口。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 文件下载和查看</title>
      <link href="/web-wen-jian-xia-zai-he-cha-kan/"/>
      <url>/web-wen-jian-xia-zai-he-cha-kan/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-文件下载和查看"><a href="#Web-文件下载和查看" class="headerlink" title="Web 文件下载和查看"></a>Web 文件下载和查看</h1><p>在浏览器中点击一个文件链接，会被浏览器直接打开或者下载。<br>其实浏览器的行为是可以人为控制的，最简单的方法是使用 <code>HTML5 download Attribute</code>。</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- will download as "expenses.pdf" --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/files/expenses.pdf<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>expenses.pdf<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Download Your Expense Report<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>这种方式虽然简单，但是兼容性不太好。查看<a href="http://caniuse.com/download" target="_blank" rel="noopener">http://caniuse.com/download</a>，我们可以发现很多版本都不支持这个属性。</p><p>浏览器行为是由 <code>HTTP Head</code> 中的 <code>Content-Disposition</code> 来控制的，例如</p><pre class=" language-html"><code class="language-html">Content-Disposition: attachment; filename="fname.txt"</code></pre><p>它的意思是将该文件作为附件，并且下载的文件名是 <code>fname.txt</code>。</p><p>如果使用 <code>S3</code> 下载文件，使用 <code>AWS</code> 的 <code>api</code> 可以生成下载的 <code>url</code>:</p><pre class=" language-ruby"><code class="language-ruby">url <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">url_for</span><span class="token punctuation">(</span><span class="token symbol">:read</span><span class="token punctuation">,</span> response_content_disposition<span class="token punctuation">:</span> <span class="token string">"attachment; filename=\"<span class="token interpolation"><span class="token delimiter tag">#{</span>filename<span class="token delimiter tag">}</span></span>\""</span><span class="token punctuation">)</span></code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html</a></li><li><a href="http://docs.aws.amazon.com/AWSRubySDK/latest/AWS/S3/S3Object.html" target="_blank" rel="noopener">http://docs.aws.amazon.com/AWSRubySDK/latest/AWS/S3/S3Object.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> HTTP </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 更新 Emacs</title>
      <link href="/mac-geng-xin-emacs/"/>
      <url>/mac-geng-xin-emacs/</url>
      
        <content type="html"><![CDATA[<p>最近买了 <code>hhkb</code> 开始折腾 <code>Emacs</code>。</p><p><code>Mac</code> 自带 <code>Emacs</code>，但是版本比较老是 <code>Emacs22</code>，<code>Emacs24</code> 是现在最新的，有很多新功能，比如原生支持显示行数。</p><p>升级参考 wikemacs.org: <a href="http://wikemacs.org/index.php/Installing_Emacs_on_OS_X" target="_blank" rel="noopener">Installing Emacs on OS X</a></p><p>使用 <code>brew</code> 安装 <code>Emacs</code></p><pre class=" language-sh"><code class="language-sh">brew update  brew install emacs --cocoa  ln -s /usr/local/Cellar/emacs/24.3/Emacs.app /Applications  </code></pre><p>删除 <code>Mac</code> 原生的 <code>Emacs</code></p><pre class=" language-sh"><code class="language-sh">sudo rm /usr/bin/emacs  sudo rm -rf /usr/share/emacs  </code></pre><p>大功告成~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3 圆角无效</title>
      <link href="/css3-yuan-jiao-wu-xiao/"/>
      <url>/css3-yuan-jiao-wu-xiao/</url>
      
        <content type="html"><![CDATA[<p>今天在做页面的时候遇到 <code>CSS3</code> 圆角无效的情况，实例代码: </p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector"><span class="token class">.category-menu</span> </span><span class="token punctuation">{</span>    <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> <span class="token number">14</span>px<span class="token punctuation">;</span>    <span class="token property">-moz-border-radius</span><span class="token punctuation">:</span> <span class="token number">14</span>px<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">14</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.category</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category-menu<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>featured<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Featured<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Highest Rated<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newest<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Newest Videos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><img src="/images/2013/QQ20131107-1.png">  </p><p>你会发现圆角居然没有出现！让我们加上边框看看发生了什么: </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.category-menu</span> </span><span class="token punctuation">{</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">3</span>px solid <span class="token hexcode">#BADA55</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/images/2013/QQ20131107-2.png"></p><p>仔细观察可以发现，圆角被类为category的div所设置背景挡住了。将 <code>background: #fff;</code> 注释，我们看到了圆角</p><p><img src="/images/2013/QQ20131107-3.png"></p><p>从此可以得出结论，<code>CSS3</code> 的圆角会被子元素的背景遮挡，从而产生圆角无效的假象。</p><p>问题找到了，但是如果要求鼠标移上类为<code>category</code> 的 <code>div</code> 时，相应的 <code>div</code> 背景变色，那怎么办呢？</p><p>天无绝人之路，只要给第一个设置左上和右上圆角，最后一个 <code>div</code> 设置左下和右下圆角，就可以完美解决这个问题了。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector"><span class="token class">.category</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.category</span><span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ff6633</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.first</span> </span><span class="token punctuation">{</span>    <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> <span class="token number">4</span>px <span class="token number">4</span>px <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">-moz-border-radius</span><span class="token punctuation">:</span> <span class="token number">4</span>px <span class="token number">4</span>px <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">4</span>px <span class="token number">4</span>px <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.last</span> </span><span class="token punctuation">{</span>    <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">4</span>px <span class="token number">4</span>px<span class="token punctuation">;</span>    <span class="token property">-moz-border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">4</span>px <span class="token number">4</span>px<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">4</span>px <span class="token number">4</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category-menu<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category first<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>featured<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Featured<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Highest Rated<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category last<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newest<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Newest Videos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Siege</title>
      <link href="/siege/"/>
      <url>/siege/</url>
      
        <content type="html"><![CDATA[<p><code>siege</code> 围攻是一个压力测试和评测工具，设计用于 <code>web</code> 开发这评估应用在压力下的承受能力。</p><p>可以模拟对一个 <code>web</code> 站点进行多用户的并发访问，记录每个用户所有请求过程的响应时间，并在一定数量的并发访问下重复进行。</p><h3 id="在-Mac-OS-X-下安装"><a href="#在-Mac-OS-X-下安装" class="headerlink" title="在 Mac OS X 下安装"></a>在 <code>Mac OS X</code> 下安装</h3><pre class=" language-sh"><code class="language-sh">wget http://download.joedog.org/siege/siege-3.0.5.tar.gztar -xvf siege-latest.tar.gzcd siege-*./configuremakesudo make install</code></pre><p>完毕后，查看是否安装成功，使用<code>which siege</code></p><h3 id="在-Ubuntu-下安装"><a href="#在-Ubuntu-下安装" class="headerlink" title="在 Ubuntu 下安装"></a>在 <code>Ubuntu</code> 下安装</h3><pre class=" language-sh"><code class="language-sh">sudo apt-cache search siegesudo apt-get install siege </code></pre><p>现在可以开始使用这个工具了，例如</p><pre class=" language-sh"><code class="language-sh">siege -c 300 -t 100s 127.0.0.1:3000</code></pre><p>参数详解</p><pre class=" language-sh"><code class="language-sh">-C,或–config 在屏幕上打印显示出当前的配置,配置是包括在他的配置文件$HOME/.siegerc中,可以编辑里面的参数,这样每次siege 都会按照它运行.  -v 运行时能看到详细的运行信息  -c n,或–concurrent=n 模拟有n个用户在同时访问,n不要设得太大,因为越大,siege 消耗本地机器的资源越多  -i,–internet 随机访问urls.txt中的url列表项,以此模拟真实的访问情况(随机性),当urls.txt存在是有效  -d n,–delay=n hit每个url之间的延迟,在0-n之间  -r n,–reps=n 重复运行测试n次,不能与 -t同时存在  -t n,–time=n 持续运行siege ‘n’秒(如10S),分钟(10M),小时(10H)  -l 运行结束,将统计数据保存到日志文件中siege .log,一般位于/usr/local/var/siege .log中,也可在.siegerc中自定义  -R SIEGERC,–rc=SIEGERC 指定用特定的siege 配置文件来运行,默认的为$HOME/.siegerc  -f FILE, –file=FILE 指定用特定的urls文件运行siege ,默认为urls.txt,位于siege 安装目录下的etc/urls.txt  -u URL,–url=URL 测试指定的一个URL,对它进行”siege “,此选项会忽略有关urls文件的设定  </code></pre><p>结果说明</p><pre class=" language-sh"><code class="language-sh">Transactions: 30000 hits //完成30000次处理  Availability: 100.00 % //100.00 % 成功率  Elapsed time: 68.59 secs //总共使用时间  Data transferred: 817.76 MB //共数据传输 817.76 MB  Response time: 0.04 secs //响应时间，显示网络连接的速度  Transaction rate: 437.38 trans/sec //平均每秒完成 437.38 次处理  Throughput: 11.92 MB/sec //平均每秒传送数据  Concurrency: 17.53 //实际最高并发连接数  Successful transactions: 30000 //成功处理次数  Failed transactions: 0 //失败处理次数  Longest transaction: 3.12 //每次传输所花最长时间  Shortest transaction: 0.00 //每次传输所花最短时间  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siege </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 彻底删除文件</title>
      <link href="/git-che-di-shan-chu-wen-jian/"/>
      <url>/git-che-di-shan-chu-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>一般 <code>git</code> 删除文件使用 <code>git rm</code> 就可以了，但是有时候某些文件你甚至不想让它出现在 <code>git</code> 的 <code>log</code>中。</p><p><code>github</code> 有<a href="https://help.github.com/articles/remove-sensitive-data" target="_blank" rel="noopener">一篇文章</a>详细说明了如何操作，经过尝试是可以成功将文件彻底删除，在 <code>log</code> 中都找不到。</p><p>比如删除根目录下的 <code>file</code> 文件夹彻底删除: </p><pre class=" language-sh"><code class="language-sh">git filter-branch --force --index-filter \  'git rm -rf -r --cached --ignore-unmatch file' \  --prune-empty --tag-name-filter cat -- --all</code></pre><p>然后: </p><pre class=" language-sh"><code class="language-sh">git push origin master --force</code></pre><p>这样 <code>git</code> 仓库中这个文件夹就被彻底删除了。</p><p>如果你还想清除本地的一些缓存，可以依次进行下面几部操作 </p><pre class=" language-sh"><code class="language-sh">rm -rf .git/refs/original/`git reflog expire --expire=now --allgit gc --prune=nowgit gc --aggressive --prune=now</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 神奇的分号</title>
      <link href="/php-shen-qi-de-fen-hao/"/>
      <url>/php-shen-qi-de-fen-hao/</url>
      
        <content type="html"><![CDATA[<p>今天在开发过程中，遇到两种分号的神奇问题，特此记录。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">echo</span> <span class="token string">'我是正常的分号'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'我是神奇的分号'</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>用肉眼无法分辨两种分号的区别，如果你使用 <code>win</code> 平台，上面两条语句都可以运行。但是如果你是 <code>unix</code> 或是 <code>linux</code> 则是语法错误。</p><p>根本原因是这是两种分号，他们的字符编码不同，<code>win</code> 同时支持这两种分号，而 <code>unix</code> 或是 <code>linux</code> 只支持其中一种。</p><p>这个现象和字母的大小写很类似，<code>win</code> 不区分大小写，而 <code>unix</code> 或是 <code>linux</code> 区分大小写。</p><p>使用下面这段代码就可以证明我们的猜想</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">';'</span> <span class="token operator">==</span> <span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">echo</span> <span class="token string">'相等'</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">echo</span> <span class="token string">'不相等'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>斯坦福-iPad 和 iPhone 应用开发(iOS5)</title>
      <link href="/si-tan-fu-ipad-he-iphone-ying-yong-kai-fa-ios5/"/>
      <url>/si-tan-fu-ipad-he-iphone-ying-yong-kai-fa-ios5/</url>
      
        <content type="html"><![CDATA[<p>师介绍</p><p>讲师: Paul Hegarty</p><p>介绍: 斯坦福大学软件工程学教授，主要教授iOS应用的开发、编程。</p><p>课程介绍</p><p>最新更新课程，适用于 <code>iOS 5</code>。</p><p>本课程介绍了使用 <code>iPhone SDK</code> (软件开发包)建造 <code>iPhone</code> 平台上的应用程序所需的工具和应用程序接口。</p><p>使用多点触控技术，为手机等终端设计用户互交界面等技术进行面向对象的设计。</p><p>其他主题包括: 内核动画、<code>bonjour</code> 网络、移动终端电量管理和性能测评。</p><p>预备知识: 抽象编程水平的C语言和编程经验。</p><p>第 1 课 MVC 和 Objective-C 介绍</p><p>第 2 课 我的第 一个苹果操作系统iOS</p><p>第 3 课 Objective-C</p><p>第 4 课 视图</p><p>第 5 课 协议与手势</p><p>第 6 课 多个MVC和延续符</p><p>第 7 课 iPad+Apps</p><p>第 8 课 视图控制器生命周期-图象视图、滚动视图、网络视图</p><p>第 9 课 Table Views</p><p>第 10 课 数据块和多线程</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><hr><h3 id="第-1-课-MVC-和-Objective-C-介绍"><a href="#第-1-课-MVC-和-Objective-C-介绍" class="headerlink" title="第 1 课 MVC 和 Objective-C 介绍"></a>第 1 课 MVC 和 Objective-C 介绍</h3><p>你会在本课程上学习数据库（databases），计算机网络设计（networking），多媒体程式设计（multimedia programming），多线程（multithreading），动画（animation）。</p><p><code>iOS</code> 是基于 <code>unix</code> 的系统。</p><p><code>iOS</code>可以分为下面 <code>4</code> 层: </p><ul><li>Cocoa Touch</li><li>Media</li><li>Core Services</li><li>Core OS</li></ul><p><code>iPad</code> 和 <code>iPhone</code> 应用大部分是在 <code>Cocoa Touch</code> 这一层上进行开发的。</p><p><code>Objective-C</code> 中的实现文件是 <code>m</code> 后缀名的文件。</p><hr><h3 id="第-2-课-我的第一个苹果操作系统iOS"><a href="#第-2-课-我的第一个苹果操作系统iOS" class="headerlink" title="第 2 课 我的第一个苹果操作系统iOS"></a>第 2 课 我的第一个苹果操作系统iOS</h3><p><code>storyboard</code> 是 <code>iOS5</code> 新增的功能，它的基本功能允许你同时在屏幕上显示所有 <code>MVC</code> 的关系。使用它，你能够看到 <code>MVC</code>是怎么交互作用的。</p><p>自动引用记数，Automatic Reference Counting (ARC)。它是 <code>iOS5</code> 中新特性，用于自动内存管理。</p><p><code>NSLog</code> 是格式化输出。例如</p><pre class=" language-c"><code class="language-c"><span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"digit pressed = %@"</span><span class="token punctuation">,</span> digit<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述代码中，<code>digit</code> 变量的值会在 <code>%@</code> 所在的位置输出。</p><hr><h3 id="第-3-课-Objective-C"><a href="#第-3-课-Objective-C" class="headerlink" title="第 3 课 Objective-C"></a>第 3 课 Objective-C</h3><p>类名称（Class Name），结构体（structs）、枚举类型（enumerated types）使用大写，其他不要用大写。</p><p>指针的强弱是用于表示指向对象的指针，而用于指向存储器的指针在 <code>iOS</code> 中几乎不用它。</p><p>强指针（strong）是指将所要做的事情通过指针被保持在堆中，而不把它分配道存储器。</p><p>弱指针（weak）的意思是只要有人，至少一个人用强指针指向它，就把这个存储内容保存在堆内。如果没别人指着它，并且你要把它扔出堆外，则把我的指向它的指针设为零。弱指针只在 <code>iOS5</code> 中应用程序运行时起作用。在iOS4中不能用弱指针，你只能用强指针，然后你还要亲自把它们归零。</p><p>大写的 <code>BOOL</code> 和小写的 <code>bool</code> 是一样的，一般使用大写的。</p><hr><h3 id="第-4-课-视图"><a href="#第-4-课-视图" class="headerlink" title="第 4 课 视图"></a>第 4 课 视图</h3><p>在 <code>Oc</code> 中，方法分为类方法和实例方法。</p><p>前置加号（+）的方法为类方法，这类方法是可以直接用类名来调用的，它的作用主要是创建一个实例。有人把它称为创建实例的工厂方法。</p><p>前置减号（-）的方法为实例方法，必须使用类的实例才可以调用的。</p><hr><h3 id="第-5-课-协议与手势"><a href="#第-5-课-协议与手势" class="headerlink" title="第 5 课 协议与手势"></a>第 5 课 协议与手势</h3><p><code>iOS</code> 中的协议最重要的两个用处是委托（delegates）和数据源（data sources）。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PI 3.14</span></code></pre><p><code>#define</code>关键字用来设定常量。例如设定常量PI的值为 <code>3.14</code>: </p><p><code>shouldAutorotateToInterfaceOrientation</code> 在 <code>iOS6</code> 中被弃用了，现在 <code>iOS6</code> 默认允许屏幕旋转。</p><p>按住 <code>Option</code> 键移动鼠标可以模拟两指手势，如果键盘上没有 <code>Option</code> 键，则可以使用 <code>Alt</code> 键。</p><hr><h3 id="第-6-课-多个-MVC-和延续符"><a href="#第-6-课-多个-MVC-和延续符" class="headerlink" title="第 6 课 多个 MVC 和延续符"></a>第 6 课 多个 MVC 和延续符</h3><p>如果前面的代码需要调用后面才声明的类，这个时候就需要使用类的前向引用。即在文件开头用 <code>@class</code> 关键字声明: </p><pre class=" language-c"><code class="language-c">@class ClassName<span class="token punctuation">;</span></code></pre><p>它告诉编译器，有一个类命名为 <code>ClassName</code>，然后向其保证，马上就会定义这个类，但是现在暂时还不对其定义。</p><p><code>segue</code> 是一个 <code>MVC</code> 跳转到另一个 <code>MVC</code> 的东西，它的作用是 <code>push</code>，即把新的 <code>MVC</code> 推送道屏幕上，另一个则滑出屏幕。</p><p>双击 <code>storyboard</code> 的背景，它会缩小来显示更多内容。</p><p>在 <code>iOS5</code> 才有 <code>storyboard</code>，所以 <code>iOS4</code> 是不兼容 <code>segue</code> 的。</p><p><code>@property</code> 用来定义一个类的属性。<br><code>@synthesize</code> 表示由编译器来自动实现属性的 <code>getter/setter</code> 方法，不需要你自己再手动去实现。在 <code>iOS6</code> 中 <code>@synthesize</code> 也可以不写了。</p><hr><h3 id="第-7-课-iPad-Apps"><a href="#第-7-课-iPad-Apps" class="headerlink" title="第 7 课 iPad+Apps"></a>第 7 课 iPad+Apps</h3><p><code>iPad</code> 上有两大独有的用户界面元素，一个是分屏视图，另一个是弹出窗口。</p><p><code>iOS5</code> 使用 <code>springs and struts</code> 模式来布局，<code>iOS6</code> 则默认使用自动布局。</p><p>取消选择 <code>Use Autolayout</code> 复选框，就可以使用旧版本的 <code>springs and struts</code> 模式。</p><p>如果布局比较复杂，建议使用自动布局，不过使用自动布局的程序将不兼容 <code>iOS5</code>。</p><hr><h3 id="第-8-课-视图控制器生命周期-图象视图、滚动视图、网络视图"><a href="#第-8-课-视图控制器生命周期-图象视图、滚动视图、网络视图" class="headerlink" title="第 8 课 视图控制器生命周期-图象视图、滚动视图、网络视图"></a>第 8 课 视图控制器生命周期-图象视图、滚动视图、网络视图</h3><p>覆盖指定初始化里的事项，大部分在 <code>viewDidLoad</code> 完成。</p><p><code>ViewWillAppear</code> 适合做两件事，就是最后一刻推迟等待进行一些消耗资源的事情和涉及几何特性的事情。</p><p><code>UIWebView</code> 是一个完整的网络浏览器，在 <code>Safari</code> 中可以进行的所有操作都可以在此视图中实现。</p><p>它基于 <code>Webkit</code> 这个平台创建，一个开源的 <code>HTML</code> 渲染框架。</p><p>它支持 <code>JavaScript</code>，虽然只能运行5秒钟，所以无法锁定住手机。</p><p>运行某些 <code>JavaScript</code>无限循环，它只允许 <code>JavaScript</code>分配10M内存，所以不会占用全部的手机内存。这个限制使 <code>HTML5+JavaScript</code>实现的游戏在 <code>iOS</code>平台上前景黯淡。</p><p><code>UIWebView</code> 非常有用，不仅可充当网页浏览器，还可以显示特定类型数据，比如 <code>PDF</code>。就像你用 <code>Safari</code> 打开一个 <code>PDF</code> 一样，记住 <code>UIWebView</code>其实就是一个 <code>Safari</code> 浏览器。</p><p><code>Transform</code> 是一种仿射变换，基本上就是缩放、平移和旋转。</p><hr><h3 id="第-9-课-Table-Views"><a href="#第-9-课-Table-Views" class="headerlink" title="第 9 课 Table Views"></a>第 9 课 Table Views</h3><p><code>Table Views</code>是 <code>iOS</code> 中显示列表的视图，它有四种基本的单元格类型，还可以自定义单元格。第一种是 <code>Subtitle</code>，它是粗体显示，底下带一行灰色副标题。</p><p><code>Basic</code> 类型下方则没有东西。<code>Right Detail</code> 和 <code>Subtitle</code>一样，只是里面的内容安放方式不一样，它是蓝色字体，在右边而不是显示在下方。<code>Left Detail</code> 也一样，不过方向对调了。</p><hr><h3 id="第-10-课-数据块和多线程"><a href="#第-10-课-数据块和多线程" class="headerlink" title="第 10 课 数据块和多线程"></a>第 10 课 数据块和多线程</h3><p>在 <code>iOS</code> 里面使用 <code>block</code> 来操作多线程。</p><p><code>JCD</code> 不是标准的 <code>C</code>，它是一个用于多线程的苹果机制。</p>]]></content>
      
      
      <categories>
          
          <category> 公开课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决 JavaScript 指向不明</title>
      <link href="/jie-jue-javascript-zhi-xiang-bu-ming/"/>
      <url>/jie-jue-javascript-zhi-xiang-bu-ming/</url>
      
        <content type="html"><![CDATA[<p>用面向对象的方式编写 <code>JavaScript</code> 时，在类中经常会出现 <code>this</code> 指向不明的问题。</p><p>解决这个问题很简单，在对象中将 <code>this</code> 指定给一个变量，然后都使用这个对象就可以了。</p><p>例如在类文件的最开始加上下述代码</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span></code></pre><p>这样在这个类中，<code>self</code> 就指向了 <code>this</code>，我们使用 <code>self</code> 这个变量，就可以不用担心 <code>this</code> 指向不明的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 忽略文件</title>
      <link href="/git-hu-lue-wen-jian/"/>
      <url>/git-hu-lue-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>使用 <code>git</code> 时，经常需要忽略一些文件，比如一些 <code>IDE</code> 生成的配置文件。</p><p>在项目目录加上 <code>.gitignore</code> 文件，然后加入需要忽略文件的文件名就可以了。</p><pre><code>.project</code></pre><p>需要注意的是，如果需要忽略 <code>.gitignore</code> 文件，那么文件中就要加上 <code>.gitignore</code></p><pre><code>.project.gitignore</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 变量声明提前</title>
      <link href="/javascript-bian-liang-sheng-ming-ti-qian/"/>
      <url>/javascript-bian-liang-sheng-ming-ti-qian/</url>
      
        <content type="html"><![CDATA[<p><code>JavaScript</code> 使用了函数作用域，变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p><p>到底是什么意思呢？我们来看下面这段代码</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>你可能认为输出是</p><pre><code>global  local  </code></pre><p>但是运行一下你就会发现实际结果是</p><pre><code>undefined  local  </code></pre><p>深入研究你会发现就算是你使用传递参数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实际结果依然是</p><pre><code>undefined  local  </code></pre><p>或者代码改写为</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> scope<span class="token punctuation">;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实际结果仍然是</p><pre><code>undefined  </code></pre><p>为什么，后面的代码能够影响到前面的代码？</p><p>照成这种结果的原因的就是前面提到的函数作用域，在 <code>JavaScript</code> 中上面的代码实际上是这样的</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> scope<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">'local'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>JavaScript</code> 这个特性被非正式地称为声明提前，即函数里声明的所有变量都被提前至函数体的顶部，但是这个声明提前至声明却不赋值。</p><p>由于拥有这种特性，在编写代码时一些程序员特意将变量声明放在函数体的顶部，而不是像其他语言中让变量声明和使用变量的代码尽量靠近。</p><p>所以在函数体中使用到 <code>var</code> 来声明变量时，记得将声明和赋值语句放在函数体的顶部，避免因为这种特性造成变量值为 <code>undefined</code> 的 <code>BUG</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 冒泡排序</title>
      <link href="/php-mou-pao-pai-xu/"/>
      <url>/php-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>使用递归实现冒泡排序</p><p><code>PHP</code> 多递归时需要 <code>return</code>，如下述代码中</p><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span> <span class="token variable">$count</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果改为</p><pre class=" language-php"><code class="language-php"><span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span> <span class="token variable">$count</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上层就接不到值，即结果为 <code>null</code></p><p>完整的代码实现</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//产生10个1到100的随机数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 冒泡排序 */</span><span class="token keyword">function</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span> <span class="token variable">$count</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$count</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//排序结束</span>    <span class="token keyword">return</span> <span class="token variable">$array</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$count</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将两个相邻的随机数做比较，</span>    <span class="token comment" spellcheck="true">//当第$i个随机数大于第$i+1个随机数时，</span>    <span class="token comment" spellcheck="true">//互换它们的位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//PHP中递归需要return，否则只能得到null</span>  <span class="token keyword">return</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span> <span class="token variable">$count</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$count</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$new_array</span> <span class="token operator">=</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">,</span> <span class="token variable">$count</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$new_array</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 工厂方法模式</title>
      <link href="/php-gong-han-fang-fa-mo-shi/"/>
      <url>/php-gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</p><p>有些开发人员的确是把这个编程习惯误认为是工厂模式。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//比萨商店</span><span class="token keyword">class</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token variable">$Factory</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$factory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">Factory</span> <span class="token operator">=</span> <span class="token variable">$factory</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">Factory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简单比萨工厂</span><span class="token keyword">class</span> <span class="token class-name">SimplePizzaFactory</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'cheese'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token string">'pepperoni'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PepperoniPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>工厂方法模式 <code>Factory Method Pattern</code>，定义了一个创建对象的接口，但由子类决定要实例化的是哪一个。</p><p>工厂方法让类把实例化推迟到子类。</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//比萨接口</span><span class="token keyword">interface</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//比萨1</span><span class="token keyword">class</span> <span class="token class-name">CheesePizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'CheesePizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'CheesePizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'CheesePizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'CheesePizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//比萨2</span><span class="token keyword">class</span> <span class="token class-name">PepperoniPizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'PepperoniPizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'PepperoniPizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'PepperoniPizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'PepperoniPizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//纽约比萨1</span><span class="token keyword">class</span> <span class="token class-name">NYCheesePizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYCheesePizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYCheesePizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYCheesePizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYCheesePizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//纽约比萨2</span><span class="token keyword">class</span> <span class="token class-name">NYPepperoniPizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYPepperoniPizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYPepperoniPizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYPepperoniPizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NYPepperoniPizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//芝加哥比萨1</span><span class="token keyword">class</span> <span class="token class-name">ChicagoCheesePizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoCheesePizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoCheesePizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoCheesePizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoCheesePizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//芝加哥比萨2</span><span class="token keyword">class</span> <span class="token class-name">ChicagoPepperoniPizza</span> <span class="token keyword">implements</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoPepperoniPizza prepare&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoPepperoniPizza bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoPepperoniPizza cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'ChicagoPepperoniPizza box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义比萨商店</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//纽约比萨店</span><span class="token keyword">class</span> <span class="token class-name">NYPizzaStore</span> <span class="token keyword">extends</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'cheese'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NYCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token string">'pepperoni'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NYPepperoniPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//芝加哥比萨店</span><span class="token keyword">class</span> <span class="token class-name">ChicagoPizzaStore</span> <span class="token keyword">extends</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'cheese'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChicagoCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token string">'pepperoni'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChicagoPepperoniPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$NYPizzaStore</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NYPizzaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ChicagoPizzaStore</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChicagoPizzaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$NYPizzaStore</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token string">'cheese'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ChicagoPizzaStore</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token string">'pepperoni'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出</p><pre><code>NYCheesePizza prepare  NYCheesePizza bake  NYCheesePizza cut  NYCheesePizza box  ChicagoPepperoniPizza prepare   ChicagoPepperoniPizza bake   ChicagoPepperoniPizza cut  ChicagoPepperoniPizza box  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 装饰者模式</title>
      <link href="/php-zhuang-shi-zhe-mo-shi/"/>
      <url>/php-zhuang-shi-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>装饰者模式 <code>Decorator Pattern</code> ，动态地将责任附加到对象上。</p><p>若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//饮料抽象类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Beverage</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token variable">$description</span> <span class="token operator">=</span> <span class="token string">'Unknown Beverage'</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">description</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">function</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//调料抽象类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CondimentDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//书中的JAVA代码里这里是一个抽象方法，PHP不允许这么做</span>  <span class="token comment" spellcheck="true">//public abstract function getDescription();</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//饮料1</span><span class="token keyword">class</span> <span class="token class-name">Espresso</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">description</span> <span class="token operator">=</span> <span class="token string">'Espresso'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1.99</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//饮料2</span><span class="token keyword">class</span> <span class="token class-name">HouseBlend</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">description</span> <span class="token operator">=</span> <span class="token string">'House Blend Coffee'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0.89</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//调料1</span><span class="token keyword">class</span> <span class="token class-name">Mocha</span> <span class="token keyword">extends</span> <span class="token class-name">CondimentDecorator</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token variable">$beverage</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$beverage</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">beverage</span> <span class="token operator">=</span> <span class="token variable">$beverage</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">beverage</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">', Mocha'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0.2</span> <span class="token operator">+</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">beverage</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一杯普通的饮料</span><span class="token variable">$beverage</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Espresso</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'Description:'</span><span class="token punctuation">.</span><span class="token variable">$beverage</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'&lt;br/>Cost:'</span><span class="token punctuation">.</span><span class="token variable">$beverage</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'&lt;br/>'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一杯普通的饮料</span><span class="token variable">$beverage2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HouseBlend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加一点调料</span><span class="token variable">$beverage2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mocha</span><span class="token punctuation">(</span><span class="token variable">$beverage2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'Description:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'&lt;br/>Cost:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'&lt;br/>'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再多加一点调料</span><span class="token variable">$beverage2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mocha</span><span class="token punctuation">(</span><span class="token variable">$beverage2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'Description:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'&lt;br/>Cost:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'&lt;br/>'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再多加一点调料</span><span class="token variable">$beverage2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mocha</span><span class="token punctuation">(</span><span class="token variable">$beverage2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'Description:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">'&lt;br/>Cost:'</span><span class="token punctuation">.</span><span class="token variable">$beverage2</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'&lt;br/>'</span><span class="token punctuation">;</span></code></pre><p>输出</p><pre><code>Description:Espresso   Cost:1.99   Description:House Blend Coffee, Mocha  Cost:1.09  Description:House Blend Coffee, Mocha, Mocha  Cost:1.29  Description:House Blend Coffee, Mocha, Mocha, Mocha  Cost:1.49  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 抽象工厂模式</title>
      <link href="/php-chou-xiang-gong-han-mo-shi/"/>
      <url>/php-chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>抽象工厂模式 <code>Abstract Factory Pattern</code>，提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//定义比萨商店</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$Pizza</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//纽约比萨店</span><span class="token keyword">class</span> <span class="token class-name">NYPizzaStore</span> <span class="token keyword">extends</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token variable">$PizzaIngredientFactory</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NYPizzaIngredientFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'cheese'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheesePizza</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token string">'clam'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClamPizza</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//芝加哥比萨店</span><span class="token keyword">class</span> <span class="token class-name">ChicagoPizzaStore</span> <span class="token keyword">extends</span> <span class="token class-name">PizzaStore</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPizza</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token variable">$PizzaIngredientFactory</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChicagoPizzaIngredientFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'cheese'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheesePizza</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token string">'clam'</span> <span class="token operator">==</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token variable">$Pizza</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClamPizza</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$Pizza</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原料工厂接口</span><span class="token keyword">interface</span> <span class="token class-name">PizzaIngredientFactory</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createDough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createCheese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createVeggies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPepperoni</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createClam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//纽约原料工厂</span><span class="token keyword">class</span> <span class="token class-name">NYPizzaIngredientFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PizzaIngredientFactory</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createDough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createDough&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createSauce&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createCheese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createCheese&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createVeggies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createVeggies&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPepperoni</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createPepperoni&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createClam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'NY createClam&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//芝加哥原料工厂</span><span class="token keyword">class</span> <span class="token class-name">ChicagoPizzaIngredientFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PizzaIngredientFactory</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createDough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createDough&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createSauce&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createCheese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createCheese&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createVeggies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createVeggies&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createPepperoni</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createPepperoni&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createClam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'Chicago createClam&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//比萨类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'bake&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'cut&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'box&lt;br />'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//比萨1</span><span class="token keyword">class</span> <span class="token class-name">CheesePizza</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span> <span class="token operator">=</span> <span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//向原料工厂请求原料</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createDough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createCheese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//比萨2</span><span class="token keyword">class</span> <span class="token class-name">ClamPizza</span> <span class="token keyword">extends</span> <span class="token class-name">Pizza</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span> <span class="token operator">=</span> <span class="token variable">$PizzaIngredientFactory</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//向原料工厂请求原料</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createDough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createCheese</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">PizzaIngredientFactory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createClam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$NYPizzaStore</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NYPizzaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ChicagoPizzaStore</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChicagoPizzaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$NYPizzaStore</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token string">'cheese'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ChicagoPizzaStore</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">orderPizza</span><span class="token punctuation">(</span><span class="token string">'clam'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出</p><pre><code>NY createDough  NY createSauce  NY createCheese  bake  cut  box  Chicago createDough  Chicago createSauce  Chicago createCheese  Chicago createClam  bake  cut  box</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何阅读一本书</title>
      <link href="/ru-he-yue-du-yi-ben-shu/"/>
      <url>/ru-he-yue-du-yi-ben-shu/</url>
      
        <content type="html"><![CDATA[<p>阅读的四个层次: </p><ol><li>基础阅读</li><li>检视阅读</li><li>分析阅读</li><li>主题阅读</li></ol><p>或许我们对世界的了解比以前的人多了，在某种范围内，知识也成了理解的先决条件。这些都是好事。但是，“知识”是否那么必然是“理解”的先决条件，可能和一般人的以为有相当的差距。我们为了“理解”一件事，并不需要“知道”和这件事相关的所有事情。太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。</p><p>作者所在的时代收音机和电视机开始大幅流行，而我们现在的时代网络的力量几乎压倒一切。尤其是最近几年发展起来的微博，由于信息流转太快，信息量太大，以至于发微博有字数限制。微博这种模式虽然获得信息非常快，但是并不是学习的好地方，它的信息冗余太多，无意义的太多，知识零散，深度不够，使人无法专注，谈不上学习。在论坛中看到长篇文字，只会看开头甚至只看帖子的标题，直接看下面的评论。我想很多人都有这个经历，而微博正是因为这种现象发展而来。</p><p>这些媒体，经过太精心的设计，使得思想形同没有需要了。读者所面对的是一种复杂的组成——从独创的华丽辞藻到经过审慎挑选的资料与统计——目的都在让人不需要面对困难或努力，很容易就整理出“自己”的思绪。根本不用思考就能表现得宜，导致个人缺乏自主的独立思考的能力。</p><p>我们可以将“阅读”这个词，区分为两种不同的意义。第一种意义是我们自己的阅读时，凭我们的阅读技巧与聪明才智，一下子便能融会贯通了。这样的读物能增加我们的资讯，却不能增进我们的理解力，因为在开始阅读之前，我们的理解力就已经与他们完全相同了。第二种意义是一个人试着读某样他一开始并不怎么了解的东西。这个东西的水平就是比阅读的人高上一截。这个作者想要表达的东西，能增进阅读者的理解力。阅读的两种意义，第一种是知识面扩大，而另一种则是关于知识的深度。</p><p>阅读其实是作者与读者进行交流，一旦达到相同的理解程度，就完成了沟通，从而使读者学习到东西。作者是一名缺席的老师，如果你问一本书一个问题，你就必须自己回答这个问题。在这种情况下，只有等你自己做了思考与分析之后，才会在书本上找到答案。</p><p>阅读的速度，不论是快还是慢，只不过是阅读问题的一个微小部分而已。有些书你需要快速阅读，而有些书则需要反复回味，即使是同一本书，在它不同的段落章节中也可以分成重要和不那么重要的部分。</p><p>在阅读一本难读的书时，不要企图了解每一个字句。不要害怕，或是担忧自己似乎读得很肤浅。就算是最难读的书，但你再读第二次时，你就已经准备好要读这本书了。读书百遍，其义自现。每次阅读思考着一些问题，尝试着解读问题，你就能吃透这本书了。</p><p>阅读的部分本质就是被困惑，而且知道自己被困惑。怀疑是智慧的开始，从书本上学习跟从大自然学习是一样的。如果你对一篇文章连一个问题也提不出来，那么你就不可能期望一本书能给你一些你原本就没有的视野。当你阅读时，如果没有对作者所表达的问题或回答有所疑问，那么要么是你已经完全了解，并接受了作者的思想；要么是你阅读时，没有思考，不明白作者所提出的一些问题以及答复，你并没有读懂这本书。</p><p>阅读时只记忆与背诵所读的东西，是使用文字，并没有体会其中的思想传达。这些读者从来就没法超越文字本身，他们犯了玩弄文字的错误。要确认自己是否读懂书中的思想，需要尝试能否用自己的话表达出书中的思想，而不是简单的复述。</p><p>每个论述都要有开端。开端基于两种情况，一种是作者和读者都认同的前提，另一种则是不论作者或读者都无法否认的自明之理。第一种是主观的，需要彼此认同，这个假设可以是任何东西。而第二种则不同，每当你提到它的时候，别人都会说你说的是废话。</p><p>阅读一本书，是一种对话。有可能你不怎么认为，因为作者一直在说，你却无话可说。事实上，读者是最后一个说话的人。当你读完一本书后，在你说出同意、反对或展缓评论之前，你一定要说“了解”。对作者的思想毫无理解变同意是愚蠢，还不清楚便反对是无理。我们需要重述作者的观点，如果无法说出个所以然来。那么对作者观点的讨论，就只是一些文字游戏而已，只是口舌之快，无论肯定或否定的意见都毫无意义。当你透过对一本书的诠释理解，与作者达成共识之后，才可以决定同意他的论点，或是不同意他的立场。</p><p>大多数人会以赢得辩论为目标，他们忘记了辩论的原有目的——学习到真理。辩论中的胜利在于你能从中学到什么，如果知道所谓的赢在于知识的增长，那么你就会明白争强好胜是毫无益处的。亚里士多德在《诗学》中提到: “其实这就是我们的责任。为了追求真理，要毁掉一些我们内心最亲近的事物，尤其像我们这样的哲学家或热爱智慧的人更是如此。因此，纵使双方是挚友，我们对真理的虔诚却是超越友谊的。”而在柏拉图的《会饮篇》中有一段对话也是说这样的道理: “我不能反驳你，苏格拉底。”阿加顿说: “让我们假设你说的都对好了。”“阿加顿，你该说你不能反驳真理，因为苏格拉底是很容易被反驳的。”</p><p>在读者与作者“辩论”中，要遵循以下三个规则: </p><ol><li>要求读者先完整地了解一本书，不要急着开始批评。</li><li>要求读者不要争强好胜或盲目反对。</li><li>将知识上的不同意见看作是大体上可以解决的问题。</li></ol><p>分析阅读的第一阶段: 找出一本书在谈什么的规则: </p><ul><li>依照书本的种类和主题作分类。</li><li>用最简短的句子说出整本书在谈些什么。</li><li>按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。</li><li>找出作者在问的问题，或作者想要解决的问题。</li></ul><p>分析阅读的第二阶段: 诊释一本书的内容规则: </p><ul><li>诊释作者的关键字，与他达成共识。</li><li>由最重要的句子中，抓住作者的重要主旨。</li><li>知道作者的论述是说明，从内容中找出相关的句子，在重新架构出来。</li><li>确定作者已经解决了哪些问题，还有哪些是没有解决的。再判断哪些是作者知道他没有解决的问题。</li></ul><p>分析阅读的第三阶段: 像沟通知识一样地评论一本书的规则: </p><ol><li>智慧礼节的一般规则: <ul><li>除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出: “我读懂了！”之前，不要说你同意、不同意或暂缓评论。）</li><li>不要争强好胜，非辩到底不可。（你的胜利在于知识的增长，而不是辩论的胜负。）</li><li>在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。</li></ul></li><li>批评观点的特别标准: <ul><li>证明作者的知识不足。</li><li>证明作者的知识错误。</li><li>证明作者不合逻辑。</li><li>证明作者的分析和理由是不完整的。</li></ul></li></ol><p>论说性作品要传达的是知识——在读者经验中曾经有过或没有过的知识。想象文学是在阐述一个经验本身——那是读者只能借着阅读才能拥有或分享的经验。想象文学会尽量使用文字来隐藏的多重字义，好让这些文特有的多元性增加文章的丰富性与渲染力。作者会用隐喻的方式让整本书整合起来，就像注重逻辑的作者会用文字将单一的意义说明清楚一样。</p><p>论说性作品的作者传达的是问题的结论，而想象文学的作者则表达的是一种经历，让读者自己产生问题。论说性作品所做的是因为什么，所以什么。想象文学则是讲述一个故事。如果论说性作品出现技术上的错误，就应该批评，而想象文学只要能自圆其说，你就不应该批评。你可以批评《三国志》其中某段记录错误，却不能批评《三国演义》说它情节有错误，你只能说我喜欢或不喜欢它的那处情节。</p><p>换句话说，对于小说或其他想象文学作品，我们不应该反对或赞成，而是喜欢或不喜欢。我们在批评论说性作品时，关心的是他们所陈述的事实。在批评想象文学时，我们主要关心的是它是否讲述了一段让我们欣赏或是喜欢的故事。</p><p>当代事件的作者可能希望你用某一种方式了解这个事件，这有他自己的利益考虑。就算他不这么想，他的消息来源也会这么想。你要搞清楚他们的利益考虑，阅读任何东西都要小心翼翼。你要擦亮眼睛，消息来源要多种多样，尝试用不同的视角去看待事件。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>麻省理工《计算机科学及编程导论》</title>
      <link href="/ma-sheng-li-gong-ji-suan-ji-ke-xue-ji-bian-cheng-dao-lun/"/>
      <url>/ma-sheng-li-gong-ji-suan-ji-ke-xue-ji-bian-cheng-dao-lun/</url>
      
        <content type="html"><![CDATA[<p>课程介绍: </p><p>这门课程适用于那些拥有很少或没有编程经验的学生,它致力于使学生理解计算机在解决问题中的作用,并且帮助学生，不论其专业，使他们对于能够完成有用的小程序的目标充满信心。这门课程将使用Python语言进行教学。</p><p>课程类型:  计算机</p><p>课程主讲人: Prof. Eric Grimson 教授 Prof. John Guttag 教授</p><p>埃里克格里姆森是美国麻省理工学院计算机科学与工程系的教授，并在麻省理工学院的伯纳德持的戈登医学工程主席。 教授格里姆森在麻省理工学院曾担任教育科学部主任，电气工程和计算机副系主任。 自2005年以来，他一直担任计算机科学和电机工程学系的院长。 在1975年，他获得了里贾纳大数学 （高荣）和学物理学士， 1980年，麻省理工学院数学博士学位。 格里姆森教授是麻省理工学院计算机科学和人工智能实验室成员，他的集团已率先领域和许多其他国家的艺术系统和行为识别活动，对象和人识别，图像数据库索引，图像引导手术，现场模拟计算机视觉。 格里姆森教授协会是IEEE的资深会员，并在麻省理工学院获得了玻色教学卓越奖。</p><p>第 1 课 课程简介及数据类型</p><p>第 2 课 分支、条件和循环</p><p>第 3 课 循环式程序样式</p><p>第 4 课 函数抽象、递归简介</p><p>第 5 课 浮点数和逐次近似</p><p>第 6 课 二分法、牛顿法、列表简介</p><p>第 7 课 列表和可变性、字典、效率简介</p><p>第 8 课 算法复杂度: 对数、线性、二次、指数</p><p>第 9 课 折半搜索、泡沫排序和选择排序</p><p>第 10 课 归并排序、哈希函数、异常处理</p><p>第 11 课 测试和调试</p><p>第 12 课 调试、背包问题、动态规划简介</p><p>第 13 课 动态规划: 重复子问题、最优子结构</p><p>第 14 课 面向对象编程简介</p><p>第 15 课 抽象数据类型、类、方法</p><p>第 16 课 封装、继承、遮蔽</p><p>第 17 课 计算模型: 随机游走模拟</p><p>第 18 课 表示模拟结果、Pylab作图</p><p>第 19 课 有偏随机游走、分布</p><p>第 20 课 蒙特卡洛模拟、估算π</p><p>第 21 课 验证模拟结果、曲线拟合、线性回归</p><p>第 22 课 正态、均匀和指数分布</p><p>第 23 课 股市模拟</p><p>第 24 课 课程总回顾: 按计算机科学家那样思考</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><hr><h3 id="第-1-课-课程简介及数据类型"><a href="#第-1-课-课程简介及数据类型" class="headerlink" title="第 1 课 课程简介及数据类型"></a>第 1 课 课程简介及数据类型</h3><p>没有一个问题的提出，是要命的。我们不会用他们来淘汰你们，而是用他们来帮助你们学习。</p><p>我们不会发课件。事实证明学生在自己做笔记的时候学得更好，讽刺的是即使他们永远不看那些笔记。</p><p>我们的目标都是为了帮助你像一个计算机科学家一样思考。换一种说法就是，我们想赋予你一种能力，以让你可以用计算机做你想做的任何事。我们希望每当你要面对一些技术问题的时候，你们的本能之一将会是: “我怎么才能编写一个代码来帮我解决这问题？”</p><p>知识分为两种: 陈述性（declarative）的知识和程序性（imperative）的知识。 陈述性的知识用叙述事实来思考它，它维护了真相。它告诉你怎么才可能去检查一些事儿，但是它没有说怎样检查。而这就是程序性的知识。程序性的知识是对推论过程的描述。</p><p>你在课堂上应该学会如何设计菜谱，如何构建菜谱，如何在Python语言的模式中设计东西，而不是一些细节问题。</p><hr><h3 id="第-2-课-分支、条件和循环"><a href="#第-2-课-分支、条件和循环" class="headerlink" title="第 2 课 分支、条件和循环"></a>第 2 课 分支、条件和循环</h3><p>无论我们创建一种多么复杂的数据结构，都是基于字符串，数字以及布尔类型。</p><p>解释器实际上是机器内置的按照我们描述的规则，来推算出结果值并把值显示出来的一个东西。</p><hr><h3 id="第-3-课-循环式程序样式"><a href="#第-3-课-循环式程序样式" class="headerlink" title="第 3 课 循环式程序样式"></a>第 3 课 循环式程序样式</h3><p>流程图是一种代码结构视觉化的工具。因为它让我们看到了，循环在什么地方、那里初始化变量以及什么时候条件判断等等。它的意义在于，如果你开始按照流程图往下走，你就是将抽象的代码操作给视觉化和直观化，它能帮助构思代码结构以及理清你的思路。</p><p>对于简单分支式程序，运行程序花费的总时间，受限于指令（instructions）的数目，毕竟每个指令最多执行一次。而其他程序，例如一个循环程序，它所花费的时间取决于循环的次数，即指令执行次数取决于循环是次数。</p><p>模拟执行，指的是取一下简单值，过一遍，看看会怎么样。</p><p>对于任何循环，有两点是必须检测的。必须保证程序能够终止并且必须保证结果是合理的。</p><p>防御式编程（defensive programming）必须能够: 保证遍历了代码中所有分支；保证对每个分支，打印或返回的结果有意义；保证所有可能的输入数据都能对应一个分支，并且不会产生错误或无限循环。</p><p>元组（tuple）指的是有序的元素列。它是不可变的（而数组则是可以改变的）。例子: </p><pre class=" language-python"><code class="language-python">test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre><hr><h3 id="第-4-课-函数抽象、递归简介"><a href="#第-4-课-函数抽象、递归简介" class="headerlink" title="第 4 课 函数抽象、递归简介"></a>第 4 课 函数抽象、递归简介</h3><p>到现在为止，我们学习了赋值语句、条件语句、输入/输出、循环结构以及各种数据类型。我们使用这些就可以称为图灵完全（Turing-complete），也就是说，有了这些以后，就可以写出任何程序了。</p><p>农场中有一群猪和一群鸡，有一天农场主看到有x个头和y个脚，求该农场有多少头猪和多少只鸡: </p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>numLegs<span class="token punctuation">,</span> numHeads<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">for</span> numChicks <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numbeads <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    numPigs <span class="token operator">=</span> numHeads <span class="token operator">-</span> numChicks    totLegs <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span>numPigs <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>numChicks    <span class="token keyword">if</span> totLegs <span class="token operator">==</span> numLegs      <span class="token keyword">return</span> <span class="token punctuation">[</span>numPigs<span class="token punctuation">,</span> numChicks<span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>None<span class="token punctuation">,</span> None<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">barnYard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  heads <span class="token operator">=</span> int<span class="token punctuation">(</span>raw_input<span class="token punctuation">(</span><span class="token string">'Enter number of heads: '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  legs <span class="token operator">=</span>  int<span class="token punctuation">(</span>raw_input<span class="token punctuation">(</span><span class="token string">'Enter number of legs: '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  pigs<span class="token punctuation">,</span> chickens <span class="token operator">=</span> solve<span class="token punctuation">(</span>legs<span class="token punctuation">,</span> heads<span class="token punctuation">)</span>  <span class="token keyword">if</span> pigs <span class="token operator">==</span> None<span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">'There is no solution'</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">'Number of pigs:'</span><span class="token punctuation">.</span>pigs    <span class="token keyword">print</span> <span class="token string">'Number of chickens:'</span><span class="token punctuation">.</span>chickens</code></pre><p>递归: 只要基础情况正确，递归步骤正确，就能将问题简化为更简单的相同问题，最终代码收敛并给出答案。<br>斐波那契（Fibonacci）数列，给出两个数，后面产生的数都是在自己之前的两个数的和，即<code>x_3 = x_1 + x_2, x_4 = x_2 + x_3 ...</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> fib<span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre><hr><h3 id="第-5-课-浮点数和逐次近似"><a href="#第-5-课-浮点数和逐次近似" class="headerlink" title="第 5 课 浮点数和逐次近似"></a>第 5 课 浮点数和逐次近似</h3><p>Python与其他语言不同，它有一种“任意精度整数”。也就是说，你想让它有多大，它就能有多大（小数则不行，最多精确到17位）。例如2的1000次方: </p><pre class=" language-python"><code class="language-python"><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">1000</span></code></pre><p>二分法的基本思路: 所有可能的答案构成一个线性排列的空间。若在某处取猜想值，如果答案不正确，我将能够知道正确答案在在猜想值的左侧还是右侧。某种意义上，递归也是这种思路，通过每一步减小问题规模来解决问题。</p><hr><h3 id="第-6-课-二分法、牛顿法、列表简介"><a href="#第-6-课-二分法、牛顿法、列表简介" class="headerlink" title="第 6 课 二分法、牛顿法、列表简介"></a>第 6 课 二分法、牛顿法、列表简介</h3><p>回归测试（regression testing），这个测试就是为了保证来重复检测整个程序是否运行良好。</p><p>收敛速度（speed of convergence）</p><p>牛顿法，先设定一个初始猜测值guess，然后求得该值对应函数的切点斜率。在绝大多数情况下，不是所有的情况，切线在解的附近，是曲线很好的近似。因此，切线在X轴上的截距会比先前更接近正确的解。如果初始guess是最下面这一点，即guess=0，切线与X轴平行并没有相交，后面自然做不下去了。这种情况是数值计算程序中最需要关注的。相对于二分法，牛顿法的效率要高很多。</p><p>计算机的答案不一定正确，毕竟在计算机中终归都是人写的程序。保持疑问是个好习惯。</p><p>列表和字符串有两处不同: 一是它可变，二是其值不一定要由字符组成。</p><hr><h3 id="第-7-课-列表和可变性、字典、效率简介"><a href="#第-7-课-列表和可变性、字典、效率简介" class="headerlink" title="第 7 课 列表和可变性、字典、效率简介"></a>第 7 课 列表和可变性、字典、效率简介</h3><p>除了拼写单词，永远不要使用小写的l，你很难将它和数字1分别开。</p><p>在一般情况下: </p><pre class=" language-python"><code class="language-python">a<span class="token operator">=</span><span class="token number">1</span>b<span class="token operator">=</span>aa<span class="token operator">=</span><span class="token number">2</span></code></pre><p>最后结果是<code>a=2，b=1</code>。而在列表中赋值是通过不同路径指向同一对象，并不是像上面的a指向了一个新的2，列表会把之前的1修改为2。</p><p>同列表一样，字典类型也是可变的。也具有多样性，但与列表不同的是字典的元素没有顺序。 另外，它包含一般化的索引。列表和字符串只能通过整数获取其元素，而字典里的任意元素都可以考虑为一对键和值，其中键用作索引（字典类型运用到了哈希表（Hash table）技术，其实就是PHP中的数组）。</p><p>效率显然是编写代码需要重点考虑的内容，我们经常首先关注的是代码功能的实现，然后再来找更高效的实现方法。</p><hr><h3 id="第-8-课-算法复杂度-对数、线性、二次、指数"><a href="#第-8-课-算法复杂度-对数、线性、二次、指数" class="headerlink" title="第 8 课 算法复杂度: 对数、线性、二次、指数"></a>第 8 课 算法复杂度: 对数、线性、二次、指数</h3><p>如果你想成为一个好的设计师（designer）就要学会用已学知识处理未知问题。碰到新问题时，你应该想想它和什么最像？以及哪类算法可以应用到这类问题上，然后从这些可能有用的算法中选用什么算法最为合适？</p><p>我们主要关注问题规模变大造成的增长率。</p><p>大O符号,它表示增长的上界，随着输入规模增加，函数增长的上界。</p><p>在各种算法中复杂度分为对数 &lt; 线性 &lt; 二次 &lt; 指数，对数是每次将问题分解成一个小问题（除法），线性是每次将问题减少常数次（加减法），二次是每次将问题增加（乘法） ，线性是每次将问题进行指数性的增加（指数）</p><hr><h3 id="第-9-课-折半搜索、冒泡排序和选择排序"><a href="#第-9-课-折半搜索、冒泡排序和选择排序" class="headerlink" title="第 9 课 折半搜索、冒泡排序和选择排序"></a>第 9 课 折半搜索、冒泡排序和选择排序</h3><p>折半搜索的前提是有一个有序列表<br>一、取中点<br>二、判别中点是否为要找的结果<br>三、如果不是，将问题减半，然后重复<br>本质上，这个模板体现了对数算法（分治算法）</p><p>选择排序又名为单元排序，每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</p><p>冒泡排序，依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟: 首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小 数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟: 仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小 于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其 实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。</p><hr><h3 id="第-10-课-归并排序、哈希函数、异常处理"><a href="#第-10-课-归并排序、哈希函数、异常处理" class="headerlink" title="第 10 课 归并排序、哈希函数、异常处理"></a>第 10 课 归并排序、哈希函数、异常处理</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>分治算法如果只是一个劲地分，而不考虑合的复杂性，也许会得不偿失。所以真正好的分治算法，不仅分起来简单，合起来也需要不太复杂。</p><p>有一种搜索算法它甚至比折半搜索还好，它就是哈希（hash或译作“散列”）</p><p>在计算机科学中很多情况下，效率可以通过牺牲空间取得。</p><hr><h3 id="第-11-课-测试和调试"><a href="#第-11-课-测试和调试" class="headerlink" title="第 11 课 测试和调试"></a>第 11 课 测试和调试</h3><p>单元测试，单独确认程序每段代码。<br>集成测试，将整个程序集成后，看是否运行正确。</p><p>首先研究既有数据，你需要用一种怀疑的眼光来看问题。然后形成一种假设，让它与所有数据一致。从而设计并开始一个可重复的实验。</p><hr><h3 id="第-12-课-调试、背包问题、动态规划简介"><a href="#第-12-课-调试、背包问题、动态规划简介" class="headerlink" title="第 12 课 调试、背包问题、动态规划简介"></a>第 12 课 调试、背包问题、动态规划简介</h3><p>大体上说，最优化问题（optimization problem）都差不多。包括两部分，一些你想获得最大或最小值的函数，还必须符合一些约束条件。典型的最优化问题，其中一个最著名的是最短路径问题。另一类的最优化问题是旅行商问题（traveling salesman problem）。装箱问题（bin packing），用大小不同形状不同的东西填装容器。 序列比问题（sequence alignment），例如DNA序列，RNA序列。还有一个最优化问题，背包问题（knapsack problem）。</p><p>背包问题具体来说是，你有一堆东西，东西比较多背包放不下，你需要选择带什么，留下什么。你需要在背包能带东西有限的情况下，最大化你所带东西的价值。</p><p>在贪婪算法中，需要在每一步最大化你的值。不用提前计划，做好当前的事情就好。就像是有些人吃东西时先吃甜点，这样能够保证在吃饱前吃到最好的东西。</p><p>局部的最优化并不能保证全局的最优化。所以，你不能重复的进行局部优化，期望得到全局的最优。</p><p>动态规划（dynamic programming），不要在这个名字上花费精力。这个方法由数学家贝尔曼发明，国防部曾经让他帮忙做一些工作，他不想让他们知道他在做什么，所以他编造了一个与此毫不相关的名字。不幸的是，我们一直沿用至今。所以不要认为，它特指任何动态的东西。它能解决很多表面上是指数增长的问题，关键有两点，一是找到重叠子问题，二是所谓最优子结构。</p><hr><h3 id="第-13-课-动态规划-重复子问题、最优子结构"><a href="#第-13-课-动态规划-重复子问题、最优子结构" class="headerlink" title="第 13 课 动态规划: 重复子问题、最优子结构"></a>第 13 课 动态规划: 重复子问题、最优子结构</h3><p>斐波那契数列</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">global</span> numCalls  numCalls <span class="token operator">+=</span><span class="token number">1</span>  <span class="token comment" spellcheck="true">#print 'fib调用', n</span>  <span class="token keyword">if</span> n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>numCalls <span class="token operator">=</span> <span class="token number">0</span>n <span class="token operator">=</span> <span class="token number">6</span>res <span class="token operator">=</span> fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'fib_'</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'='</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token string">'调用次数为'</span><span class="token punctuation">,</span> numCalls<span class="token keyword">def</span> <span class="token function">fastFib</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">global</span> numCalls  numCalls <span class="token operator">+=</span><span class="token number">1</span>  <span class="token comment" spellcheck="true">#print 'fib1调用', n</span>  <span class="token keyword">if</span> <span class="token operator">not</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span>    memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>fastFib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span> <span class="token operator">+</span> fastFib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span>  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">fib1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>  memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>  <span class="token keyword">return</span> fastFib<span class="token punctuation">(</span>n<span class="token punctuation">,</span> memo<span class="token punctuation">)</span>numCalls <span class="token operator">=</span> <span class="token number">0</span>n <span class="token operator">=</span> <span class="token number">6</span>res <span class="token operator">=</span> fib1<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'fib_'</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'='</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token string">'调用次数为'</span><span class="token punctuation">,</span> numCalls</code></pre><p>我们看到加上memo这个缓存后，算法的复杂度减少了不少，根本原因就是我们找到重叠子问题，并且将结果缓存起来，避免重复计算。整个算法的的核心就是: </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#如果memo中不存在斐波那契数列的第n个数</span><span class="token comment" spellcheck="true">#则计算该数</span><span class="token keyword">if</span> <span class="token operator">not</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span>  memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>fastFib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span> <span class="token operator">+</span> fastFib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#如果存在就直接返回该数</span><span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre><p>把之前解决了的问题作为数据储存起来。依赖表查找查询之前数据，而缓存法是一种特殊情况。表查找是一种常见的方式，当你解决复杂的问题时，保存答案然后供以后使用。看到算法刚开始时间复杂度是1700万，增加缓存后变为1800，是相当令人震惊的。缓存这种方法其实就是我们常说的空间换时间。</p><hr><h3 id="第-14-课-面向对象编程简介"><a href="#第-14-课-面向对象编程简介" class="headerlink" title="第 14 课 面向对象编程简介"></a>第 14 课 面向对象编程简介</h3><p>对象表示一系列的数据和函数。这里关键的思想在于将数据和处理数据的函数当作一体。这样的好处在于把对象传给程序其他部分时，那部分程序也有能力处理这个对象。这种数据及相应处理函数的组合是面向对象编程的本质。</p><hr><h3 id="第-15-课-抽象数据类型、类、方法"><a href="#第-15-课-抽象数据类型、类、方法" class="headerlink" title="第 15 课 抽象数据类型、类、方法"></a>第 15 课 抽象数据类型、类、方法</h3><p>可以将类考虑为创造对象实例的模板。</p><p>Python中的<code>self</code>关键字是其他语言中的<code>this</code>关键字。</p><p>数据隐藏是只能通过定义的方法，来访问实例值。很遗憾，Python没有强制数据隐藏。</p><hr><h3 id="第-16-课-封装、继承、遮蔽"><a href="#第-16-课-封装、继承、遮蔽" class="headerlink" title="第 16 课 封装、继承、遮蔽"></a>第 16 课 封装、继承、遮蔽</h3><p>Python中的<code>__init__</code>是其他语言中的构造函数。</p><p>映射也常常称为重载。</p><hr><h3 id="第-17-课-计算模型-随机游走模拟"><a href="#第-17-课-计算模型-随机游走模拟" class="headerlink" title="第 17 课 计算模型: 随机游走模拟"></a>第 17 课 计算模型: 随机游走模拟</h3><p>从一个不太正式的问题描述去得到一个更加正式的问题。从某种程度上来说，就是我们如何来进行问题优化的。</p><p>创造计算模型。我们几乎写的每个有意义的程序在某种意义上来说都是对真实世界的建模。如果我们要写一个帮助我们决定买还是卖股票的程序，在某种意义上就是在尝试对股票市场进行建模。</p><hr><h3 id="第-18-课-表示模拟结果、Pylab作图"><a href="#第-18-课-表示模拟结果、Pylab作图" class="headerlink" title="第 18 课 表示模拟结果、Pylab作图"></a>第 18 课 表示模拟结果、Pylab作图</h3><p>学会问自己答案是不是合理。是不是违反直觉？是不是和事实相符？</p><hr><h3 id="第-19-课-有偏随机游走、分布"><a href="#第-19-课-有偏随机游走、分布" class="headerlink" title="第 19 课 有偏随机游走、分布"></a>第 19 课 有偏随机游走、分布</h3><p>好设计的关键: 将你程序的各个部分进行独立决策，当你遇到什么不可避免的事情时，你就可以加强代码，或者你发现什么错误时，你所需要的改变都是有限的。（PS: 我们使用的面向对象的那些策略和各种设计模式大多原理中就包含了这个。）</p><hr><h3 id="第-20-课-蒙特卡洛模拟、估算π"><a href="#第-20-课-蒙特卡洛模拟、估算π" class="headerlink" title="第 20 课 蒙特卡洛模拟、估算π"></a>第 20 课 蒙特卡洛模拟、估算π</h3><p>随机模拟程序会有一些有趣的问题，我们要运行多少次才能相信答案是正确的呢？</p><p>蒙特卡洛(Monte Carlo)模拟，某种程度上是演绎统计学的应用。一个随机选择的样例，一般能够体现出它所在分类的一些性质。</p><hr><h3 id="第-21-课-验证模拟结果、曲线拟合、线性回归"><a href="#第-21-课-验证模拟结果、曲线拟合、线性回归" class="headerlink" title="第 21 课 验证模拟结果、曲线拟合、线性回归"></a>第 21 课 验证模拟结果、曲线拟合、线性回归</h3><p>通过取样我们不可能得到完美的精确度，除非你取样是整个群体。无论你取多少样本，除非你判断每个元素，否则你是不可能确定这个样本集合是典型的。没办法确定是否选择了一个不公正的样本，除非查看了整个群体。所以我们不可能知道我们的预测是否正确。</p><p>一个答案是统计可靠地，但并不代表它就是正确答案。这是因为它的一些影响判断的基础假设是错误的。这个时候我们就需要去通过和物理事实相比检查答案的正确性。</p><p>大多数情况都能靠某个模型来解释，而有一些情况不能解释。在那些不能解释的情况中往往是<strong>潜在变量（lurking variable）</strong>在影响结果。当你在建立模型的时候需要去寻找这些潜在变量，在寻找潜在变量时你要小心<strong>过度拟合</strong>。</p><hr><h3 id="第-22-课-正态、均匀和指数分布"><a href="#第-22-课-正态、均匀和指数分布" class="headerlink" title="第 22 课 正态、均匀和指数分布"></a>第 22 课 正态、均匀和指数分布</h3><p>数据滥用</p><ul><li>注意是谁给你的数据，而不是数据本身。</li><li>共存即原因。它的意思是关联性，并不代表因果性 ，你需要寻找潜在变量（lurking variable） 。（即因果关系过度单纯化 ）</li><li>非响应性倾向（non-response bias）。实际上它就是无代表意义的样本。</li><li>数据提升（data enhancement）。它的意思是在数据中读出来超过它原有意义的东西。（即过分解读）</li></ul><hr><h3 id="第-23-课-股市模拟"><a href="#第-23-课-股市模拟" class="headerlink" title="第 23 课 股市模拟"></a>第 23 课 股市模拟</h3><p>泊松（Poisson），人们常常用泊松过程来对事物进行建模，也就是说过去行为的过程，对未来的行为是没有影响的，也就是说它是无记忆性的。</p><hr><h3 id="第-24-课-课程总回顾-按计算机科学家那样思考"><a href="#第-24-课-课程总回顾-按计算机科学家那样思考" class="headerlink" title="第 24 课 课程总回顾: 按计算机科学家那样思考"></a>第 24 课 课程总回顾: 按计算机科学家那样思考</h3><p>首先理解这个问题，然后想一想解决方案的整体架构，然后不考虑怎么实现的前提下去考虑算法。这是个和用Python还是Java或者C++无关的决定。事实上，把一个拥有良好的架构的程序，从一种编程语言转为另外一种是很容易的。</p>]]></content>
      
      
      <categories>
          
          <category> 公开课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人月神话</title>
      <link href="/ren-yue-shen-hua/"/>
      <url>/ren-yue-shen-hua/</url>
      
        <content type="html"><![CDATA[<p>第一章焦油坑提出了软件工程中乐趣和苦恼，第二章人月神话则讲述了人员数量和时间是无法互换的，并研究了产生这种情况的原因，第三章到第十五章则讨论了解决这种情况的种种方案，到最后得出结论软件工程并没有银弹（即没有万能的方法），只有一些子弹而已。</p><p>神话和传说中的魔术在我们的时代已变成了现实。在键盘上键入正确的咒语，显示出前所未有的或是已经存在的事物。编程这种快乐是一种创造事物的纯粹快乐。如同小孩在玩泥巴时感到快乐一样。 编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。</p><p>用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。它暗示着人员数量和时间是可以互相替换的。人数和时间的互换仅仅适用于以下情况: 某个任务可以分解给参与人员，并且他们之间不需要相互的交流。这在收割小麦或收获棉花的工作中是可行的，而在编程中近乎不可能。</p><p>Brooks法则: 向进度落后的项目中增加人手，只会使进度更加落后。</p><p>没有银弹，所谓的快速开发工具触礁再正常不过了。因为真正复杂的是需求，而不是软件。项目永远是在催促你，不管开发工具的效率多高，花在和客户沟通上的成本一点都不会减少。不管快速开发的语言有多厉害，照样也需要改来改去。</p><p>程序员的生产力相对是一个常量，它不受开发所用的语言的影响。因此，实际生产力收获来自于迁移到高级语言编程，这些语言每行表达了更多的实际工作。</p><p>Brooks列出的根本性困难包括: </p><ul><li>复杂性（complexity）——“复杂”是软件的根本特性，可能来自于程序员之间的沟通不良，而产生结构错误或时间延误；也可能因为人们无法完全掌握程序的各种可能状态；也可能来自新增功能时而引发的副作用等等。</li><li>一致性（conformity）——大型软件开发中，各小系统的界面常会不一致，而且易于因为时间和环境的演变更加不一致。</li><li>易变性（changability）——软件的所处环境常是由人群、法律、硬件设备及应用领域等各因素融合而成的文化环境，这些因素皆会快速变化。</li><li>不可见性（invisibility）——软件是看不见的，即使利用图示方法，也无法充分表现其结构，使得人们心智行的沟通面临极大的困难。</li></ul><p>这些是软件的本性，Brooks认为没有捷径可以解决（there is no royal road），但可以渐进式地进行改善。他认为可行的方案有: </p><ul><li>买来装配（buy and build）——软件的建造尽量使用现有零组件，不要一起都从头做起。</li><li>快速雏形（rapid prototyping）——使用重复式的开发方法（iterative development）来渐进地改善软件的雏形，以求逐步理清使用者需求。</li><li>有机成长（growing organically）——生命皆是由小慢慢长大的，建造大型软件的方法应该是逐渐成长，而不是一次建造完成。</li><li>优秀设计者（great designer）——人是软件设计的核心，良好的方法可改善人的创造过程，但无法激励人的原本创造力，须倚重有创意的人。</li></ul><p>人月神话道出了软件开发要面对的本质问题，即人与机器之间交流。程序员作为两者之间沟通的桥梁，无论硬件和编程环境如何改变，成本最高的沟通成本仍然不会有数量级的减少。</p><blockquote><p> 今有程序员五人，需时日几何？<br> 一年。<br> 吾急需之！若有十人，几何？<br> 两年。<br> 百人若何？<br> 万世。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑客与画家</title>
      <link href="/hei-ke-yu-hua-jia/"/>
      <url>/hei-ke-yu-hua-jia/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么书呆子不受欢迎"><a href="#为什么书呆子不受欢迎" class="headerlink" title="为什么书呆子不受欢迎"></a>为什么书呆子不受欢迎</h4><ul><li>所有东西都在变成软件，印刷机诞生后，人类写过多少个字，未来就有多少家软件公司。</li><li>事实上，大多数会画的人，本身就很喜欢画画，将许许多多时间投入其中，这就是为什么他们擅长画画的原因。同样受欢迎也不是天生的，而是要你自己做出来的。</li><li>在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。我已经意识到，正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。</li><li>校园生活真正的原因是空虚。</li></ul><h4 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h4><ul><li>计算机科学就像一个大杂烩，由于某些历史意外，很多不相干的领域被强行拼装在一起。这个学科的一端是纯粹的数学家，中间部分是计算机博物学家，另一端则是黑客。所以在计算机科学的名下，数学家、物理学家和建筑家都不得不待在同一个系里。</li><li>黑客就像画家，工作起来是有心理周期的。有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作16个小时，等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。</li><li>普通黑客与优秀黑客的所有区别之中，会不会换位思考可能是最重要的单个因数。有些黑客很聪明，但是完全以自我为中心，根本不会设身处地为用户考虑。这样的人很难设计出优秀软件，因为他们不从用户的角度看待问题。</li><li>在达芬奇的年代，绘画并不是一件很酷的事情。达芬奇用自己的工作推动绘画成为一种伟大的表达方式。同样，编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。</li></ul><h4 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h4><ul><li>历史上的每一个年代，都会给“异端邪说”贴一些标签，目的是在人们开始思考它们是否为真之前就把它们封杀。“亵渎神明”、“冒犯圣灵”、“异端”都是西方历史上常见的标签，当代的标签则是“有伤风化”、“不得体”、“破坏国家利益”等。</li><li>为什么家长要伪装？因为他们觉得孩子不应该知道成年人的所有内容，只需知道一部分适合儿童的就行了。我们喜欢孩子们看上去天真无邪。</li><li>一旦发现了“不能说的话”，下一步怎么办？我的建议是就是别说，至少也要挑选合适的场合再说，只打那些值得打的仗。与笨蛋辩论，你也会变成笨蛋。</li><li>不管问谁，人们都会说同样的话: “我们心态很开放，愿意接受新思想。”但是实际上，人们脑子里有一根界线，早就认准了什么是对的，什么是错的。换言之，在他们看来，所以观点都是可以讨论的，出来那些错误的观点。</li><li>每当你看到有些话被攻击为出自XX分子或XX主义，这就是一个明确的信号，表明背后有问题。</li><li>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。问自己，什么话是我不能说的？为什么？</li></ul><h4 id="良好的坏习惯"><a href="#良好的坏习惯" class="headerlink" title="良好的坏习惯"></a>良好的坏习惯</h4><ul><li>在大众眼里，黑客就是入侵计算机的人。可是，在程序员眼里，黑客指的是优秀的程序员。这两个含义其实是相关的。对于程序员来说，黑客这个词的字面意思主要就是精通，也就是他可以随心所欲地支配计算机。</li></ul><h4 id="另一条路"><a href="#另一条路" class="headerlink" title="另一条路"></a>另一条路</h4><ul><li>互联网软件的发布过程可以分解为一系列的渐进式修改，而不是猛地推出一个大幅变动的版本。一旦采用了这种新模式，你就会知道发布方式对软件开发的影响有多么重大。桌面软件开发之中的许多棘手问题，都是源于它的那么灾难性的发布方式。</li><li>大公司付出的高价之中，很大一部分是商家为了让大公司买下这个商品而付出的费用。（如果国防部花1000美元买一个马桶座圈，部分原因是要让国防部买下它本身就需要花很多钱）</li><li>苹果公司还没有失败,如果它能把iPod升级为手机，并且将网络浏览器包括其中，那么微软就有大麻烦了。（这段话写于2001年9月，现在看来预言成功了）</li></ul><h4 id="如何创造财富"><a href="#如何创造财富" class="headerlink" title="如何创造财富"></a>如何创造财富</h4><ul><li>创造有价值的东西就是创造财富。你最好搞清楚什么是财富。财富与金钱并不是同义词（亚当斯密在《国富论》中提到，许多国家为了保住“财富”，禁止出口白银或者黄金。但是黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高，即通货膨胀）。大多数生意的目的是为了创造财富，做出人们真正需要的东西。</li><li>我们很乐意迫使那些又大又慢的竞争对手跟着我们一起走进沼泽地。创业公司就像游击队一样，喜欢选择不易生存的深山老林作为根据地，政府的正规军无法追到那种地方。我还记得创业初期我们是多么筋疲力尽，整体都为一些可怕的技术难题绞尽脑汁。但是，我还是感动相当高兴，因为那些问题连我们都觉得这么困难，那么竞争对手就更会认为是不可能解决的。</li></ul><h4 id="关注贫富分化"><a href="#关注贫富分化" class="headerlink" title="关注贫富分化"></a>关注贫富分化</h4><ul><li>总的来说，你要避免的是绝对贫穷，而不是相对贫穷。</li></ul><h4 id="设计者的品味"><a href="#设计者的品味" class="headerlink" title="设计者的品味"></a>设计者的品味</h4><ul><li>大人教导你说品味只是每个人的偏好而已。但是来到博物馆，他们却对你说，仔细观赏达芬奇的作品，因为他是伟大的艺术家，品味超凡。只要你开始思考这个问题，你就会发现，众多不同学科对“美”的认识有着惊人的相识度。优秀设计的原则是许多学科的共同原则，一再反复出现。</li><li>好设计是简单的设计。装饰品本身不是坏事，只有当它被用来掩盖结构的苍白时，才变成了一件坏事。</li><li>好设计是永不过时的设计。某些大师的作品太过杰出，永不过时，使得后人几乎难以在该领域立足。</li><li>好设计是解决主要问题的设计。</li><li>好设计是启发性的设计。</li><li>好设计通常是有点趣味性的设计。</li><li>好设计是艰苦的设计。并非所有的痛苦都是有益的。你需要的是咬牙向前冲的痛苦，而不是脚被钉子扎破的痛苦。</li><li>好设计是看似容易的设计。在大多领域，看上去容易的事情，背后都需要大量的练习。</li><li>好设计是对称的设计。</li><li>好设计是模仿大自然的设计。</li><li>好设计是一种再设计。很少有人一次就把事情做对。开源软件因为公开承认自己的BUG，反而使得代码的BUG比较少。</li><li>好设计是能够复制的设计。刚入门的新手不知不觉地模仿他人，逐渐熟练之后才可以创作原创性的作品。</li><li>好设计通常是奇特的设计。爱因斯坦并不想让相对论变得很奇特，他只想找出真理，是真理本身显得很奇特。米开朗基罗并没有想过要树立米开朗基罗风格，他只是想画好作品，结果不由自主地创造出了米开朗基罗风格。</li><li>好设计是成批出现的。</li><li>好设计常常是大胆的设计。</li></ul><h4 id="一百年后的编程语言"><a href="#一百年后的编程语言" class="headerlink" title="一百年后的编程语言"></a>一百年后的编程语言</h4><ul><li>效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快，这会变得越来越明显。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>功利主义</title>
      <link href="/gong-li-zhu-yi/"/>
      <url>/gong-li-zhu-yi/</url>
      
        <content type="html"><![CDATA[<p>穆勒认为，功利主义所谓的“幸福”或“快乐”不是指动物的幸福或快乐，而是指人的幸福或快乐，对于人来说，“理智的快乐，感情和想象的快乐以及道德情感的快乐所具有的价值要远高于单纯感官的快乐。”</p><p>承认某些种类的快乐比其他种类的快乐更值得欲求更有价值，这与功利原则是完全相容的。荒谬的倒是，我们在评估其他各种事物，质量与数量都是考虑的因素，然而在评估各种快乐的时候，有人却认为只需考虑数量这一个因素。</p><p>穆勒指出，功利主义并不反对自我牺牲，但反对把自我牺牲本身看作善事: “一种牺牲如果没有增进或不会增进幸福的总量，那么就是浪费。它（指功利主义）唯一赞成的自我牺牲，是为了他人的幸福或有利于他人幸福的某些手段而做出的牺牲。”</p><p>任何道德规范，如果没有相应的人性基础，从而是大多数人做不到的，那就会变成虚伪的说教。而它内在约束力则在于被我们称之为“良心”的道德感情。</p><p>对功利主义的误解: 指责功利主义把一切都交给快乐来处理，而且是交给最粗俗的快乐。（PS:功利主义称为效用主义比较好，但是约定俗成的原因就一直这样了）主张功利理论的每一位著作家，都从来没有把功利理解为某种于快乐判然有别的东西，而是把它理解为快乐本身以及痛苦的解除。</p><p>极少有人会因为可以尽量地享受禽兽的快乐而同意成为低等的动物；凡聪明人都不会同意变成傻瓜，凡受过教育的人都不愿意成为无知的人；凡有良心和感情的人，即使相信傻瓜、白痴和流氓比他们更满意于自己的命运，也不愿意变得自私卑鄙。他们不会为了最大程度地满足自己和傻瓜共有的各种欲望，而舍弃自己拥有单傻瓜不拥有的东西。</p><p>人们常常会由于性格的软弱而选择就近的善，尽管他们知道它的价值较低；这种情形不仅人们在两种肉体的快乐之间进行选择时存在，人们在肉体的快乐与心灵的快乐之间进行选择时也同样存在。他们虽然完全明白，健康是更大的善事，但仍然会沉迷于有害健康的感官快乐。</p><p>我们完全可以怀疑，一个高尚的人政府其高尚而永远比别人幸福，但毫无疑问的是，一个高尚的人必定会使别人更加幸福，而整个世界也会因此而大大得益。</p><p>动机虽然与行为者的品格有很大关系，却与行为的道德性无关。救人于溺水之中，总是道德上正确的行为，无论救人的动机是出于义务还是希望为此得到报酬。</p><p>任何行为规则都不可能做到没有例外，任何一种行为都不太可能被断定是永远应该做的或永远不该做的，这不是任何信条的过错，而要归咎于人类事务的复杂本性。</p><p>除了毫无道德感的人之外，几乎没有人能够忍受自己的生活安排只受到自己的私利驱动，即便考虑他人的利益也是出于私利的迫使。</p><p>功利主义学说主张，幸福是值得欲求的目的，而且是唯一值得欲求的目的；其他事物如果说也值得欲求，那仅仅是因为它们可以作为达到幸福的手段。对人类来说，唯有本身令人快乐的东西，或者是获得快乐免受痛苦的手段，才是善。</p><p>有些共产主义者认为，唯有按照绝对平等的原则来分配社会劳动成果才是正义的；另一些共产主义者认为，按需分配才是正义的；还有一些共产主义者则认为，那些工作更努力、生产更多产品，或者为社会做出的服务更有价值的人，才可以正当地要求劳动成果的分配中获取较大的份额。上述每一种观点的论证，似乎都可以合理地诉诸天然的正义感。</p><p>如果我们认为，一个人应当为某个行为受到惩罚，那么就会说这个行为是错的，但如果我们认为，一个人不应当为了这个行为而受到惩罚，那么就不会说它是错的，而会用其他一些表示不喜欢或者贬抑的语词来描述这个行为。如果我们愿意看到一个人受到强制去做某件事，那么就会说这样做是对的，但如果我们只愿看到一个人受到劝说和鼓励去做这件事，那么就不会说这样做是对的，而仅仅会说它是值得欲求的或值得称赞的。</p><p>安全利益，对任何一个人的感情来说，它都是所有利益中最重要的利益。世上一切其他利益，都可以为一个人所需而不为另一个人所需，其中的许多利益，如有必要，都能被人放弃，或被其他东西替代，但唯有安全，没有一个人能够缺少，我们要免除所有的祸害，要长久地获得一切善的价值，全靠安全。<br>对人类来说，禁止人类相互伤害的道德规则最为重要（决不可忘记的是相互伤害也包括错误地干涉彼此的自由），而其他任何行为准则无论多么重要，也只不过是向人们指出了如何处理某种人类事务的最好方式。</p><p>PS: 所谓自由是有限的，自由不等于为所欲为，其前提是不伤害别人，而往往有人遗忘了，他们错误的认为自由是无限制的。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哈佛-公正-该如何做是好</title>
      <link href="/ha-fo-gong-zheng-gai-ru-he-zuo-shi-hao/"/>
      <url>/ha-fo-gong-zheng-gai-ru-he-zuo-shi-hao/</url>
      
        <content type="html"><![CDATA[<p>课程介绍: </p><p>这是关于道德与政治哲学的一个入门系列课程，主要是围绕哈佛大学迈克尔 • 桑德尔教授法学系列课程《公正: 该 如何做是好？》展开评议。</p><p>本课程共 12 部分，旨在引导观众一起评判性思考关于公正、平等、民主与公民权利的一些基本问题。每周，超过 1000 位学生来听哈佛教授兼作家迈克尔 • 桑德尔的课，以拓展他们对于政治与道德哲学的认知理解，探究固有观念是与非。学生们同时还将接触过去一些伟大哲 学家 —— 亚里士多德、康德、密尔、洛克。然后，应用课程去分析复杂多变的现代问题: 赞助性措施、同性婚姻、爱国主义、忠诚度与人权等。</p><p>桑德尔在教学中通过一些假设或真实案例的描述，置学生于伦理两难困境中，然后要他们做出决定:  “ 该如何做是好？ ” 他鼓励学生站出来为自己的观点辩护，这 通常激发生动而幽默的课堂辩论。桑德尔然后围绕伦理问题展开，更深层次地触及不同道德选择背后的假设。这种教学法通常会揭示道德推论的矛盾本质。</p><p>课程类型: 哲学</p><p>课程主讲人: Michael J. Sandel 教授</p><p>网站: <a href="http://www.justiceharvard.org" target="_blank" rel="noopener">http://www.justiceharvard.org</a></p><p>内容介绍: </p><p>来自 <a href="http://www.hecaitou.com/blogs/hecaitou/archives/134359.aspx" target="_blank" rel="noopener">和菜头</a> 的推荐: </p><p>强烈建议各位去观赏一下哈佛法学教授迈克尔 . 桑德尔的公开课《公正: 该如何做是好？》（ Justice: What’s the Right Thing to Do?) 。我很清楚地知道，在《槽边往事》的读者中，学生们在学校里正在接受冗长的教育，公司人每年也会接受数量惊人的培训，甚至还有人正在自修。但是， 这里我还是建议你抽一点时间，接受这份额外的课外学习。</p><p>这一系列课程被评为哈佛新生最欢迎的公开课，并不是因为它只适合涉世未深的年轻人，又或者是它只适合哈佛学生那样的高智商人群。我推荐的它的理由在于: </p><p>1 、大家可以看到什么是真正的 “ 学习 ” 。课程没有任何内容需要你强背记忆，也不会要求你去做笔记，但是我相信你能够在很久之后还会记得课程所要讲授的内容，而且愿意在自己的 Blog 里主动做课堂笔记。对于真正有价值的知识传授，你没有道理会去错过，或者遗忘。</p><p>2 、大家可以看到什么是真正的 “ 教学 ” ，许多网友反应，看这套课程需要时常暂停。这是因为每一小节里，迈克尔 . 桑德尔都会从平实简单的例子出发，让 你不由自主地去思考他提出的命题。他并非回答问题，或者是解答问题，更不是灌输你观点，而是自始至终激发你的脑力震荡，对习见提出挑战，换从多个角度思考 看似最为简单的事情。</p><p>3 、大家可以看到什么是真正的 “ 政治学 ” 。《公正: 该如何做是好？》是为法学院学生开设的课程，出发点是谈公正和正义，一共分为 12 堂课。如果你看 过第一堂课，你就会知道，在愚蠢的国内大学教育中，政治学被庸俗化和弱智化到了什么程度，以至于大家会觉得只有乏味已极且心存卑鄙之辈才应该学习，人文学 科也只是纸面上的功夫。通过迈克尔 . 桑德尔的讲授，你可以看到任意结论的导出，后面都有论证的严谨和思考的精深。明白《政治学》并非只是教材上看到的那 套阶级分析的蠢话，而是切实地关心我们的处境，我们的生活，并致力于实现真正的公正。单是看西方思想家的思辨过程，就已经足够性感。</p><p>以下分课内容简介来自 <a href="http://article.yeeyan.org/view/100584/80057" target="_blank" rel="noopener">译言网</a> ，由 <a href="http://space.yeeyan.org/u/100584" target="_blank" rel="noopener">terrell</a> 网友翻译。特此致谢！</p><p>第 1 课 谋杀的道德侧面 / 同类相残案</p><p>2009 年 9 月 13 日</p><p>第 1 讲 杀人的道德侧面</p><p>如果必须选择杀死 1 人或者杀死 5 人，你 会怎么选？正确的做法是什么？教授 Michael Sandel 在他的讲座里提出这个假设的情景，有多数的学生投票来赞成杀死 1 人，来保全其余五个人的性命。但是 Sandel 提出了三宗类似的道德难题 - 每 一个都设计巧妙，以至于抉择的难度增加。当学生站起来为自己的艰难抉择辩护时， Sandel 提出了他的观点。我们的道德推理背后的假设往往是矛盾的，而什 么是正确什么是错的问题，并不总是黑白分明的。</p><p>第 2 讲 同类自残案</p><p>Sandel 介绍了功利主义哲学家 Jeremy Bentham （杰瑞米 · 边沁）与 19 世纪的一个著名案例，此案涉及到的人是 4 个失事轮船的船员。他们在海上迷失了 19 天之后，船长决定杀死机舱男孩，他 是 4 个人中最弱小的，这样他们就可以靠他的血液和躯体维持生命。案件引发了学生们对提倡幸福最大化的功利论的辩论，功利论的口号是 “ 绝大多数人的最大利 益 ” 。</p><p>第 2 课 给 生命一个价格标签 / 如何衡量快乐</p><p>2009 年 9 月 20 日</p><p>第 3 讲 给生命一个价格标签</p><p>Jeremy Bentham （杰瑞米 · 边沁）在 18 世纪后期提出的的功利主义理论 - 最大幸福理论 - 今天常被称为 “ 成本效益分析 ” 。 Sandel 举出企业运用这一理论的实例: 通过评估衡量一美元在生活中的价值来作出重要的商业决定。由此引起了功利主义 的反对观点的讨论: 即使当多数人的利益可能是卑鄙或不人道的时候也强调绝大多数人的利益，这样是否公平？</p><p>第 4 讲 如何衡量快乐</p><p>Sandel 介绍另一位功利主义哲学家 J.S. Mill （穆勒，也译作 “ 密尔 ” ）。他认为，所有人类的体验都可以量化，但某些快乐是更值得拥有，更有价值的。穆勒认为，如果社会重视更大程度的欢乐和公 正，那么长远来说，社会整体终会有所进步。 Sandel 的检验这个理论的方法是， 在课堂上播放了 3 个视频剪辑《辛普森 》 ，真人秀《勇敢者的游戏》，以及莎士比亚的《哈姆雷特》 - 然后要求学生辩论: 这三个体验里的哪一个应该被定为 “ 最大程度 ” 的快乐。</p><p>第 3 课 自由选择 / 我属于谁？</p><p>2009 年 9 月 27 日</p><p>第 5 讲 自由选择</p><p>自由主义者认为政府干预最少的社会是最理想的 社会形态。 Sandel 介绍自由主义哲学家 Robert Nozick ，他认为，每个个体都有选择自己想要的生活的基本权利。政府不应该具备权力来制定人们保护自我的法律（安全带法），不应该具备权力来制定把道 德价值观强加给社会的法律，不应该具备权力来制定把富人收入重新分配给穷人的法律。 Sandel 使用了比尔盖茨和迈克尔乔丹的例子来解释 Nozick 的理 论: 税收的重新分配是强迫劳动的一种形式。</p><p>第 6 讲 我属于谁？</p><p>自由主义哲学家 Robert Nozick 举出了一个向富人征税的例子 — 房屋税，医疗保健，穷人的教育 - 这是一种强制。学生们首先讨论了支持重新分配税收的观点。如果你在一个具有税收 制度较为进步的社会系统中，你是不是被强制交税？穷人到底需不需要那些他们已经获得的社会服务吗？他们值得享受那些服务么 ? 富人们是不是经常通过侥幸或家 庭财产获得财富？在这个讲座里，一组学生（名为 “ 自由意志队 ” ）被要求为自由意志的反对意见辩护。</p><p>第 4 课 我的地盘我做主 / 满合法年龄的成年人</p><p>2009 年 10 月 4 日</p><p>第 7 讲 我的地盘我做主</p><p>洛克（ John Locke ）既是自由意志论的支持者，也是它的批评者。 Locke 指出，在 “ 自然状态 ” ，在任何政治体制建立之前，每个人都享有生命，自由和财产的自然权 利。然而，一旦我们同意进入社会，就同意了受法律制度的约束。因此， Locke 认为，即使政府干预了个人的权力，这也是大多数人的意见赋予了它权力这么做 的。</p><p>第 8 讲 满合法年龄的成年人</p><p>洛克谈到税收和同意的问题，他是如何面对 以下两个问题的困扰:<br>1 ）他认为个人的生命，自由，财产具有不可剥夺的权利<br>2 ）政府通过大多数的条例 - - 未经个体同意，就可以向他们征税？难道这不等于未经他 / 她的同意，掠取他的个人财产？洛克的答案是，我们正在通过社会生活对税收法律做 “ 默认同意 ” ，因 此，税收是合法的。而且，只要政府不是特意对某一群体征税 - 如果不是武断专横的 - 那么税收并没有侵犯个人的基本权利。</p><p>第 5 课 雇枪？/ 出售母亲</p><p>2009 年 10 月 11 日</p><p>第 9 讲 雇枪？</p><p>内战期间，男子被征召到前线作战 - 但新兵被允许 可花钱雇人来顶替他们。 Sandel 教授问学生: 这项政策是自由市场交易的例子么？或者这是某种形式的胁迫？因为较低的阶层去服役肯定出自更多的经济诱 因？这引发了对战争和征兵等当代问题的课堂辩论。今天的志愿军真正是自愿的么？是否很多新兵都来自于不合比例的经济低下的背景？ “ 爱国主义 ” 起到了什么样 的作用？什么是公民的义务？公民是否该有为自己国家服兵役的义务？</p><p>第 10 讲 出售母亲</p><p>Sandel 教授把自由市场交易运用到当代颇具争议的新领域: 生殖权利。 Sandel 描述了现代的 “ 精子和卵子捐赠 ” 交易中那些奇怪的父母。紧接着 Sandel 把辩论 引向深入，他讲到了 “Baby M” 事件，此著名案例曾引发 “ 孩子是谁的？ ” 的问题和矛盾。事情是这样:  80 年代中期， Mary Beth Whitehead 和一对新泽西的夫妇签订了一项合约，同意为他们做 “ 代孕母亲 ” ，条件是支付给她一大笔的费用。但分娩之后 24 小时， whitehead 决定留下这个孩子，于是双方不得不对簿公堂。学生们讨论了出售生命的道德问题，争论点围绕承诺，契约和母亲的权利。</p><p>第 6 课 考虑你的动机 / 道德的最高准则</p><p>2009 年 10 月 18 日</p><p>第 11 讲 考虑你的动机</p><p>Sandel 教授在课程中这样介绍康 德: 最具挑战性和最有难度的思想家之一。康德认为，我们作为个体，是神圣的，是权力的享有者，但并不是因为我们拥有自己。相反，理性和自由选择是我们的能 力，使我们变得独特，使我们跟单纯的动物区别开。当我们将责任付诸行动的时候（去做正确的事），只有这样，我们的行动才有道德的价值。 Sandel 引用了 一个例子: 一名店主拒绝给一个顾客换零钱，只因他担心会影响他的生意。根据康德的理论，这不是一种道德行为，因为他没有找到正确的理由做正确的事 情 … 。</p><p>第 12 讲 道德的最高准则</p><p>康德说，就我们的行为的道德价值而 言，赋予它道德价值的是我们超越自身利益和偏好，将责任付诸行动的能力。 Sandel 讲述了一个真实的故事: 一名 13 岁的男孩赢得一项拼字比赛的冠军，但 随后他向法官承认，其实他把最后一个单词评错了。用这个故事和其他的故事， Sandel 解释了用康德的理论如何来确定一项行动在道义上是否正确: 在作出决 定时，想象一下，你的行为背后的道德原则，是否能成为每个人都必须遵照的普遍法律。这个准则，是否能作为一个普遍规律，让所有人都受益？</p><p>第 7 课 谎言的教训 / 协议就是协议</p><p>2009 年 10 月 25 日</p><p>第 13 讲 谎言的教训</p><p>康德的道德理论，严格到不允许有任何例外 情况，他认为如果说谎，即使是善意的谎言，都是对自己尊严的侵犯。用一个假设的案例来考验他的理论: 如果你的朋友藏在你家，一个杀手敲你的门来问他在哪 里，你会对他说什么 – 不要说谎 – 来救你的朋友？这引发了对 “ 误导性的真理 ” 的讨论 - 以及对克林顿总统利用精确的语言来否认与莱温斯基的性关系，而没有 直接向公众撒谎的讨论。</p><p>第 14 讲 协议就是协议</p><p>Sandel 介绍了现代哲学家 John Rawls 和他的 “ 假定契约 ” 理论。 Rawls 认为，实现最公正和公平的治理的唯一途径是，如果所有立法者都平等的站到谈判桌前。试想，如果他们都在 “ 无 知的面纱 ” 之后 – 在他们的个人身份信息暂时不公开（他们的种族，阶级，个人兴趣）的时候，他们必须就一系列法律达成共识。 Rawls 认为，只有这样，治理机构才能商定真 正公平公正的原则。</p><p>第 8 课 什么是公平的起点？/ 我们该得到什么？</p><p>2009 年 11 月 1 日</p><p>第 15 讲 什么是公平的起点？</p><p>John Rawls 把他的 “ 无知的面纱 ” 理论运用到社会和经济平等的争论焦点中，以及公平治理的问题。他问，如果每个市民都必须参与税收的再分配问题 — 在他们不知 道最终会成为社会成员中的穷人还是富人的时候 - 我们大多数人不是更喜欢消除金融风险并同意财富的公平分配么？</p><p>第 16 讲 我们该得到什么？</p><p>Sandel 教授重述了三种不同的理论，涉及如何在生活中分配收入，财富和机会。他总结了自由主义，精英制度系统和平等主义理论，引起了对当今社会薪酬差别的公正性的 讨论。 Sandel 比较了美国联邦最高法院 O’connor 大法官（ 200 000 美元）和法官 Judy （ 2,500 万美元）的工资。 Sandel 问大家，这是否公平？如果不是，原因何在？ Sandel 解释了 John Rawls 的观点 - 他认为，个人的 “ 成功 ” 往往是和荣誉无关的随机结果: 运气，继承的财富，积极的家庭环境。但是，对于付出更多努力和更长时间去获得成功 的个体 - 如何来衡量他 / 她付出的努力呢？</p><p>第 9 课 讨论反歧视行动 / 目的是什么？</p><p>2009 年 11 月 8 日</p><p>第 17 讲 讨论反歧视行动</p><p>学生们讨论反歧视行动和大学招生问 题。学校在招生的时候考虑种族和族裔因素是否正确？是否侵犯了个人权利？是否和喜欢一个明星运动员一样平等和主观？这样的争论是不是倾向于把推行多样化变 成合理的呢？这个观点应该如何来反对一个学生的努力和成绩更重要的观点呢？</p><p>第 18 讲 目的是什么？</p><p>Sandel 介绍亚里士多德关于公平和正义的理论，简单地说，是告诉人们他们该付出什么，该得到什么。亚里士多德认为，一个人在考虑分配问题的时候，必须考虑分配的目 标，终点和目的。对他来说，这是关于一个人找到合适的位置来发挥他的美德的事情。</p><p>第 10 课 好市民 / 自由与适应</p><p>2009 年 11 月 15 日</p><p>第 19 讲 好公民</p><p>亚里士多德的正义理论引起了有关高尔夫球的辩 论，特别是高尔夫球的 “ 目的 ” 。学生们辩论美国 PGA 在这件事上的做法是否错误 – 不允许残疾人选手 Casey Martin 在职业巡回赛中使用球具手推车。</p><p>第 20 讲 自由与适应</p><p>Sandel 指出了对亚里士多德关于自由 的观点最突出的反对声音 — 他为奴隶制的辩护。学生讨论对亚里士多德理论的其他反对意见，并辩论他的哲学是否限制了个人自由。</p><p>第 11 课 社会的需求 / 我们的忠诚在哪里</p><p>2009 年 11 月 22 日</p><p>第 21 讲 社会的需求</p><p>Sandel 教授介绍康德和 John Rawl 对亚里士多德理论的反对意见，亚里斯多德认为个体应该有自由有能力选择他的终极目标。这引来了关于共产主义观点的介绍。作为个体，我们该如何衡量 我们对家庭的义务，对社会的义务和对国家的义务呢？</p><p>第 22 讲 我们的忠诚在哪里</p><p>Sandel 教授发起了一个讨论: 在各种社会群体中，小到家庭这样的群体，大到社会，我们是否有团结协作的义务和成员的义务。针对不同的事件，学生们辩论忠诚是否比责 任更重要，何时更重要。</p><p>第 12 课 辩论同性婚姻 / 美好生活</p><p>2009 年 11 月 29 日</p><p>第 23 讲 辩论同性婚姻</p><p>如 果公正的原则取决于权利服务的终点是否有道德或内在的价值。社会怎样处理不同人对 “ 好 ” 持有不同的想法和观念？利用同性婚姻的例子，学生辩论是否可能把性 的道德合法性从婚姻的最终目的中脱离出来。</p><p>第 24 讲 美好生活</p><p>Sandel 教授提出了两个问题。是否有必 要找到美好生活的原因，以决定什么是正义，什么是人民的权利？如果是那样的话，是否可以争论或者证明美好生活的本质是什么？学生辩论时，进一步讨论了政府 在决定婚姻目的这个问题上的作用。 Sandel 作总结时指出，我们作为个体，可能永远不会同意许多道德哲学问题的争论点。不过他认为，一方面，关于这些问 题的辩论是不可避免的。另一方面，这给我们提供了一个更好地了解他人价值观的好机会。</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="第-1-课-谋杀的道德侧面-同类相残案"><a href="#第-1-课-谋杀的道德侧面-同类相残案" class="headerlink" title="第 1 课 谋杀的道德侧面 / 同类相残案"></a>第 1 课 谋杀的道德侧面 / 同类相残案</h3><h4 id="第-1-讲-杀人的道德侧面"><a href="#第-1-讲-杀人的道德侧面" class="headerlink" title="第 1 讲 杀人的道德侧面"></a>第 1 讲 杀人的道德侧面</h4><p>后果主义道德推理认为是否道德取决于行为的后果，取决于你的行为对外界所造成的影响。</p><p>绝对主义道德推理认为是否道德取决于特定的绝对道德准则，取决于绝对明确的义务和权利，而不管后果如何。</p><p>后果主义道德推理中最具影响的就是功利主义，由18世纪英国政治哲学家 杰里米•边沁(Jeremy Bentham)提出。</p><p>绝对主义道德推理中最为著名的则是18世纪德国哲学家 伊曼努尔•康德(Immanuel Kant)。</p><p>哲学就是让我们面对自己熟知的事物，然后引导并动摇我们原有的认知。</p><p>传授的都是已有的知识，它将我们所熟知的毋庸置疑的事物变得陌生。哲学让我们对熟知事物感到陌生，不是通过提供新的信息，而是通过引导并激发我们用全新方式看问题。一旦所熟知的事物变得陌生，它将再也无法回复到从前。自我认知就像逝去的童真，不管你有多不安，你已经无法不去想或是充耳不闻了。</p><p>在《高尔吉亚篇》中 苏格拉底的一位朋友 卡里克里斯，试图说服苏格拉底放弃哲学思考。他告诉苏格拉底: 如果一个人在年轻时代有节制地享受哲学的乐趣，那自然大有裨益。但倘若过度沉溺其中，那他必将走向毁灭。</p><p>面对这些，有一种典型的回避方式。这种方式就是怀疑论，大致的意思是争论过的案例或者原则，没有一劳永逸的解决方法。如果亚理士多德 洛克 康德以及穆勒花了这么多年都没能解决这些问题，那今天我们就能解决了吗？也许这本就是智者见智 仁者见仁的问题。多说无益，也无从论证，这就是怀疑论的回避方式。</p><p>诚然，这些问题争论已久。但正因为这些问题反复出现，也许表明虽然在某种意义上它们无法解决，但另一种意义上却又无可避免。它们之所以无可避免，无法回避是因为在日常生活中我们一次次地在回答这些问题。因此怀疑论让我们举起双手放弃道德反思，这绝非可行之策。康德曾很贴切的描述了怀疑论的不足，他写道怀疑论是人类理性暂时休憩的场所，是理性自省以伺将来做出正确抉择的地方，但绝非理性的永久定居地。康德认为简单地默许于怀疑论，永远无法平息内心渴望理性思考之不安。</p><h4 id="第-2-讲-同类自残案"><a href="#第-2-讲-同类自残案" class="headerlink" title="第 2 讲 同类自残案"></a>第 2 讲 同类自残案</h4><p>边沁的核心观点非常简单，充满了道德上的直观感染力。</p><p>边沁: 正确的选择；公正的选择。（the right thing to do; the just thing to do）PS: 最大化功利（maximize utility）</p><p>边沁认为功利等于快乐减去痛苦，幸福减去苦难。PS: 功利主义认为快乐和痛苦都是可以计算的</p><p>所有人类均受两大至高无上的因素所支配: 痛苦与快乐。（pain and pleasure）</p><p>人的本性就是趋乐避苦的，所以我们应以道德为基准，不管是在考虑个人行为时，还是作为立法者或普通公民，考虑如何立法时。于公于私最正确的选择都该是为全方位地最大化地提升幸福。边沁的功利主义有时被总结为一句口号: 为最多的人谋求最大的幸福。（The greatest good for the greatest number）</p><p>世上没有任何情况允许人类来主宰别人的命运或决断他人的生死，我们没有那样的权力。</p><p>某些基本权利我们有吗？（Do we have certain fundamental rights?）</p><p>只要程序公平就可以不论结果吗？（Dose a fair procedure justify any result?）</p><p>征得同意有何道德作用？（What is the moral work of consent?）</p><hr><h3 id="第-2-课-给生命一个价格标签-如何衡量快乐"><a href="#第-2-课-给生命一个价格标签-如何衡量快乐" class="headerlink" title="第 2 课 给生命一个价格标签 / 如何衡量快乐"></a>第 2 课 给生命一个价格标签 / 如何衡量快乐</h3><h4 id="第-3-讲-给生命一个价格标签"><a href="#第-3-讲-给生命一个价格标签" class="headerlink" title="第 3 讲 给生命一个价格标签"></a>第 3 讲 给生命一个价格标签</h4><p>边沁的主要观点简单明确就是: 道德的最高准则，无论个人道德还是政治道德，都是最大化公共福利，或曰集体幸福感，或者说权衡苦乐将幸福最大化。一句话，功利最大化。</p><p>边沁就是这样论证这一原则的“我们都受到痛苦和快乐的支配，苦乐是我们最高无上的主宰，因此任何道德体系都应考虑到它们。”最好怎样考虑呢？通过最大化。从而引出“为最多的人谋求最大的幸福”这一原则。</p><p>我们到底该最大化什么呢？边沁说: “应最大化幸福，或更精确来说最大化功利。”功利最大化原则不只针对个人也适用于共同体及立法者。</p><p>边沁问: “道德什么是共同体？”共同体是其成员的集合。所以在制定最优政策时，制定法律时，决定何谓公正时，公民和立法者应扪心自问这个问题。当用政策带来的总效益减去总成本，正确的选择应该是减去苦难后最幸福最大化的那一个。这就是所谓功利最大化。</p><p>功利主义的逻辑，通常被称作成本效益分析，一再被企业和政府运用。其做法包括做出估计，通常是估计出金额来代表功利。即分别列出成本和各项收益的金额。</p><p>功利主义是否充分尊重个体和少数的权利？</p><p>所有的价值都有可能用金钱衡量吗？</p><p>不能用统一方式衡量，那么功利主义道德理论意义何在？ </p><h4 id="第-4-讲-如何衡量快乐"><a href="#第-4-讲-如何衡量快乐" class="headerlink" title="第 4 讲 如何衡量快乐"></a>第 4 讲 如何衡量快乐</h4><p>功利主义只关注“为最多的人谋求最大的幸福”，没有充分地尊重个人权利。</p><p>是否可以将所有的价值都用统一的标准衡量。是否所有价值都可以计价。</p><p>功利主义这样假设是否正确，即假设价值同质，所有价值可比以及所有道德问题都能用金钱衡量。对价值和选择的简单相加。为何该同等看待所有偏好，而不区分其好坏呢？难道不该区分高级快乐和低级快乐吗？</p><p>不对人们选择的价值进行定性区分，其魅力就在于它是无偏见的平等主义的。边沁功利主义者认为每个人的偏好都有意义，不论人们所欲何为，不论其喜好各有不同。对边沁来说，要记住真正重要的，是快乐或痛苦的强度和持续时间。所谓“更高级快乐或更高贵美德”在边沁看来不过是更持久更强烈的快乐。他有一句名言表达此观点，只要快乐的总量相等，针戏与诗一样好。（The quantity of pleasure being equal, pushpin is as good as poetry.）什么是针戏？是当时一种儿童游戏，类似挑园片游戏。</p><p>这一观点暗含了一种主张，认为从本质上判定谁的快乐更高级更有价值或更好是非常无礼的。这种拒绝比较快乐的观点确有迷人之处。毕竟有人喜欢莫扎特，有人喜欢麦当娜。有人喜欢芭蕾，有人喜欢保龄球。谁能说这些快乐中谁的更高级，更有价值或者更高贵呢？但是不进行定性区分是对的吗？我们能摒弃这个观点吗，即我们某些爱好比其他更好或更有价值？古罗马斗兽场中罗马人获得的快乐，这种卑劣的有几分堕落的可耻的快乐在确定公共福利时还应该被算在内吗？</p><p>J.S. Mill（穆勒）是一个神童。三岁就懂希腊文，八岁时懂拉丁文，十岁的时候写了《罗马律史》 。二十岁时，他精神崩溃了。之后的五年一直陷于忧郁，但二十五岁时，他遇到了海立特•泰勒（Harriet Taylor）从此摆脱抑郁。他们结了婚从此过上了幸福的生活。正是在她的影响下穆勒试图把功利主义人性化。将功利主义演算放宽和修正以容纳人道主义关切，比如对个体权利的尊重，以及对高级和低级快乐的区别对待。</p><p>1859年穆勒写了本关于自由的名著《论自由》（On Liberty），书里的主要观点是争取个体和少数群体权利的重要性。</p><p>在1861年在晚年时期，他写了《功利主义》（Utilitarianism）。明确指出功利是道德的唯一标准，在他看来。他并没有质疑边沁的前提而是肯定此观点。他非常明确地说，任何事为人向往的唯一证据是人们真的向往它。所以他始终认为我们的实际欲望是道德判断的唯一基础。但在第八页，即第二章中，他提出功利主义者可以区分高级和低级快乐。</p><p>功利主义者何以将性质上更高级的快乐与较低级基本无价值的区分开呢？唯一能区分快乐级别高低的方法，就是看同时体验过两者的人更喜欢哪个。这两种快乐中，如果所有或几乎所有两种都体验过的人都更偏好其中一种，而且并不是出于任何道德责任换句话说，没有外界的独立的标准影响那么该快乐就是更令人满意的。</p><p>穆勒的观点是高级快乐的确需要培养鉴赏和教育。但他同时认为人一旦接受教育和培养，就应该不仅能区分高级和低级快乐，而且会真的更偏好高级快乐。（PS: 阳春白雪，下里巴人；通俗和高雅）</p><p>穆勒: “当痛苦的人胜过当快乐的猪；当痛苦的苏格拉底胜过当快乐的傻瓜。如果傻瓜或猪对此有异议，那只是因为他们未体验过更高级快乐。”（It is better to be a human being dissatisfied than a pig satisfied; better to be Socrates dissatisfied than a fool satisfied. And if the fool, or the pig, are of a different opinion, it is because they only know their side of the question.）（PS: 发现自己是傻逼总比自己不知道自己是傻逼好。）</p><p>穆勒说，我反对任何理论不以功利为基础，虚构公正标准。但是他依然把基于功利的公正称为所有道德的主体最无与伦比最神圣最有束缚力的部分。所以公正是更高级的，个体权利是种特权，但并不能出于功利主义假设之外的理由。公正对于一定的道德要求而言，从整体来看，在社会总功利的范畴内更高等因此也高于其它任何义务。所以公正神圣，至高，且享受特权。它是不能被轻易交换的。但穆勒称这个原因根本上还是功利的。当你考虑到人类，长远发展的利益。如果我们秉持公正尊重权利，从长远看社会整体会发展得更好。这令人信服吗，还是尽管穆勒没有承认，但他说存在性质上更高级的快乐以及个体权利神圣且极其重要这已经超出了功利主义范畴呢？</p><p>我们还没有完全回答这个问题，因为就权利和公正而言，要回答这个问题我们还需要了解，其它非功利主义解释权利基础的方式，然后才能思考它们是否成立。</p><p>边沁确立了功利主义作为道德和法律哲学学说的地位，一位生前生后都谨守自己哲学原理的哲学家。</p><hr><h3 id="第-3-课-自由选择-我属于谁？"><a href="#第-3-课-自由选择-我属于谁？" class="headerlink" title="第 3 课 自由选择 / 我属于谁？"></a>第 3 课 自由选择 / 我属于谁？</h3><h4 id="第-5-讲-自由选择"><a href="#第-5-讲-自由选择" class="headerlink" title="第 5 讲 自由选择"></a>第 5 讲 自由选择</h4><p>自由主义认为个人很重要，不仅仅是用来实现更高社会目标的工具或为了实现功利最大化的工具，个人是独立的存在，有独立的生命值得尊重。不该只以偏好和价值的加总来考虑公正或法律。</p><p>自由主义非常重视个人权利。它被称为自由主义是因为它宣称个人的基本权利是自由权。就因为我们都是独立存在的个体，我们不能被利用去满足社会可能的需求。就因为我们是独立存在的个体，我们享有自由的基本权利，即我们有权自由选择，过自己喜欢的生活只要尊重他人同等的权利。这就它的基本理念。</p><p>罗伯特•诺齐克（Robert Nozick）是这样说的，个人有权利。这些权利如此强大如此深远以至引发一个问题，如果有的话政府可以做什么。</p><p>自由主义对于政府或国家的角色有什么看法呢？大部分当代政府所做的三种事在自由主义理论看来是不合法不公正的。</p><p>第一，家长式的立法。（No Paternalist Legislation） 即制定保护人们免受自身行为伤害的法律，诸如系安全带，骑摩托车带头盔的法规。自由主义说系安全带也许是件好事但这应由人们自己做主，政府没有资格用法律来强迫人们系安全带。这是强迫，所以第一点不应有家长式的立法。（PS: 不是每个人都有自制力，太自由未免为所欲为了，最终会害了自己）</p><p>第二，不应有道德式的立法。（No Morals Legislation） 很多法律试图提高公民的品德或者试图树立整个社会的道德标准。自由主义者说这也违反了个人的自由权。举一个经典的例子，以弘扬传统道德之名立法，历来都有法律禁止同性恋行为。自由主义者认为其他人没有因此受到伤害也没有被侵权，所以政府不应该插手此事，不该试图立法弘扬道德。（PS: 这个还真不好说）</p><p>第三，任何为了劫富济贫，进行收入或财富再分配而制定的税收或其他政策。（No Redistribution of Income from Rich to Poor） 仔细想想再分配这个概率，按自由主义者的话来说就是强迫。它相当于政府施行的盗 窃，若是民主政府的话则是大多数人施行的盗 窃，其对象是工作出色而赚得大钱的人。诺齐克和其他自由主义者认为可以有这样一种“小政府”它的税收只用来提供所有人都需要的服务，包括国防，治安，强制履约和保护产权的司法系统，不过仅此而已。（PS: 我觉得能力越大，责任也越大。如果没有一定程度的再分配照顾社会底层，就不会有名副其实的机会均等。）</p><p>第一条原则 ，诺齐克称之最初占有的公正原则。这很简单就是说人们是否公平地获得生产资料？我们需要了解最初的占有是否来得公平？让他们赚到钱的土地工厂或者商品这些生产 资料是不是偷来的？如果不是偷来的如果他们有权享有那些生产资料，那就算符合第一条原则。</p><p>第二条原则 ，财富的分配是否基于自由达成的交易，基于自由市场的买卖？可以看出自由主义眼中的公平相当于自由市场理念下的公平。只要生产资料的获得是公平的，不是偷来的，只要分配的结果是出自自由市场上个体的自由选择，这样的分配就是公平的。反之则不公平。</p><p>诺齐克说征税相当于强占收入。换句话说，就是强占劳动果实。但如果政府有权强占我的收入或劳动果实，这在道义上不就等同于政府有权让我做部分义务劳动吗？所以实际上征税道义上等同于强迫劳动。因为强迫劳动会强占我的闲暇，时间，还有努力，就像征税会强占我的劳动所得一样。所以对诺齐克和其他自由主义者来说，在分配的税收是盗 窃。但是不仅如此，盗 窃还在道义上等同于强占生命和劳动的时间，因此等于强迫劳动。如果政府有权强占我的劳动果实，这就说明它确实有权强迫我劳动。什么是强迫劳动？诺齐克指出，强迫劳动就是奴役。因为如果我连对自己劳动的独占权都没有，这就说明政府或是政治共同体是我的部分主人。政府是我的部分主人又意味着什么呢？仔细想想，这就意味着我是一个奴隶，我不是自己的主人。</p><p>这些推理把我们带回到自由主义的权利主张所隐含的基本原则。那是什么原则呢？我就是我自己主人的原则。是尊重人权，自然会接受自我拥有的原则。如果你不想只把人看成是各种偏好的集合，那你必将走向这一基本道德理念“我们是自己的主人”，功利主义的问题就出在这里。这也是为什么摘取健康人的器官是错的。你这么做仿佛他的器官属于你或这个社会。但我们只属于我们自己。也正是出于这一理由才不该制定法律保护我们免受自己伤害或告诉我们该如何生活，该秉持怎样的道德规范，这也是为什么向富人征税来救济穷人不对，就算是为了公益事业，就算是为了帮助科特丽娜飓风的灾民。请富人去搞慈善活动吧。但如果对他们征税，就成了强迫劳动。你能强迫乔丹放弃下周的比赛必须下灾区去帮助卡特里娜飓风的灾民吗？道义上说，两者是一样。因此利害关系很分明的。</p><p>我们现在已经听了一些对自由主义的反对声。但要想驳倒自由主义，你就得打破它的这个推理过程，强占我的收入就是强迫劳动，强迫劳动就是让我做奴隶。</p><h4 id="第-6-讲-我属于谁？"><a href="#第-6-讲-我属于谁？" class="headerlink" title="第 6 讲 我属于谁？"></a>第 6 讲 我属于谁？</h4><p>“小政府”概念，自由主义经济学家弥尔顿•弗里德曼（Milton Friedman）指出许多人们觉得是理所当然的政府职能其实不应属于政府。这是家长式统治。他以社会保障为例。他说让人们在能挣钱的年头为退休而攒钱，社保的初衷是好的，但这样做不对。这侵犯了人们的自由，因为政府强迫所以人不管愿不愿意都得储蓄一部分当前收入留到退休时用。</p><p>如果人们想要碰运气或今朝有酒今朝醉哪管退休和凉水，那也是他们的选择。他们应该有决定的自由，冒险的自由。因此即使是社会保障也是弗里德曼主张的“小政府”所反对的。该理论认为有时公共产品例如治安保护和消费都将不可避免地造成“搭便车问题”。即使是我们以为理所当然属于政府职能范围内的公共产品原则上说其中很多都能独立出来，仅提供给付费者。（PS: 突然想起了逍遥游，在庄子的眼里客观现实中的一事一物，包括人类本身都是对立而又相互依存的，这就没有绝对的自由，要想无所依凭就得无己。）</p><p>在自由主义者的“小政府”概念中隐含着对强迫的担忧，强迫有什么问题呢？自由主义者的答案是，为了公共福利，强迫某人或者利用某些人是不对的，因为这是在质疑人人自主这一基本事实。人人自主或人人自有这一最基本道德事实。</p><p>自由主义者反对再分配的论断始于人人自主这一基本理念。诺齐克说如果整个社会可以向盖茨或者乔丹收税收走他们的一部分财富，社会这样做其实是在假定他们对盖茨或乔丹的财产拥有共同所有权，但那就违背了人人自主的基本原则。</p><p>如果没有社会条件，如果社会不稳定，你就很难正当的赚到钱，更别提拥有财产了。可能会为了养家糊口而犯罪，那就影响到别人了。</p><p>如果你不认同自由主义者对再分配的反对，那么似乎有一个突破点可以最快也最温和地打破自由主义的推理，那就是为什么这么多人都在争论说税收在道义上无异于强制劳动。但自由主义的论证中， 最根本的主张其前提和基础又如何呢？我们真的是自己的主人吗或者如果没有自我拥有这原则，我们还是可以跟自由主义者一样避免创造出一个这样维护公正的社会吗？即为了其他人的福利或为了大众的利益可以利用某些人？</p><p>自由主义者反对功利主义为大家谋幸福而利用某些人的理念，他们说摒弃“利用他人”的功利主义逻辑的办法就是依靠这一强大的我们是自己的主人原则。如果有一套公正理论和对权利的解释，对自我拥有提出质疑会引起怎样的后果呢？那是否意味着我们又回到了功利主义的老路上，利用他人还简单加总偏好，将健康人的器官取走？</p><p>诺齐克并没有独立创建自我拥有理论。他借鉴了另一位更早期的哲学家约翰•洛克（John Locke）洛克从自然状态角度解释了私有财产的兴起，他的推理思路和诺齐克等自由主义者的思路相似。洛克说私有财产之所以兴起，是因为我们将劳动付诸于无主的事物，所以取得了这些东西的产权。原因何在？因为我们拥有自己的劳动，这又是为什么？因为我们是自己的主人。所以为了检视自由主义声称的我们拥有自己的原则，我们需要看看英国政治学家J约翰•洛克是怎么说的，并探讨他对私有财产权和自我拥有的解释。</p><p>PS: 如果生活在社会中就不可能完全拥有自主权，因为你不能无视其他人的存在。 </p><hr><h3 id="第-4-课-我的地盘我做主-满合法年龄的成年人"><a href="#第-4-课-我的地盘我做主-满合法年龄的成年人" class="headerlink" title="第 4 课 我的地盘我做主 / 满合法年龄的成年人"></a>第 4 课 我的地盘我做主 / 满合法年龄的成年人</h3><h4 id="第-7-讲-我的地盘我做主"><a href="#第-7-讲-我的地盘我做主" class="headerlink" title="第 7 讲 我的地盘我做主"></a>第 7 讲 我的地盘我做主</h4><p>表面上看，洛克是自由主义的强力盟友。于当今自由主义者一样，他首先认为，有些基本的个人权利至关重要以至任何政府，甚至代议政府，甚至民主选举的政府都无法剥夺。不仅如此，他还认为这些基本权利包括生命，自由和财产的自然权利。此外他还认为财产权不仅仅是政府或是法律的产物。财产权某种意义上可以说是先于政治的自然权利。这种权利依附于个体而存在，甚至早于任何政府的建立，甚至早在任何议会和立法机关制定法律定义权利并强制实施前就存在。</p><p>洛克说为了理解拥有自然权利意味着什么，得先想象下政府与法律存在之前事物的运作方式，即洛克所说的自然状态。他说自然状态就是一种自由状态。每个人都是自由而平等的。自然状态下没有等级制度。并不是一些人天生就是君王而另一些人天生就是奴隶。（PS: 王侯将相宁有种乎）</p><p>每个人在自然状态下都是自由而平等的，但是他同时指出自由状态和放纵状态是有区别的。因为即使处在自然状态下，仍受某种法的约束。不是立法机关制定的法律，而是一种自然法。这种自然法制约着我们的行为，即便我们是自由的，即便是在自然状态下。它制约的是什么呢？自然法唯一制约的是我们拥有的这些自然权利，我们不能放弃也不能剥夺他人的。根据自然法，我不能随意剥夺他人的生命，自由或财产，也不能随意剥夺自己的生命，自由或财产。即使我是自由的，我也不难随意违背自然法。不能随意自身或出售自己成为奴隶或给别人绝对权力任意主宰我。 </p><p>你可能觉得这些制约相当微小，但它从何而来呢？洛克告诉了我们它的来源，他给了我们两个答案。</p><p>这是第一个答案。“既然人类都是无所不能和无限智慧的，创世主的创造物”，也就是上帝，“他们就是他的财产，是他的创造物，他要他们存在多久就存在多久，由不得他们自己做主。”第一个答案解释了为什么我们不能放弃我们的生命，自由和财产权利。因为严格来说，它们不是自己的，毕竟人都是上帝的产物（PS: 上帝可以换成天，大自然之类，毕竟每个人信仰不一样，或者认为说法不一样）。上帝更有权拥有我们，是种至高无上的权利。</p><p>你可能觉得这答案无法令人满意，没说服力，至少对那些不信仰上帝的人来说是这样。那么洛克对他们又有什么说法呢？洛克对其原因进行了解释，其解释如下，如果我们恰当反思自由的含义，我们便会得出结论: 自由绝不是让我们能为所欲为。</p><p>自然状态受自然法支配，人人均应遵循:  </p><p>而理性，即自然法，教导着有意遵从它的人类人人既然都是平等和独立的，任何人就不得侵害他人的生命，健康，自由，或财产。 （《政府论（下篇）》第二章“论自然状态”第6节）</p><p>这就引出了洛克在权利的诠释上令人费解的矛盾之处。某种意义上很熟悉，某种意义上又很陌生。他认为自然权利是不可剥夺的。“不可剥夺”是什么意思？就是我们不能远离，放弃，丢弃，交易或出售自然权利。某种意义上不可剥夺，不可转让的权利使我的所有物并不能完全为我所有。但另一种意义上说不可剥夺权利，尤其是我们的生命，自由和财产，正因为这些权利不可剥夺使我能更深刻更充分拥有它，这就是洛克对不可剥夺的解释。在美国《独立宣言》中可以看到，托马斯杰•斐逊引用了洛克的这个观点。生命与自由不可剥夺，还在洛克基础上加上了追求幸福的权利，都是不可剥夺的权利。这些权利如此基本，对我必不可少，连我自己都不能出售或放弃它们。</p><p>这些就是我们在政府产生前自然状态下拥有的权利。就生命和自由而言，我不能剥夺自己的生命。不能将自己卖为奴隶，我也不能剥夺他人生命或胁迫他人成为奴隶。但对财产而言又是怎样的情况呢？因为洛克理论中必不可少的一点是说私有财产在任何政府建立前就已经产生。但私有财产权利怎么能在政府建立之前就产生呢？洛克的经典回答在 《政府论（下篇）》第五章“论财产”第27节。</p><p>每人对他自己的人身享有一种所有权。除他以外任何人都没有这种权利。他身体的劳作，双手的劳动，我们可以说是正当地属于他的。 因此他更进一步，自由主义者此后也将如此，从自我拥有的观点，从我们拥有自我所有权更进一步到与之紧密关联的我们拥有自己劳动的观点。再从这更进一步为以下观点，任何施加了我们劳动的无主物品都是我们的财产。所以只要他使任何东西脱离自然所提供的状态，脱离现有状态，他就也将掺进他的劳动，在这上面施加了他自己所有的某些东西，因而是它成为他的财产。</p><p>为什么？因为劳动是劳动者无可争议的所有物，因此除这名劳动者以外对他施加或掺进劳动的所有物别人没有所有权。并加上了这一重要补充，至少在留有足够同样好的东西共有的情况下是这样的。但洛克认为我们获取到的财产不仅包括采集到的水果，捕杀到的鹿群，捕捉到的鱼群。如果我们犁田耕种并圈地种植了土豆，我们获取到的财富不仅是土豆，还包括那块土地。一个人能耕耘，播种，改良，栽培多少土地和能用多少土地的产品，这多少土地就是他的财产，这就像是他用他的劳动从公地圈来的那样。（《政府论（下篇）》第五章“论财产”第32节）</p><p>因此权利不可剥夺的观点似乎将洛克和自由主义者区分开了。自由主义者认为我们队自身拥有绝对所有权，因此我们能做任何自己想做的事。而洛克去不是完全支持这个观点。事实上，他说如果我们认真看待自然权利，你就会意识到我们的自然权利也受到一定制约，该制约不管是来自上帝或者是因为反思过什么是真正的自由，并认为真正的自由就是承认某些权利不可剥夺。这就是洛克于自由主义者之间的区别。但谈到洛克的私有财产观点时，他似乎又成了自由主义者的盟友，因为洛克对私有财产的论述，以如下观点开始，我们拥有自己的所有权因而拥有我们的劳动力，因而拥有我们的劳动成果，不仅包括我们在自然状态下采集或捕获的东西还包括我们圈地并耕种改良过的那些土地的所有权。</p><p>如果私有财产是与生俱来的，而非约定俗成，如果这是在我们同意组建政府前就拥有的，这个权利又如何能限制合法政府的行为呢？</p><p>为了最终搞清洛克到底是自由主义的盟友还是潜在的批评者，就得弄清一旦进入社会自然权利将有何变化。众所周知只有经过同意才能进入社会，才能脱离自然状态并被大多数人被人类法律体系所管辖。但这些人类法律合法的唯一前提就是尊重我们的自然权利，尊重我们不可剥夺的生命，自由和财产权。没有任何议会或立法机构，不管其宣称自己如何民主，能合理侵犯我们的自然权利。任何法律都不能侵犯生命自由和财产权的观点似乎是支持“有限政府”这一观点的，这点无疑很讨自由主义者欢心。</p><p>但他们不该高兴得那么早，因为在洛克看来，即便政府建立了自然法还是延续的，即便洛克坚持“有限政府”观点，政府最终受限于它的创建初衷，即保护我们的财产权。即便如此，还有个重要问题，即怎样才算我们的财产，怎样才算尊重我们的生命和自由，这是由政府来界定的。对财产的界定，对生命与自由尊重的界定就是限制政府的因素。但到底怎样才算对生命和财产的尊重，这是由政府来决定和界定的。</p><p>怎么会这样呢？是洛克在自相矛盾还是这存在着重大区别？我们得进一步研究洛克所指的合法政府是什么。</p><h4 id="第-8-讲-满合法年龄的成年人"><a href="#第-8-讲-满合法年龄的成年人" class="headerlink" title="第 8 讲 满合法年龄的成年人"></a>第 8 讲 满合法年龄的成年人</h4><p>政府是以征得同意为基础的，并是有限政府。洛克认为有些基本权利能限制政府的行为，并认为这些权利都是自然权利，不是由法律或政府赋予的。洛克伟大的哲学实验就在于他能否说明以下问题，私有财产权是怎么能够不经过同意在政府和法律出现并界定财产前就已存在。这是他的疑问。他的主张。洛克认为有种创造财富的方法，不仅包括我们采集捕猎到的东西，还有土地本身，只要还有足够多足够好的留给别人。</p><p>同意的作用是什么？同意这个概念在道德和政治哲学中很常见。洛克说合法政府是建立在同意的基础上而现如今又有谁会不同意他的观点呢？当时当一些政治哲学家对同意的看法与洛克非常相似时，都让人很难理解或至少不会觉得很有趣。洛克关于同意是合法政府建立基础的理论也有些令人困惑和奇怪的地方。</p><p>一个检验洛克同意理论并查清其让人困惑之处的方法，就是看根据洛克理论基于同意而建立的，合法政府能做什么有何权力。为了回答这个问题，回顾一些自然状态会很有帮助。记住，自然状态是我们决定脱离的状态，正是因此产生了同意这一概念。</p><p>为什么不保持那个状态为什么要建政府呢？洛克说自然状态有一些不便之处，什么不便之处呢？主要的一点就是每个人都能行使自然法。每个人都是执行者或洛克说的自然法的“执刑者”，这个“执刑者”可以字面上理解。如果某人触犯了自然法，他就是侵略者。他就是失去了理智你就可以惩罚他。而且在自然状态中你不必对实施惩罚的程度太过小心。你可以杀了他。你可以理所当然地杀死一个跟踪你，想谋害你的人。那是自卫。而说到执行权，惩罚权，自然状态下人人都能实施处罚权。不仅可以处死那些跟踪你想谋害你的人，还可以惩罚想偷你东西的小偷，因为那也算侵犯了自然法。如果有人透露第三方的东西，你也可以抓他。为什么？违反自然法是一种侵略行为。没有警察，没有法官，没有陪审团，所以每个人都是自己的法官。而洛克发现人们审理自己的案子时，他们往往会失去理智，这就引出了自然法的不便之处。有人行为过度了，就变成了侵略，就能惩罚他。不知不觉间，所以人不可剥夺的生命，自由和财产权都没了保障。 他用很强硬甚至可怕的字眼描述你可以怎样对待违反自然法的人。“一人可以摧毁向他挑起战争的人正如他可以杀死一匹狼或一头狮子。这种人除强力和暴力的法则之外没有其他法则”注意这里，“因此可以被当作猛兽危险和有害的动物看待，要落在它们的爪牙之内就一定会遭到毁灭，所以先下手为强。”</p><p>乍一看自然状态是十分良善的，人人皆自由但还有自然法，自然法尊重人们的权利，而这些权利是如此强大，它们是不可剥夺的。乍一看非常良善，一旦仔细看，会发现它粗暴且充满暴力，而这就是人们想脱离的原因。怎么脱离呢？这时候同意就登场了。唯一脱离自然状态的办法就是采取同意这一行为，你同意放弃你的执行权，同意建立一个政府或一个共同体。政府或共同体中有立法机关制定法律并且所有人都事先同意，任何加入的人事先都要同意遵从大多数人的决定。但问题出现了，多数人到底有何权利，他们能决定什么？多数人到底有多大权力呢？基于同意组成的政府又受多大限制呢？它受限于多数人有义务尊重并维护公民的基本自然权利。加入政府时，我们可并未放弃这些权利。不可剥夺的权利。</p><p>最高权力，未经本人同意不能取去任何人财产的任何部分，因为既然保护财产是政府的目的也是人们加入社会的目的，这就必然假定而且要求人们应该享有财产权。 （《政府论（下篇）》第十一章“论立法权的范围”第138节）</p><p>这就是当初人们加入社会的初衷，为了保护财产权。洛克所说的所有权，通常概括了所有的自然权利，即生命，自由和财产权。因此在社会中享有财产权的人们，对于那些根据社会的法律，是属于他们的财产就享有这样一种权利。即未经他们本人的同意任何人无权夺去。所以，以为任何国家的立法权能为所欲为任意处分人民产业或掠夺任何财产这是错误的想法。</p><p>这就是晦涩的地方。一方面，他说未经你同意政府不能取走你的财产。他非常明确这点。但之后他又说，而且财产权是自然权利。但然后，他的意思似乎是如何界定财产权不是与生俱来而是约定俗成的，是由政府定义的。“根据社会的法律是属于他们的财产。”而继续下去情况就更复杂了。“政府没有巨大的经费就不能维持。凡享受保护的人都应该从他的产业中支出他的一份来维持政府。但是这仍须得到他自己的同意，即得到大多数的同意，由他们自己或选出的代表所表示的大多数同意。” 洛克这里到底指的是什么呢？</p><p>财产既是自然权利但也有约定俗成的一面。自然权利是说财产权是基本的不可剥夺的，正因为它是这样的权利，所以有产权制度存在并被政府所尊重。所以任何掠夺他人财产就侵犯了自然法就是非法的。但财产还有约定俗成的一面，就引出了更进一步的问题。什么才算财产，财产如何定义且何种行为才算掠夺财产，这是由政府决定的。在回到关于同意的问题，同意的作用是什么？征税想要合法化的必要条件就是要经过同意，不是经过比尔盖茨本人同意如果他不得不交税的话，而是要经过他和我们，社会中的每个人同意在我们当初脱离自然状态并组建政府的时候就同意的。是集体性的同意。这样解读的话，似乎同意的作用意味深远而经同意建立的有限政府也并不那么有限。</p><p>自由主义者对洛克的失望在于两点。首先，有些权力是不可剥夺的，所以我并非真正地拥有自己。我不能放弃自己的生命或自由或财产，因为某种程度上说这侵犯了我的权利。这是他们失望的第一点。失望的第二点，一旦经过同意建立合法政府后，对洛克来说它唯一的限制就是不能肆意夺取生命或自由或财产。但如经多数人决定，如果多数人颁布一部普遍适用的法律并经公平程序，投票决定，那就不算侵权，不管是征税还是征兵。</p><p>所以很明显，洛克是在担心国王的绝对专权，但同时洛克也确实有黑暗的一面，这位同意观点上的伟大理论家提出理论却是私有财产的取得并不不要获得同意，这也许跟洛克关心的第二件事有关，即为殖民美洲作辩护。洛克这位昔日的殖民事务大臣，可能乐于正义化当时的土地私有化举动，即只有圈地并耕种该土地不需同意就能拥有它。同时他也在完善一个理论，基于同意建立的政府能限制国王和专制统治者。</p><p>剩下的就是最基本的问题，究竟同意是什么？同意由何用？同意有何道德上的力量？同意又有何限制？同意不只对政府很重要，对市场也是。 </p><hr><h3 id="第-5-课-雇枪？-出售母亲"><a href="#第-5-课-雇枪？-出售母亲" class="headerlink" title="第 5 课 雇枪？/ 出售母亲"></a>第 5 课 雇枪？/ 出售母亲</h3><h4 id="第-9-讲-雇枪？"><a href="#第-9-讲-雇枪？" class="headerlink" title="第 9 讲 雇枪？"></a>第 9 讲 雇枪？</h4><p>洛克认为重要的是政治当局或军事当局不是专制的，这才是关键。将军有权处死一个擅离职守或不服从命令的士兵，但尽管这些长官拥有生杀大权， 他们无权取走这位士兵的一分一毫。因为这不是他的合法权力，这就是专制，就构成了腐 败。 （《政府论（下篇）》第十一章“论立法权的范围”第139节）</p><p>所以在洛克 理论中，同意影响重大。不是个体对征税或军事命令的同意，而是在最初同意加入政府并同意受到大多数约束，这才是具有关键意义的同意，而且这点关键到即使我们建立有限政府的初衷是保护不可剥夺的生命、自由和财产权。即使初衷如此，但有限政府唯一的限制只是必须依照通行法律实施统治，依法治国。</p><h4 id="第-10-讲-出售母亲"><a href="#第-10-讲-出售母亲" class="headerlink" title="第 10 讲 出售母亲"></a>第 10 讲 出售母亲</h4><p>某些产品不应该对外放开使用权或用于牟利。某些产品的价值并不能从使用价值来评定。除了使用价值之外还有很多价值标准，这些产品如果只从功用上考虑，它们的价值并不能被准确评估。</p><p>某种程度上它把我们带回到功利主义的讨论，功利或者说功用是否是评价商品的唯一适当方式，包括评价生命、兵役、生殖、生育？我们怎么决定哪些估计模式才能合适正当地评价那样的产品呢？</p><p>是否有某些东西是金钱买不来的，不仅是因为合同不完全自由，还可能是因为这些产品的价值评定不单纯限于它们的使用价值。</p><hr><h3 id="第-6-课-考虑你的动机-道德的最高准则"><a href="#第-6-课-考虑你的动机-道德的最高准则" class="headerlink" title="第 6 课 考虑你的动机 / 道德的最高准则"></a>第 6 课 考虑你的动机 / 道德的最高准则</h3><h4 id="第-11-讲-考虑你的动机"><a href="#第-11-讲-考虑你的动机" class="headerlink" title="第 11 讲 考虑你的动机"></a>第 11 讲 考虑你的动机</h4><p>康德是反对功利主义的。个人之所以是受到尊重的或者是权利的拥有者，并不是源于我们支配和拥有自己。而是源于，我们都是理性的存在。我们是理性存在，其意义就是我们都有理性。同时我们也是独立自主的存在。也就是说，我们有能力自由的选择和行动。理性和自由并不是我们仅有的能力，我们还有痛苦和快乐，受苦和满足的能力。</p><p>康德也承认，功利主义的观点一半是正确的。当然，我们会回避痛苦，我们追求享乐，康德并不否认这一点。他所驳斥的是边沁的说法，边沁认为痛苦和快乐主宰了我们，康德认为这是错误的。康德认为，是我们的理性让我们脱颖而出，让我们变得截然不同，使我们区别开，而且高于动物的存在，使我们成为不仅仅是只有欲望的肉身。</p><p>我们通常会认为，自由就是我们做自己想做的事，或者毫无障碍的得到想要的东西。这是对于自由的一种看法，但是康德不是这么看。康德制定了更为严格的定义来解释自由是什么，这一定义既严肃又苛刻。但如果你仔细想想，你会发现它很有说服力。康德的推理如下: 如果我们像动物一样，追求享乐或欲望的满足，或者回避痛苦。如果我们是那样的话，我们并不是真正的自由的。欲望这样我们就成了这些欲望和冲动的奴隶。我们不能选择某种饥饿或某种欲望。因此，当我们去满足它的时候我们只是去适应我们的本能需求而已。</p><p>在康德看来，自由是本能需求的对立。自由的行动就意味着自主的行动，自主的行动就意味着遵从我为自己设定的规则而行动，不是出于自然法则或因果定律。康德发明了一个术语来描述自主的对立面，自主的对立就是“他律”。当我因“他律”而行动时，我的行为是出于某种偏好或本能欲望，而不是我自己选择的。因此，康德坚持将自由严格的视作是自主的。为什么“他律”或本能的行为其对立就是自主呢？康德的观点是，自然是受规则支配的，例如因果关系的定律。假设你丢下一个台球，它就会掉到地上，我们都不会认为，这个球的行动是自由的，因为它的行为遵循自然规律，遵循因果关系的规律，即万有引力定律。</p><p>正如对自由的定义超乎寻常的严厉和苛刻，康德对道德的定义也很苛刻。行动自由，并不是选择最好的手段，来达到特定的目的。而是为了选择目的的本身，这正是人类可以做到，而台球无法做到的。当我们处于偏好或享乐的行为，我们成了时下目的的手段，而这个目的是外加给我们的，我们成了工具，而不是实现目的的主人，这就是我们的意志受“他律”支配。另一方面，当我们根据我们给自己制定的规律，自主的行动时。我们的行为本身就是目的而不是手段，当我们自主行动时，我们好像是工具实现外加给我们目的的工具。但我们可以反过来，将我们自己看做是目的。康德告诉我们，正是这种自由行动的能力赋予了人类独有的尊严。尊重人类的尊严，意味着不仅仅要将人视为实现目的的手段，而且要将人本身也视为目的。这就是为什么，为了某些人的幸福而利用其他人是错误的。康德认为，这就是功利主义是错误的真正原因。这就是尊重他人的尊严，维护他人的权利是重要的原因所在。</p><p>行为的道德价值并非在于行为，行为所产生的结果。行为的道德价值，与行为的动机有关，与意志的品质有关，与行为的意图有关。关键的是动机而且必须是某种类型的动机。因此，某一行为的道德价值取决于行为的动机。重要的是，那个人除以正确的目的，做了正确的事。“高尚的一种之所以高尚，并不是看它的效果，”康德写道，“它本身就是高尚的。即使尽了最大的努力，也一无所成，它仍像珠宝一样，因其自身而闪耀，它本身就蕴含了全部的价值。” 因此，如果某种行为在道德上是好的，仅仅符合道德准则是不够的，其目的必须是道德的。康德的观点是，动机赋予了行为的道德价值，而且只有一种动机，可以给行为赋予的道德价值，这就是出于职责的动机。在康德看来，责任的对立就是所有那些与我们的偏好相关的动机。“偏好”是指我们所有的欲望，所有的依外部情况而定的渴望、喜好、冲动、诸如此类。只有出于道德准则，出于职责所采取的行为，才具有道德价值。</p><p>遵守道德规范是需要一些激励，这种激励不可以是与道德相冲突的，满足个人利益的激励。康德提出了另一种不同于“偏好”的激励。他说，这是对道德规范的崇敬。因为他形成了自己动机，他的意志符合道德标准。如果符合道德的行为是指出于职责，按照道德标准来行动，而且这行为也是自由的，自主的。那就一定意味着，人们是按照给自己设定的准则来行动的，这就是自主行动的意思。不过这也引发了另外一个有趣的问题，如果行动自主，意味着根据人们为自己设定的准则来行为。那么，人们就可以逃脱自然规律和因果定律的束缚。当人们出于职责行事的时候，怎么保证人们为自己设定的准则与其他人给自己的准则是一样的呢？</p><p>听起来。自主行为就是根据自己的良心行动。但是怎么保证，人们使用各自的理性，最终会得出同意的一个道德准则呢？对此，康德的回答是: 作为自主的个体，之所以能得出同一个的行为原则是因为一种理性，这是一样人类所共有的理性，它不是个人独有的。它给我们设立了一个先验，不管任何的外部情况或经验的目的。 那么这种理性能提供怎样的道德准则呢?它的内容是什么？</p><h4 id="第-12-讲-道德的最高准则"><a href="#第-12-讲-道德的最高准则" class="headerlink" title="第 12 讲 道德的最高准则"></a>第 12 讲 道德的最高准则</h4><p>很多时候，人们行为的动机都是利己的。康德不否认这点，但康德的意思是，关于我们的道德行为，关于我们的行为具有道德价值，赋予其道德价值的，正是我们那超越自我利益，偏好的能力。</p><p>康德说，理性有两种不同的律令。其中一种称之为“命令”。有一种命令就是假言命令，它是工具性的理性。它是目的&gt;&gt;&gt;手段的推理。如果该行为是实现目的的手段，这个就是假言命令。如果行为本身是好的，因此这个意志本身就符合理性。那么，它就是“定言命令”（或绝对命令）。定言命令是绝对性的，这就意味着，它不依赖任何其他目的。</p><p>如果在同一时间所有人都遵循某个法则。那么，它应该是普遍法则。某个法则，是指能解释你做事情的原因的一个原则。例如守信。如果每个人都做出虚假承诺，那么将没有人相信这些承诺，就不存在承诺这个东西。</p><p>我们不能把定言命令建立在任何特定的利益，目标或目的的基础之上。因为那样，它只与人的目的有关。然而，有一些东西，它的存在就具有绝对的价值，其自身就是目的。在其本身，单单是它本身，而这会是定言命令的基础。康德给出的答案是，人，一个理性的人，其本身就是目的，而不只是被其他意志任意利用的手段。</p><p>你总是以下这种方式行事，你总是把人，不管是你自己，或者其他人，你从不把它简单的视作一种手段，但你同时把它看做目的。这就是康德的表述，把人视作目的，作为理性的存在，人本身即是目的，而不是被用来使用的手段。</p><p>康德给了我们一个令人信服的解释，但这是关于道德的最高原则的，有说服力的解释吗？</p><hr><h3 id="第-7-课-谎言的教训-协议就是协议"><a href="#第-7-课-谎言的教训-协议就是协议" class="headerlink" title="第 7 课 谎言的教训 / 协议就是协议"></a>第 7 课 谎言的教训 / 协议就是协议</h3><h4 id="第-13-讲-谎言的教训"><a href="#第-13-讲-谎言的教训" class="headerlink" title="第 13 讲 谎言的教训"></a>第 13 讲 谎言的教训</h4><p>在康德看来，因为是你自己选择接受这些道德法则，而不是外界强加于你身上的。因为发自于责任感的行动，就是对道德法则的遵循，而这种遵循是人本身发起的，这就是为什么责任能与自由相和谐。</p><p>那么是什么能保证所有人的道德心一样呢？康德回答道，因为道德法则的趋势并不是某种条件下诱发的偶然现象，它将超越人与人之间所有的不同，将成为一个普遍法则。在这个方面看来，只有道德法则才有这种特性，因此它是纯粹的理性作出的判断，是至高无上的，是绝对命令。纯粹的理性就是我们在顺从于任何外部环境会带来的影响之前作出的选择。</p><p>那么绝对命令怎么能成为可能呢？为了回答这个问题，康德说我们要作出一个区分，我们要区分清楚两个立场，这两个立场是从我们的经验中得到的。</p><ul><li>作为一个经验客体，我属于这个感官世界（As an object of experience, I be to the sensible world.）。我的行为是由自然法则所决定的（There my actions are determined by the laws of nature），是由因果规律所决定的（and by the regularities of cause and effect）。</li><li>但作为一个经验主体，我居住在一个智慧的世界（But as a subject of experience, I inhabit an intelligible world here），不受自然法则的干扰（being independent of the laws of nature），我有自主能力（I am capable of autonomy）,我能够自主行使我赋予我自己的法则（capable of acting according to a law I give myself）。</li></ul><p>康德说，只有从第二个立场上，我才能认为我自己能自由的由起因作出不依附其他的决定，在这个感官世界这就是自由。如果我只是遵从我自己对痛苦，快乐，饥饿，饥渴，胃口的感觉的驱使，如果是这些的话，我们不可能得到自由（PS: 即人类自身动物本能）。</p><p>痛快的谎言和误导的真相这两者间有道德上的区别么？从康德的观点看来一个谎言和一个误导的真相的区别有一个世界那么大。因为康德并不是把道德建立在结果之上的，他认为道德就是对道德法则的遵守。康德不能容忍善意的谎言，但他能接受一个误导的真话（PS: 克林顿拉链门）。在误导性事实中，动机有两个，一是误导别人，同时也有说出真相，尊重道德的动机。同谎言不一样，说出有误导的事实，对道德责任仍然有一定的尊重。</p><h4 id="第-14-讲-协议就是协议"><a href="#第-14-讲-协议就是协议" class="headerlink" title="第 14 讲 协议就是协议"></a>第 14 讲 协议就是协议</h4><p>康德认为公正的法律来自于某种社会契约。但是他告诉我们，这种契约性质特殊，它并没有真正的契约缔结过程。康德指出，缔造公正和正义的契约，是所谓理性理念的产物。康德的理由是，在一个真正的制宪会议中聚集起来的人们会有不同的利益、价值观和目标，也会有不同的谈判筹码和博弈能力，在知识方面也会纯在差异。因此从他们的协商中产生的法律，不一定是公正的，也不一定是正义的。所以康德说，缔造正义法则的契约仅仅是理性观念的产物（A contract that generates princioles of right is merely an idea of reason），但它拥有毋庸置疑的实践真实性（but it has undoubted practical reality），因为它能够促使每一位立法者在制定法律的时候都与全国人民的整体意愿相符（because it can oblige every legislator to frame his laws in such a way that they could have been produced by the united will of the whole nation）。</p><p>自律的理念可能没有实现，因为可能存在各方议价权力的不等。互惠的理念可能没有实现，因为可能存在各方知识上的差距，因此他们可能错误地判断什么是真正具有相等价值的。罗尔斯认为思考正义的方法就是站在一个假想契约的角度，站在无知之幕的背后，它创造了平等的条件。通过排除，或者使我们暂时忘记权力和知识的差距，这些差距在大多数情况下会导致不公平的结果。这就是为什么对康德和罗尔斯来说，一个各方平等的假想契约是思考正义原则的唯一途径。</p><hr><h3 id="第-8-课-什么是公平的起点？-我们该得到什么？"><a href="#第-8-课-什么是公平的起点？-我们该得到什么？" class="headerlink" title="第 8 课 什么是公平的起点？/ 我们该得到什么？"></a>第 8 课 什么是公平的起点？/ 我们该得到什么？</h3><h4 id="第-15-讲-什么是公平的起点？"><a href="#第-15-讲-什么是公平的起点？" class="headerlink" title="第 15 讲 什么是公平的起点？"></a>第 15 讲 什么是公平的起点？</h4><p>收入、财富与机遇的分配，不应基于不能取信于人的因素上（the distribution of income and wealth and opportunities, should not be based on factors for which people can claim on credit）。不能基于道德观点专断的因素上（It shouldn’t be based on factors that are arbitrary from a moral point of view）。</p><p>罗尔斯通过一些相对的公正理论来说明。他开篇说的是一种公正理论，一种现今绝大多数人会反对的理论，封建的贵族制度。罗尔斯说，明显的错误是，人们的人生前途是取决于出身的偶然性的。你不能选择，你的出身不是你的行为，也不是你所拥有的机遇，而是道德规范的专断。所以，针对封建贵族制度的反对意见是说，职业应该向有天赋的人开发。应该有正式的机遇的平等，每个人应该自由奋斗、择业。</p><p>罗尔斯认为这是一种进步，因为这不限定出生的偶然性。但是即使是正式的机遇平等，自由主义概念并不超出其范围很远。因为如果你让每个人跑步比赛，每个人都可以参加，但有些人开始的起跑点不同，那么竞赛就不公平。这一体系最明显的不公平，是其允许分配受到不恰当的影响，来源于专断的道德观念。比如说，你是否有受到很好的教育。是否你成长的家庭很支持你。培养你的工作理念并给你提供机遇。所以就说到了公正的体系，机遇平等的公正体系。就是我们可能称作为优秀评价体系，是择优的体系。在公平的择优体系中，社会建立起了制度，把每个人都置于同一起跑线，平等的教育机遇（PS: 在美国大学学费越来越贵，普通家庭很难交得起学费，在中国倒是幼儿园越来越贵了）。</p><p>那么罗尔斯如何看待择优体系的呢？在他看来，即使那样，也不够来补偿与应对，在道德上的专政。只是自然界的抓阄结果。因为如果你把每个人都放到同一起点，谁会赢呢？最有天赋的人会赢，什么让他们正好有天赋？所以罗尔斯说，即使是择优的原则，当你把所有人都放到同一起跑线的话，的确能降低社会的意外性与背景影响，但即使这样依然存在财富与收入的不平衡。而造成不平衡的，是对能力与天赋的自然随机分配。所以他认为消除的原则，消除收入与财产分配影响的道德专断的原则，要求超越择优的体系。</p><p>那么如何超越？对于天生跑得快的，有些人认为唯一能做的就是妨碍那些跑的快的，让他们穿铅鞋。但是谁又会想要这么做呢？因为那样会完全颠覆赛跑的本身意义。但是罗尔斯认为，你不必须去推动一种平面上相等，即使你想要超越择优的概念。你可要允许，甚至可要鼓励，那些有天赋的幸运儿，去发挥他们的才华。但是你做什么呢，你是否改变了条件，决定人们是否有权享用其自身成果，由其基于自身天赋的努力所取得的成果。而那就是标准真正的差异原则。你建立了一个标准，规定说人们可以通过其自身的好运气而受益，受益于遗传优势方面的好运，但只能是基于为最底层人们某福利的条件上。因此，例如，迈克尔乔丹可以年收入上亿美元，但是只能是在税收掉其相当一部分收入的系统中才行，用以帮助那些缺乏像他那种篮球天赋的人。他可以运用他的巨额财富，但是他不能以为他自己是在道义上应得那些财富（PS: 收税的原因，社会财富的重新分配）。</p><p>那些被自然相中的人们（Those who have been favored by nature），可以获取财富，但只有在改善的前提下（may gain from their good fortune only on terms that improve），改善那些不那么有天赋的人的生存情况的前提下（the situation of those who have lost out）。这就是差异原则，而且这也是道义主观主义者的论点。</p><h4 id="第-16-讲-我们该得到什么？"><a href="#第-16-讲-我们该得到什么？" class="headerlink" title="第 16 讲 我们该得到什么？"></a>第 16 讲 我们该得到什么？</h4><p>针对罗尔斯的差异原则，有几种反对观点。</p><ul><li>鼓励激励怎么办？（What about incentives ?）是否有风险说，如果税赋上升到临界百分比，然后迈克尔乔丹就不肯打篮球了，或者那些CEO都情愿去做别的工作。</li><li>对于这种观点罗尔斯说到: 自然条件上所带来的优势（The naturally advantaged are not to gain），不仅仅是得益于他们的天赋更好（merely because they are more gifted），而只是用于满足训练和教育的花销（but only to cover the costs of training and education），以及发挥他们的天赋来帮助那些不太幸运的人（and for using their endowments in ways that less fortunate as well）。所以你可以有激励机制，你可以调整税率。如果过多的话，最终是会伤害到社会最底层人们的权益的。这就是辨别的标准。</li><li>那么努力怎么算？（What about effort?）那些努力工作的人，有权享有其所得所赚取的，因为他们值得拥有其所赚取。他们有为之努力奋斗。</li></ul><p>这就是从努力和道义应得方面提出的反对观点。然后，又有另外一个反对观点。这个反对观点是来自于自由主义者的。而这个反对观点来源于重申对自身拥有的思想。</p><ul><li>那么关于自我所有权呢？（What about self ownership?）是否差异原则，看待我们的自然天赋与努力看做成公共财富，这个理念是否违反了我们自己拥有自己的概念？</li></ul><p>弥尔顿·弗里德曼在他书中写到，“选择的自由（Free to Choose）。生命本不是公正的（Life is not fair）。而其倾向于认为政府可以修正（It is tempting to believe that government can rectify），所发生的自然现象（what nature has spawned）。”他认为唯一的用以修正的方法是对于结果进行的拉平的公正，然后这样就会有灾难了。然后罗尔斯对之做出回应，“自然的分配，是既公正又不公正的（The natural distribution is neither just nor unjust, nor is it unjust）。人在社会的某个阶层出身也并非是不公正的（that persons are born into society at some particular position）。这些都是很简单的自然现象的事实（These are simply natural facts）。是否公正，只是社会如何处理应对这些实际现象（What is just and unjust is the way that institutions deal with these facts）。”罗尔斯并未直接应对自我拥有论的观点。他在道义上的突出的论点基于差异原则的论点是，也许我们从根本上就不对自身完全拥有。</p><p>罗尔斯对于努力的回应，对于那些主张以努力作为道义缺失基础的观点，“那些努力工作来施展自身天赋的人们，对于他们基于自身天赋所付努力的成果是应得的。甚至是工作精神，甚至是愿意奋斗的意识，也是取决于各种家庭环境，社会以及文化各方面的不同偶然性所造成的，而且以上都不是我们的功劳。择优系统的辩护者认为努力是分配的道义基础，是贡献。但是贡献又直接把我们带回到了我们自然的天赋与能力方面，不仅仅是努力。我的天赋会在经济市场上收获什么。取决于社会上别人碰巧需要什么。其取决于供需关系法则。这不是我的功劳，所以这样显然不是道义缺失的基础。取决于某个社会碰巧认可的素质。我们应得的那些利益，基于自身天赋做出的努力所获得的成果。但不要错误与自负的说我们原本一开始就是应得的。”</p><hr><h3 id="第-9-课-讨论反歧视行动-目的是什么？"><a href="#第-9-课-讨论反歧视行动-目的是什么？" class="headerlink" title="第 9 课 讨论反歧视行动 / 目的是什么？"></a>第 9 课 讨论反歧视行动 / 目的是什么？</h3><h4 id="第-17-讲-讨论反歧视行动"><a href="#第-17-讲-讨论反歧视行动" class="headerlink" title="第 17 讲 讨论反歧视行动"></a>第 17 讲 讨论反歧视行动</h4><p>我们关心多样化，单一的学术优势从未成为哈佛大学录取学生的唯一标准。多样化意味着学生来自加州和纽约，以及马萨诸塞。城市居民，以及乡下男孩。小提琴手、画家和足球运动员。生物学家、历史学家和古典主义者。现在唯一的差别，哈佛认为是我们在这个长长的多样化参考清单中，又加入了种族和民族项目。当审查大量有能力在我们课堂上干的很出色的候选人时，哈佛写道，人种或许被作为一种额外因素考虑，就像你来自衣阿华，或你能成为一名优秀的中后卫或钢琴家。一个来自爱达荷州的乡下男孩，可能为哈佛大学带来一个波士顿人无法提供的东西。同样，黑人也可以带来白人无法带来的东西。所有学生，想要经历优良的教育，部分有赖于这些不同。这些由学生本身带来的背景和视野的不同，这就是哈佛的观点（PS: 国内的大学都该好好学学）。</p><h4 id="第-18-讲-目的是什么？"><a href="#第-18-讲-目的是什么？" class="headerlink" title="第 18 讲 目的是什么？"></a>第 18 讲 目的是什么？</h4><p>对于亚里士多德来说，正义是给予人们应得的东西。正义与两个因素有关（Justice involves two factors）: 物和人（things and the persons）即得到分配物的人（to whom the things are assigned）。一般而言我们这样认为（In general we say）平等的人（that persons who are equal）就应当有平等的事物分配予他们（should have equal things assigned to them）。</p><p>亚里士多德认为，我们正在寻找的不是最好的完人，我们寻找的只是最好的乐师。为什么最好的笛子该给最好的笛手？亚里士多德不是功利主义者，他不会说，那种方式可以产生更好的音乐，而且每个人都可以享用它，对每个人都有好处。他的回答是，最好的笛子给最好的笛手，因为这就是笛子存在的目的。一次公平分配在于这次分配是何种目标。这种思想被称为泰洛逻辑道义推理（Teleological moral reasoning）。（PS: 即目的论）</p><hr><h3 id="第-10-课-好市民-自由与适应"><a href="#第-10-课-好市民-自由与适应" class="headerlink" title="第 10 课 好市民 / 自由与适应"></a>第 10 课 好市民 / 自由与适应</h3><h4 id="第-19-讲-好公民"><a href="#第-19-讲-好公民" class="headerlink" title="第 19 讲 好公民"></a>第 19 讲 好公民</h4><p>亚里士多德说，当我们思考伦理、正义和道德论点时，一般你很难不用到目的论。在《政治学》第三卷，他告诉我们，政治生活部仅仅是生活，也不只是经济交易，不仅仅是安全，而是实现美好生活。照亚里士多德所说，这就是政治生活的追求。</p><p>只有在政治生活中，我们才可以实际锻炼对语言的清晰的理解能力。亚里士多德认为，有了这种能力才能够研讨对与错，正义与不正义。他在《政治学》第一卷中写道，“孤立的人，不能分享到政治联合体的好处。或者那些不需要来分享的人，因为他已经做到了自给自足，这样的人，不是一头野兽就是一位神。”（PS: 人终归是群居动物，需要相互支持，相互交流和理解。）所以当我们锻炼自己的语言能力时，我们才能完全认清我们的本性，我们才能完全发挥我们的人类能力。这能力意味着，我们能和其他公民研讨善与恶，对和错，正义和不正义。</p><p>我们为什么不能从家庭中，学习好的道德，或从哲学课堂，或从一本书里，按那些原则，那些规则，那些箴言，而且照此生活呢？亚里士多德说，那种方法是学不到美德的。美德是我们只能通过实践才能获致的，是我们只能通过运用才能获致的。它是这样的事物，我们只能通过做才能学到。就像学习如何演奏一件乐器，你不能够只靠读一本书来学，你必须练习，而且必须聆听，其他有造诣的乐师的表演。</p><h4 id="第-20-讲-自由与适应"><a href="#第-20-讲-自由与适应" class="headerlink" title="第 20 讲 自由与适应"></a>第 20 讲 自由与适应</h4><p>康德和罗尔斯有一个观点，他们说，因为在一个多元社会中，人们在关于好的生活的本质上明显会出现分歧，我们不应该去试图将正义建立在任何特定的对上述问题的答案上。所以他们拒绝目的论。如果你把一种特定的善的概念，捆绑到正义上的话，如果你把正义视为，一个人和他或她的社会角色间，是恰当的话，你没有给自由留下空间。而想要自由就是要独立于任何特定的角色，或独立于传统，或独立于，可能是父母留下来的惯例，或独立于社会。</p><p>究竟是亚里士多德是正确的，还是康德和罗尔斯是正确的？我们需要详细研究，权利是否优先于善？这是第一个问题，而且我们还需要详细研究，成为自由人，一个自由的道德主体意味着什么。难道自由会要求，作为一个选择主体的我，要去忍受自己趋向于，我的角色、我的最终目标和我的目的吗？</p><hr><h3 id="第-11-课-社会的需求-我们的忠诚在哪里"><a href="#第-11-课-社会的需求-我们的忠诚在哪里" class="headerlink" title="第 11 课 社会的需求 / 我们的忠诚在哪里"></a>第 11 课 社会的需求 / 我们的忠诚在哪里</h3><h4 id="第-21-讲-社会的需求"><a href="#第-21-讲-社会的需求" class="headerlink" title="第 21 讲 社会的需求"></a>第 21 讲 社会的需求</h4><p>康德认为宪法和法律不应当隐含、支持或者推崇任何一种特定的生活方式。那和自由不相容。法律的目的、宪法的意义并不是引导或者推崇美德。而是建立一种公平的权利框架。在此框架下，公民可以自由地追随他们自己对于美好生活的观念。</p><p>康德认为自由是自主行动的能力。自由意味着按照我自己设定的律令行动。自由即自律。人作为自由和独立的自我，能够选择他或她自己的目标。这一自我的形象是自由独立的，它提供了一个强有力的不受任何束缚的形象。因为它认为作为自由的道德主体，我们不被任何并非自己选择的历史纽带或者传统或者承袭下来的情况所束缚。因此我们在选择之前不受任何道德纽带的束缚。而这意味着我们是自由独立的、自主的主体。那些约束我们的规定是由我们自己制订的。</p><p>和康德的观点不同，对于自我概念，麦金泰尔（Alasdair Chalmers MacIntyre）认为人类本质上是一种讲故事的生物。这就意味着我只有先回答了我身在其中的某个故事或者多个故事是什么样的，才能回答我应当做什么这个问题。这就是他所讲的叙事式自我概念。一旦你接受了道德反思中叙事性的一面，你就会注意到我们绝不会仅仅作为个人来追求有用的物品或者有德性的行为。我们都会把自己的境遇视作某种特定社会身份所必须承受的结果。我是某个人的儿子或女儿，是这个或者那个城市的居民，我属于这个宗族，那个部族，这个民族。因此麦金泰尔认为那些对我而言是好的事物，就意味着对扮演这些角色的某个人是好的。我从我的家族、城市、部族、民族的过去继承下来了各种各样的债务、遗产、期望和责任。这些构成了我生活的前提，我的道德初始点。这在某种程度上赋予我的生活以道德独特性。</p><h4 id="第-22-讲-我们的忠诚在哪里"><a href="#第-22-讲-我们的忠诚在哪里" class="headerlink" title="第 22 讲 我们的忠诚在哪里"></a>第 22 讲 我们的忠诚在哪里</h4><p>如果义务源于共同体成员资格和身份，而这样的身份是属于多种共同体的，那么意味着我们的义务有时候互相冲突。</p><p>迈克尔·沃尔泽（Michael Walzer）是这样批评共同体主义者的，“正义与社会目的有关。一个特定社会是公正的，假如它的人们，真的生活在一条特定道路上的话，是在一条忠实于社会成员的共识的道路上的话。”如果我们不能找到正义的独立原则，独立于，任何特定共同体中流行的何谓好的观念，那么我们就会简单地，把公平当成是一种信仰或者忠诚，当成共识、价值、习俗，当成特定社会特定时间里的流行之物。</p><hr><h3 id="第-12-课-辩论同性婚姻-美好生活"><a href="#第-12-课-辩论同性婚姻-美好生活" class="headerlink" title="第 12 课 辩论同性婚姻 / 美好生活"></a>第 12 课 辩论同性婚姻 / 美好生活</h3><h4 id="第-23-讲-辩论同性婚姻"><a href="#第-23-讲-辩论同性婚姻" class="headerlink" title="第 23 讲 辩论同性婚姻"></a>第 23 讲 辩论同性婚姻</h4><p>如果我们来执行忠诚那肯定会有主从关系，越来越多的特殊性，那么我们肯定会对朋友和陌生人进行区别对待。孟德斯鸠对此有不同的观点: “一个真正有美德的人去帮助一个安全陌生的人，会像帮助他自己最亲近的朋友。如果一个有完美品德的人是没有朋友的。”（PS: 或者说是所有的人都是朋友，比如龙珠中的悟空就和这个形象非常接近。）</p><p>这是一个很难想象的世界，以至于一个完美品德的人是没有朋友的，是一种普遍性的友情输出。这个问题不简单，如果真有这么一个世界，是极其难实现的，而且是不现实的。对于这样一个世界会有更深层次的问题，这很难被认作是一个人类世界。人性中的爱是高尚的情操，我们大多数时间生活在较小的团体中。这将直接限制了道德同情的边界，但更重要的是这反映出现实，我们不是在一般情况下学习到爱与人性的，这是通过一种特殊的表达。</p><h4 id="第-24-讲-美好生活"><a href="#第-24-讲-美好生活" class="headerlink" title="第 24 讲 美好生活"></a>第 24 讲 美好生活</h4><p>对于同性婚姻，有一种观点认为，我们不应该为这个问题做决定，至少是国家不应该，法律不应该，在什么是“好”的婚姻上做决定。我们生活在一个多元社会，我们有着不同的道德和宗教信仰。我们制定法律的时候，应该在不同的道德观和宗教价值之间保持中立。</p><p>对于面对婚姻政府需要保持中立的观点，有观点认为政府应该不去插手婚姻，让人们自由选择他们庆祝结合的仪式，决定他们是否已经结婚。如果三个人想要结婚，如果一个人想要跟自己结婚，随他们去好了，如果其他人和政府都没有牵连进去，还需要操心什么？（PS: 不支持，不反对。清官难断家务事，随他们去吧。）</p><p>面对要求政府退出婚姻的观点，马歇尔法官写道，“在每一桩婚姻中都有三个参与者，一对配偶和对此结合加以肯定的国家。婚姻既是一个个人的深度承诺，也是公众对成熟、伙伴关系、亲密、忠实和家庭的一种崇敬方式。”这个观点就超出了上述自由派的两个不同的观点所涵盖的范围。这种意见将婚姻看做是一种崇敬方式，看做是一种社会认可的形式。对于婚姻的首要目的是为了繁衍，马歇尔法官认为这不对。她指出，一对异性恋男女来拿结婚证书的时候，国家没有要求他们证明自己有能力或有意愿抚养小孩。生孩子并不是婚姻的前提条件。有些人就快要死了，还结婚来着。她认为，“繁衍不是婚姻的目的，排他性、永久性的伙伴关系才是婚姻的本质和目的。”</p><p>正义的概念并不难从不言而喻的前提中推导出来。要证明它，需要多种考虑的相互支持，将所有的事情都汇聚成一个连贯一致的观点。道德哲学是苏格拉底式的，一旦我们得出一种新的原则，我们就可能想要改变我们现有的判断。有一种观点认为，尊重其他公民的道德和宗教信仰，就意味着装作没看到它们。其实不然，要做到尊重其他公民的道德和宗教信仰，还有另外一种方法，不是漠视它们，而是与之交流。予以关注。有的时候还需要与之争论。有时则需要聆听和学习。这么做的话，并不保证道德上、宗教上的相互接触在任何情况下一定会导致和谐。也不保证这么做了之后，我们就会欣赏其他人的道德和宗教信仰。毕竟，总是由可能发生这种事情，那就是对一种宗教和道德观点了解的越多，我们就越不喜欢它。但是由这种商议、交流带来的尊重，对一个多元社会来说，比起相互漠视来说，更为合适。</p><p>我们在道德和宗教意见上发生的分歧在某种程度上反映了人类品质上存在着一些根本的差异，即存在着不同的“善”。道德上互相交流会使我们去欣赏由我们的不同人生所展现出来的不同的品质。我们为什么还要继续进行这些争论，即使它们引发的问题不大可能得到最终解决？理由是，我们一直都生活在对这些问题的答案中。在我们的公共生活中，在我们的私人生活中，即使有时候看起来荒谬，我们都无法回避哲学问题。</p>]]></content>
      
      
      <categories>
          
          <category> 公开课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>斯坦福-编程方法</title>
      <link href="/si-tan-fu-bian-cheng-fang-fa/"/>
      <url>/si-tan-fu-bian-cheng-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>课程介绍: </p><p>「编程方法」本课程是最大的编程入门课程，也是斯坦福大学主要课程之一。介绍了当代程序设计基本思想: 面向对象，模块化，封装，抽象化与测试。《编程方法》将良好的编程思想连同广泛应用的Java语言一同讲授。着重教授良好的编程风格和Java语言的特色。这门同样课适合文科，主修社会科学的同学和编程爱好者学习观看。其实每年都有很多非工程系同学选修这门课。</p><p>基本要求: 本课程不要求具备编程基础，但要求多下功夫！</p><p>课程类型: 计算机</p><p>课程主讲人: Mehran Sahami教授</p><p>Mehran Sahami刚加入斯坦福大学计算机系时任副教授，本科教育附主任和教务处主任三职。2001年至2006年，任斯坦福大学计算机系讲师。2002至 2007年，任谷歌公司的高级研究员，目前依然是研究团队的顾问。Mehran Sahami的研究方向主要有计算机科学教育，机器学习和网络信息挖掘。 在此之前，Mehran Sahami是Epiphany公司的高级工程经理。去Epiphany工作前，他在斯坦福大学的计算机系拿到了博士学位。他曾今也是斯坦福大学的本科 生，一直深爱着这方土地，至今不愿离去。工作之余，喜欢跟家人团聚，喜欢弹吉他，喜欢户外旅行，还喜欢睡觉（虽然最近睡的越来越少）。</p><p>课程简介: </p><p>第 1 课 课程简介</p><p>欢迎来到CS106A，授课人员，为什么称之为编程方法？，你真的适合学习这门课程吗？课程常规，作业与评分，课外拓展，期中期末考试，成绩评定细则，行为准则，为何要从Karel学起？</p><p>第 2 课 欢迎来到 Karel 的世界</p><p>讲义相关，注册讨论小组，Karel基本命令，算法与程序孰轻孰重，Karel程序语法，运行一个Karel程序，创建函数的方法，超级Karel，For循环，While循环，Karel条件语句，If条件语句，综述。</p><p>第 3 课 Karel 与 Java</p><p>Karel 与Java，常见的错误，注释，前提条件和后续条件，分解，例程序DoubleBeeper，养成良好编程习惯重要性，正确的分解，例程序CleanUpKarel。</p><p>第 4 课 计算科学发展史</p><p>计算机科学与程序设计的千丝万缕，电脑懂什么，编译过程，Java-面向对象的程序设计语言，继承，类，acm.program层次结构，第一个Java程序，例程序ConsoleProgram，图形化界面，例程序Sending-Messages-to-a-GLabel。</p><p>第 5 课 变量</p><p>变量的数据类型，调用变量相关语法，类的类型，对象变量，调用类成员函数的方法，图形坐标，对类GObject以及其子类的操作，描画几何对象，例程序FunGraphics，表达式与操作符。</p><p>第 6 课 操作符</p><p>readInt() 和 readDouble()函数，整形与浮点数的除法运算操作符，操作符优先级，类型转换，常量，布尔数据类型，值的比较，布尔表达式，短路求值，语句块，变量的作用域，if套嵌，switch语句，for循环语句，while循环语句。</p><p>第 7 课 循环与“一半”问题</p><p>For循环与While循环的对比，例程序CheckerBoad，在Java中创建函数，创建函数举例，FactorialExample程序，用函数返回对象。</p><p>第 8 课 信息隐藏</p><p>Void函数类型，在函数间传递参数，函数的缺陷，类的使用，整体变量与局部变量，例程序RandomGenerator，例程序RollDice，setseed()函数。</p><p>第 9 课 字符串</p><p>写一个类，公有和私有的区别，构造函数，this关键词，类的使用，对象的调用需要使用引用方式，将类作为变量，Javadoc技术，例程序Student。</p><p>第 10 课 私有变量的重要性</p><p>扩展Student类，函数重写，acm.graphics程序包，GCanvas，GObjects中的常用函数，其中的接口与函数，BouncingBall例程序，GLable类中的几何学，GArc类。</p><p>第 11 课 Gimage类</p><p>GPolygon类，GCompound类，事件驱动程序，例程序ClickForFace，响应鼠标操作，响应键盘操作，例程序UFO。</p><p>第 12 课 枚举</p><p>字符，Unicode标准下的ASCII码，字符的读取，字符中的数学，基本类型char，字符对象，字符串及其操作。</p><p>第 13 课 对字符串的处理</p><p>编译器，加密。</p><p>第 14 课 内存</p><p>存放不同变量的内存区块，内存分配机制，对指针的看法，指针趣味小视频。</p><p>第 15 课 指针要点回顾</p><p>为什么要通过引用方式调用类，将封装类作为基本数据类型，文件，打开、读取、关闭文件的函数，异常状况，文件写操作函数。</p><p>第 16 课 数组</p><p>创建数组，++操作符，数组的真实长度与有效长度，将数组作为参数，初始化数组，数组列表。</p><p>第 17 课 多维数组</p><p>类模版，ArrayList类中的函数，使用ArrayList类的例程序，Glable数组列表例程序，例程序GrayImage。</p><p>第 18 课 多维数组收尾</p><p>数组列表方式，数组列表与数组的优劣分析，调试，程序调试的方法，Eclipse中的调试器。</p><p>第 19 课 接口</p><p>如何使用接口，映射，HashMap类，HashMap中的函数，中继器，HashMap例程序。</p><p>第 20 课 图形用户界面</p><p>Java程序中的Interactor，Swing Interactor层次结构，窗口区域，创建Interactor，例程序，探索更多Interactor，例程序InteractorDrawFace。</p><p>第 21 课 Interactor与Listener回顾</p><p>例程序，例程序中应用的两种方法——使用getSouce或getActionCommand函数，例程序TextField，布局设计，温度换算例程序，例程序TextAndGraphics。</p><p>第 22 课 NameSurfer概述</p><p>组件与容器，容器的监听器，设计可扩展程序，ComponentListener接口，例程序MusicShop，例程序MusicShopDisplay。</p><p>第 23 课 搜索，排序与算法效率分析</p><p>课程材料介绍——搜索，排序及其算法效率分析，搜索，线性搜索，线性搜索的效率分析，二分法搜索，二分法搜索的效率分析，排序，选择排序算法，选择排序效率分析，基数排序算法。</p><p>第 24 课 管理大型数据中的良好软件工程原理</p><p>设计思想，数据搜集层次结构，数据搜集实用函数，例程序: 在线音乐商店FlyTunes,定义歌曲类，定义专辑类，鉴证程序运行，对所需数据结构的思考，数据的重复利用，浅拷贝与深拷贝。</p><p>第 25 课 设计实用社交网络</p><p>思考程序所需功能，分离现象的六种程度，并行性，一个线程，运行接口，创建一个线程，例程序，在线程间共享数据。</p><p>第 26 课 介绍Java标准库</p><p>JAR文件介绍，创建JAR文件，创建applet小程序，脱离ACM运行库创建标准Java程序，其他——深入学习Java。</p><p>第 27 课 CS106A后续课程介绍</p><p>计算机专业简介，其他专业出路。</p><p>第 28 课 宣布图形比赛结果</p><p>期末复习，例题1，例题2，课程总结。</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="第-1-课-课程简介"><a href="#第-1-课-课程简介" class="headerlink" title="第 1 课 课程简介"></a>第 1 课 课程简介</h3><p>为什么这门课叫《编程方法》，为什么不叫做《Java程序设计》？原因在于《编程方法》教授的是良好的软件工程思想，这比单纯的编程范围大得多。有些人找一本教科书，觉得看看书就能学会如何编程。其实，学会的可能只是语言结构，但只是学会语言结构远远不够。学习软件系统，开发中实用的软件工程思想才是重中之重，这正是本门课程要教授的内容。</p><p>想做编程高手，也需要掌握一种语言，无论是 Java，C，还是 C++ 等。但如果只懂得语言，并不能成为优秀的软件工程师，也不会清楚编写好软件需要的思想。除了教授语言之外本门课程将着重讲解良好的编程思想，这才是重中之重。一些坏习惯比零基础更坏。</p><p>课程网站: <a href="www.stanford.edu/class/cs106a">www.stanford.edu/class/cs106a</a></p><p>教科书: </p><ul><li>课程导论: 《卡雷尔机器人学Java》Karel the Robot Learns Java</li><li>课本: 《Java语言的科学与艺术》The Art and Science of Java</li></ul><p>很多学习计算机的同学会走入误区，仅仅学习语言本身特性，认为只要学好了语言，就能成为一个好的软件工程师。他们过于关注语言本身细节，对程序设计却没有宏观把握。写一个好程序或者学习如何编程跟学习成为作家差不多。关键在于光靠套公式，套模板是写不出好文章的。</p><p>瑞奇·帕提斯（Rich Pattis）提出教授计算机科学入门课程，先把各种语言的繁杂指令和各种语言的差异放一边，从最简单的教起。以便能更快的学习各种指令，这样就具备了掌握程序设计语言的基本素养，可以把主要精力放在软件工程思想方面。</p><hr><h3 id="第-2-课-欢迎来到-Karel-的世界"><a href="#第-2-课-欢迎来到-Karel-的世界" class="headerlink" title="第 2 课 欢迎来到 Karel 的世界"></a>第 2 课 欢迎来到 Karel 的世界</h3><p>解决问题的方法不止一个，我们只需要选择其中一个，这就是编程的艺术。</p><p>算法和程序二者的区别在于，算法是做事情的步骤，将程序不断分解，分成很多小步骤，逐步求精。程序则必须按照语言规则合法的组织语句。</p><p>编程时重要的一点是，不仅仅要写出计算机能读懂的程序，更要让人读得懂。这是编程风格的重要体现，也是好软件的必备条件。一个虽然能正常运行，但其他人读不懂的程序，是非常糟糕的软件工程产品。让人能读得懂这是软件工程的重要原则。</p><p>考虑程序的通用性，这点非常重要。你不会只想让程序，在一种情况下正确运行吧。除非是明确指出只需在某种情况下运行。你得使程序通用化，根据通用原则来设计，使其在满足基本规则的情况下都能正确运行。</p><hr><h3 id="第-3-课-Karel-与-Java"><a href="#第-3-课-Karel-与-Java" class="headerlink" title="第 3 课 Karel 与 Java"></a>第 3 课 Karel 与 Java</h3><p>常见错误: </p><ul><li>无限循环，即为一个无限的循环。程序的语法是正确有效的，但是程序却没有按照我们所设计的去做。这是在编程时，经常遇到的问题，不同于语法问题。</li><li>差一错误（off by one bug）简称OBOB，意思是你还差一件需要做的事情。尽管按逻辑来讲也不需要做，所以理解OBOB最好的方法是用一个具体的例子来说明。如果你要建造一个100米长的栅栏，其栅栏柱间隔为10米，那么你需要多少根栅栏柱呢？11根或9根都是正确答案，这取决于是否要在栅栏的两端树立栅栏柱，但是10根却是错误的。转换到数学，数字1到数字5一共有几个数字？这里有一个公式 从M到N，一共有 M-N+1 项.</li></ul><p>软件工程中一个重要的原则是，所写的程序不仅要机器明白，人也要能够理解。注释就能使人在读程序时能够阅读并能理解。很明显的问题，需要添加注释，说明程序中不明确的地方。另外，是程序的前提与后置条件。写明前提和后置条件可以让程序员在不知道程序内部具体的运行方式时，可以理解程序要做什么。如果所写的程序很短，哪怕只有一行，也最好加上注释，因为这可以帮助我们。</p><p>把程序具体化，这个过程称之为分解。我们从一个高阶层的描述开始，然后逐步分解，至每一小步，一直分解下去，直到步骤足够清晰明了，将步骤分解到计算机可以理解为止。我们做到了原语（primitives）这个层次时，这个分解过程就结束了，这个过程叫做逐步求精法（stepwise refinement）。</p><p>分解的概念是把事物分成更小的片段，分解成更具体的部分，分解直至原语这个层面。这整个过程称之为自顶向下设计（top-down design）。这与另一个概念相对，就是自底向上设计（bottom-up design）。自底向上设计是指，从原语开始，从低阶层开始。大部分程序员，最开始都是用这种方式。有一个心理研究表明，平均要拥有100小时的编程能力（programming proficiency）才能从自底向上的思维转变为自顶向下的思维。</p><p>分解方法（decomposition methods）: </p><ul><li>每个方法解决一个问题。</li><li>大部分方法应该在1-15行左右，如果是一行，没问题，可以写一行程序调用其他程序。这样做的目的在于可以使用新名称。</li><li>方法名应该能够描述它是做什么的，解决了什么问题。一个好的名字可以解释程序是做什么的.</li><li>方法涉及到分解的，都应该有注释，注释可以更加详细的解释这个方法是做什么的。更详细的说明，最好注明前置和后置条件。</li></ul><p>写编码的时候，你要考虑分解，用逐步求精法和加注释。对整个程序的注释以及对每个方法是注释。</p><hr><h3 id="第-4-课-计算科学发展史"><a href="#第-4-课-计算科学发展史" class="headerlink" title="第 4 课 计算科学发展史"></a>第 4 课 计算科学发展史</h3><p>了解它，学习它，运用它，爱上它（know it，learn it，live it，love it）</p><p>很多人都把计算机科学看做是编程。在编程中到底涉不涉及科学，这两者的不同之处在于，计算机科学简称为CS，是指的科学，也就是用计算机来解决问题。</p><p>计算（Computational），称之为方法（methods）。写的时候只考虑理论上是否可行，却不考虑在计算机硬件上能否操作，证明出那些函数是不可行的或可行的。科学在这里指的是解决问题和解决问题的方法，及分析那种是有效的方法，这个方法是否可以解决问题。</p><p>程序，它是指我们在想出某一解决问题的方法时，用计算机的编程方式来处理问题。它只是整个计算机科学其中的一个过程，而不是全部。有一个名言曾将程序对于计算机科学的意义比喻成望远镜对于天文学的意义。</p><hr><h3 id="第-5-课-变量"><a href="#第-5-课-变量" class="headerlink" title="第 5 课 变量"></a>第 5 课 变量</h3><p>准确的命名是一个良好的软件工程原则，考虑到名称的含义，就是要让名称具有描述性，不产生歧义。</p><p>变量这是一个内容可变的盒子，有三要素。其一，名称用来标识这个盒子。其二，类型指的是盒子里放的是什么东西。其三，值告诉我们盒子里的东西是什么。</p><p>一定要给每个变量赋一个初始值，这才是优秀的软件工程。</p><hr><h3 id="第-6-课-操作符"><a href="#第-6-课-操作符" class="headerlink" title="第 6 课 操作符"></a>第 6 课 操作符</h3><p>常量与变量的不同之处就是它不会改变。全部大写，这是写常量的传统方式，每个单词之间用下划线连接。</p><p>求余运算符只对整数适用，因为求余运算符对实数没有意义。</p><p>除法在整数和双精度上运算方法有点不同。当你在做除法时，如果两个参数均为整数，在这种情况下它会做整数除法，就是做除法后丢掉余数，所有你得到的依然是个整数。例如整数5除以整数2，你会得到结果为整数2，随之的余数1就丢掉了。要是其中有一个是实数的话，比如一个双精度实数，那么这里就会做实数除法并返回实数。所有对于这里的例子5除以2改成5除以2.0的话，结果就会得到2.5这个双精度实数而不是一个整数。</p><p>编写程序的时候如果不考虑清楚逻辑就会出现重大的BUG，而且很容易让人迷惑。</p><p>例: 不论x取任何值，P都为真，这是一个典型的漏洞。</p><pre class=" language-java"><code class="language-java">P <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>短路计算，在不同情况下他们很是有用的。例如避免除数为0的情况出现</p><p>例: 如果x等于0，直接判断为假，不用处理后面的语句。这样你就永远不会有除数为0的情况。</p><pre class=" language-java"><code class="language-java">P <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">/</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>switch条件必须是整数值，不可以是双精度类型。</p><hr><h3 id="第-7-课-循环与“一半”问题"><a href="#第-7-课-循环与“一半”问题" class="headerlink" title="第 7 课 循环与“一半”问题"></a>第 7 课 循环与“一半”问题</h3><p>当不知道具体的循环次数时，使用while循环。你会去计算某些事物的执行次数（for循环），或者会在条件为真时才做某事（while），这就是两种循环的区别。</p><p>哨兵值，我们将会用一个常量去判断用户什么时候想输入数据，什么时候停止输入数据，所以在编程中这个值常被称之为哨兵。</p><p>例: 从用户那读入一连串数字，直到用户输入0才停止读入，然后计算这些数字的和。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Add</span> <span class="token keyword">extends</span> <span class="token class-name">ConsoleProgram</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SENTINEL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哨兵</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入值总和</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token string">"Enter val:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入值</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>val <span class="token operator">!=</span> SENTINEL<span class="token punctuation">)</span><span class="token punctuation">{</span>      total <span class="token operator">+=</span> val<span class="token punctuation">;</span>      val <span class="token operator">=</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token string">"Enter val:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total = "</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>循环会判断如果你给的值不是哨兵值，就不会停止。</p><p>在计算机科学或者计算机编程中，我们很讨厌重复的代码。如果能够避免重复代码，即使只有一行我们都会尽力去消除。向用户询问数值的这个操作至少要执行一次，但是在第一场执行后，我们需要在循环里面重复这个操作，所以我们遇到了难题，如何避免重复的代码呢？</p><p>例: 从用户那读入一连串数字，直到用户输入0才停止读入，然后计算这些数字的和。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Add</span> <span class="token keyword">extends</span> <span class="token class-name">ConsoleProgram</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SENTINEL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哨兵</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入值总和</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token string">"Enter val:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入值</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> SENTINEL<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果输入值等于哨兵就跳出循环</span>      total <span class="token operator">+=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total = "</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>循环会判断循环条件永远为真，看起来很奇怪。你会担心它不是一个无限循环吗？只有一种情况会被终止，我们会向用户询问数值，判断这个值是否为哨兵值。如果是，跳出循环。</p><p>break语句的作用就是它会跳出围绕代码最里面的那层循环。实际上它的用途是在循环内部检查跳出循环的条件，而不是在开头或每次进入循环的时候检查。</p><p>从编程风格来说，一个循环体内有多重终止条件是非常糟糕的。因为这会让程序员很难识别哪个条件为真，才能跳出循环。</p><p>比起用一大堆if语句来判断，稍微运用数学则来得更高明。</p><p>例: 当i+y的值为偶数时执行，为奇数时不执行。</p><pre class=" language-java"><code class="language-java">sq<span class="token punctuation">.</span><span class="token function">setFilled</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>多数情况下，return会出现在方法的结尾。但它并不只会出现在结尾，运行return时，正在执行的方法会马上停止，并且返回语句中的值或对象。</p><p>例: 比较2个数字的大小，并且返回比较大的那个数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">></span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3 id="第-8-课-信息隐藏"><a href="#第-8-课-信息隐藏" class="headerlink" title="第 8 课 信息隐藏"></a>第 8 课 信息隐藏</h3><p>信息隐藏，指方法的使用者不需要去关心方法内部结构，懂用就好。当在编写方法时，你应该考虑让一个方法解决一个问题，一个具有普遍意义的问题，而信息隐藏于用户。当用户调用方法时，只要程序注释里清楚解释了程序的用途，列明了参数。用户就可以不需要去看方法的内部结构，不必知道原理，也能知道如何使用此方法。如果你找到一个更加有效的方法来实现这个功能，只需要修改方法的内部结构，而用户则不必在乎方法的改变。</p><p>函数返回值，有时（当返回值为void）函数或方法不一定返回值，也不需要返回值。</p><p>传递参数时，实质上是在传递拷贝，并不是传递变量本身。</p><p>例: x输出值为3，AddFive方法只修改了x的拷贝，变量x的值并没有改变。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">AddFive</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    x <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改的是x的拷贝  </span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token function">AddFive</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>例: x输出值为8，AddFive方法修改了x的拷贝，然后将拷贝修改后的值返回，最后将返回的拷贝x的值赋值给变量x。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">AddFive</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    x <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改的是x的拷贝  </span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回拷贝修改后的值  </span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> <span class="token function">AddFive</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将返回的拷贝x的值赋值给变量x  </span>  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>当调用类的时候，分别有类的客户（client）和类的实现者（implementor）这两个概念。类的客户指类的使用者，当你调用ACM库里面的类使用时，你就是客户。而当你自己编写类，设定类的用途，那你就是实现者。</p><p>如果希望某个对象或变量，都能被整个类中的所有方法共有，就要用到实例变量（instance variable）。实例变量我们简称为ivar，它是一个存在于整个对象中的变量，而令所有方法都能指向这个变量。</p><p>实例变量在类中声明，对类里所有的东西都可见，所有方法都能访问。只要对象存在，实例变量就存在。常量实际上是实例变量的一种，它们是final的实例变量，也就是说它们不会改变。</p><p>局部变量（locals）在方法中声明，只在方法中可视。当方法结束，局部变量也随之结束。</p><p>当你要做的计算只在你使用的方法里有效时（即局部计算）使用局部变量，实例变量是在方法的调用之间存储某些值时使用，你可以把它看成是对象的状态。</p><hr><h3 id="第-9-课-字符串"><a href="#第-9-课-字符串" class="headerlink" title="第 9 课 字符串"></a>第 9 课 字符串</h3><p>字符串（String）是一种类型，意思是字符的有序结合，字符串实际上是一个文本。</p><p>类不具体定义父类，结果就是默认继承类object。</p><p>包的意思是指类的集合，具有相关性类的集合。</p><p>构造函数</p><ul><li>构造函数的名称与类的名称相同。</li><li>构造函数没有返回类型。</li><li>构造函数负责给予我们对象中的初始值。</li><li>构造函数在对象创建的时候被调用</li></ul><p>保持参数的名称不同于局部变量的名称，区分名称的不同。这样就不会产生混淆，这也是一个很好的编程习惯。</p><p>思考在计算机科学中很重要，重要的是要具备一个全局观，不需要过多担心细节。</p><p>当传递对象时，传递的不是对象的拷贝。传递的是对象的引用（reference），可以看做是传递对象本身。我们把它称为引用，实际上是一种指向对象的方式。虽然传递对象时，只是传递引用的拷贝，但是它们指向的是同一个对象。</p><p>类变量（class variable）被所有对象共有，是一个被类中所有对象共有的变量，而实例变量则属于对象私有，每个对象变量都是独有的。例如，圆形的半径都是每个圆形独有的，但是π是所有圆形共有的。类变量也称作静态变量（static variable），它不一定是常量，也不一定是最终值。</p><p>javadoc是java的文件材料系统（documentation system）。在注释中需要加上一个特殊标记使得javadoc系统理解。这个系统可以通过注释解释你的代码内容，同时生成html页面。这样别人在试图理解你的代码内容时，可以通过阅读这个html，而不需要通读你所写的代码。</p><p><a href="http://jtf.acm.org/javadoc/student" target="_blank" rel="noopener">Java的acm库Javadoc学生版本</a></p><hr><h3 id="第-10-课-私有变量的重要性"><a href="#第-10-课-私有变量的重要性" class="headerlink" title="第 10 课 私有变量的重要性"></a>第 10 课 私有变量的重要性</h3><p>重写的意思是指子类覆盖父类的方法。方法的名字必须相同，参数也需要完全一样。</p><p>编写代码需要尝试去做，可以阅读教材，但是真正动手实验才是王道。</p><hr><h3 id="第-11-课-Gimage类"><a href="#第-11-课-Gimage类" class="headerlink" title="第 11 课 Gimage类"></a>第 11 课 Gimage类</h3><p>修改很少的代码就能实现新的功能，这就是面向对象程序的美好之处。</p><p>事件驱动（event-driven）。程序可以检测到某些正在发生的事件，并对它们做出反应。在计算机中监听器（listener）有两种，鼠标监听器和键盘监听器，也就是从鼠标中得到是事件以及从键盘中得到的事件。</p><hr><h3 id="第-12-课-枚举"><a href="#第-12-课-枚举" class="headerlink" title="第 12 课 枚举"></a>第 12 课 枚举</h3><p>枚举是个基本的概念，把它想成一系列相关的项目。通常我们给出一些数字，这样我们就可以追踪它们了。</p><p>Java中重要的是要要记住字符串是无法改变的。当我们对字符串修改时，实际上是创建了一个新的字符串，也就是对之前的字符串的更改版本。</p><hr><h3 id="第-13-课-对字符串的处理"><a href="#第-13-课-对字符串的处理" class="headerlink" title="第 13 课 对字符串的处理"></a>第 13 课 对字符串的处理</h3><p>编译器（tokenizer）是个计算机术语。比如有一个字符串文本，我们像把它们分解成片段，这就叫做编译器。</p><p>加密（encryption）实际上就是传递秘密的信息。</p><hr><h3 id="第-14-课-内存"><a href="#第-14-课-内存" class="headerlink" title="第 14 课 内存"></a>第 14 课 内存</h3><p>说到存储，首先要知道的是RAM内存，全程是随机存取存储器（random access memory）。</p><p>计算机里最简单的存储单位叫做比特，而比特（bit）其实是二进制数字（binary digit）的缩写。比特只包含0或者1这种单一的二进制数字。</p><p>计算机存储是从十六进制出发的，尽管能换算成十进制数值，但是我们还是用十六进制表示。之所以这么做，是因为我们想要区分表示存储位置的数和存储的实际内容。</p><p>凡是使用new的就是动态变量，当调用new的时候，动态变量就存储在叫做堆（heap）里面。堆中的变量不再使用时，计算机把这部分内存收回，这叫做垃圾回收（garbage collection）。</p><p>局部变量存放在一个叫栈（stack）的地方，跟堆区分开来。栈和堆的区别就在于，对栈来说，当函数中有局部变量或者参数时，在栈这个地方会自动为变量分配一些内存。当局部变量不在作用域范围内时，像是函数结束或者是运行的程序退出，导致变量不在存在，不在作用域范围内，栈会自动回收内存（java是这样的，c和c++不会自动回收）。</p><p>每个对象都有地址，计算机内部实际上是通过对象的地址来找到它们的。</p><p>栈上创建了一些存储空间，称之为栈帧（stack frame）。它在栈上记录调用函数，产生帧信息。</p><p>在对某个对象调用函数时，首先存在栈上的是对象的指针（pointer），它就是叫做this的指针。</p><p>函数运行结束，就意味执行函数时，所分配的所有内存，被计算机自动取消分配，称之为出栈（off stack）。</p><hr><h3 id="第-15-课-指针要点回顾"><a href="#第-15-课-指针要点回顾" class="headerlink" title="第 15 课 指针要点回顾"></a>第 15 课 指针要点回顾</h3><p>设两个对象相等，它们就是两个相同的对象，内存中只有其中一个对象被存储，但有两个指针或者两个指向它的指针，一般称之为指针引用。</p><p>解引用（dereference）的意思是不存在值或者随机值，指向内存某处，产生空指针错误（值为null）。</p><p>当把基本类型作为参数传递，得到的是一个基本类型的值的拷贝。当参数是对象时，实际上是在传递对象，或者说是拷贝对对象的引用。</p><p>当一个异常被引发，必然要有捕获异常。如果没有捕获异常，程序将会出错从而停止执行。try只需要包含会出现异常的代码，不要将所有代码包含在try中。</p><hr><h3 id="第-16-课-数组"><a href="#第-16-课-数组" class="headerlink" title="第 16 课 数组"></a>第 16 课 数组</h3><p>数组是一次记录大量信息的一种方法。数组的两个核心概念是: </p><ol><li>数组是有顺序（ordered）的，意思是能基于这些循序利用索引来指向数组中的元素。</li><li>类别统一（homogeneous），存储在数组中的内容都属于一个类型，而且必须是同种类型，所以说它型别统一。</li></ol><p>数组的尺寸分为实际尺寸以及有效尺寸。实际尺寸是指声明的数组尺寸，而有效尺寸是指在程序中真正使用到的尺寸。</p><p>传递数组时，数组是通过引用来传递，得到的是实际数组。用引用而不使用拷贝，这样做是出于效率原因。传递数组的单个元素，如果它们属于基本类型，那么就算它们都是数组中的元素，得到的仍然是拷贝。如果要得到引用，必须先传递整个数组。</p><p>数组表被称为template，它可以自动的增加数组的长度。</p><hr><h3 id="第-17-课-多维数组"><a href="#第-17-课-多维数组" class="headerlink" title="第 17 课 多维数组"></a>第 17 课 多维数组</h3><p>数组表，它是一个对象，它和数组很相似，但它能根据添加元素的方式改变它的尺寸。数组表作为模板，它的类型只能是对象，所以不能有基本类型的数组表。</p><p>对于基本类型，有一个等价的类型，叫做包装类（也叫封装类wrapper class），这些类是不可变对象。数组表要想使用基本类型必须使用包装类。</p><hr><h3 id="第-18-课-多维数组收尾"><a href="#第-18-课-多维数组收尾" class="headerlink" title="第 18 课 多维数组收尾"></a>第 18 课 多维数组收尾</h3><p>多维数组是由数组构成的数组，例如二维数组是数组构成的数组，三维数组是由二维数组构成的数组。</p><p>数组表最大的优点就是动态改变尺寸，如果事先不知道尺寸，就用数组表。另一个优点是，它有相当多的高级方法。缺点是效率低于数组，另一个缺点是它的语法复杂。如果事先知道数组的尺寸，它的尺寸是固定不变的，那就一定要用数组。</p><p>坏值（bad variable），在程序某种有个值，这个值不是你所要求的值。错误逻辑（faulty logic），你本想计算机操作x，但程序却让计算机操作y。这并不是所谓的电脑故障，它所做的一切都是你指示的，只是你并没有给出正确的指示。无根据的假设（unwarranted assumption），我以为值的单位是米，火箭升空前你咋不告诉我是英尺。认真考虑你的假设是什么，当方法被调用，它可以假设什么。这些大体就是调试的本质问题。</p><p>人们总有一种简单问题复杂化的倾向，很多问题本来就是简单的，所以不要认为漏洞的出现必然是一个复杂问题。有时仅仅是因为错误逻辑，或者是不小心改变了某个值，总之就是无心之举。</p><p>调试的几个基本原则: </p><ul><li>要有条理。</li><li>不要依靠直觉自以为自己知道问题在哪。</li><li>严格看待自己的代码。</li><li>相信自己，冷静，慌张于事无补。</li></ul><hr><h3 id="第-19-课-接口"><a href="#第-19-课-接口" class="headerlink" title="第 19 课 接口"></a>第 19 课 接口</h3><p>接口（interface）它就是一套方法，和某些类共用的一套方法，所以它是一套通用的功能，某些特定类中的通用功能。</p><p>迭代器（iterator）它能把一系列值罗列出来，直到数组结束。</p><hr><h3 id="第-20-课-图形用户界面"><a href="#第-20-课-图形用户界面" class="headerlink" title="第 20 课 图形用户界面"></a>第 20 课 图形用户界面</h3><p>GUI指的是图形用户界面。</p><hr><h3 id="第-21-课-Interactor与Listener回顾"><a href="#第-21-课-Interactor与Listener回顾" class="headerlink" title="第 21 课 Interactor与Listener回顾"></a>第 21 课 Interactor与Listener回顾</h3><p>不要忘记在最后添加监听器。</p><hr><h3 id="第-22-课-NameSurfer概述"><a href="#第-22-课-NameSurfer概述" class="headerlink" title="第 22 课 NameSurfer概述"></a>第 22 课 NameSurfer概述</h3><p>无</p><hr><h3 id="第-23-课-搜索，排序与算法效率分析"><a href="#第-23-课-搜索，排序与算法效率分析" class="headerlink" title="第 23 课 搜索，排序与算法效率分析"></a>第 23 课 搜索，排序与算法效率分析</h3><p>一系列信息需要查找，最简单的方法是全部看一遍，这称为线性查找。该方法查找元素所需要的运算次数和元素的个数是成线性比例的。缺点是相当的耗时。</p><p>二分查找，在每个节点都一分为二。</p><p>两个int类型加起来再除以2会产生BUG，int类型最大值大约是40亿，如果两个int的和大于最大值就会产生BUG，所以应该先分别除以2后再相加。</p><hr><h3 id="第-24-课-管理大型数据中的良好软件工程原理"><a href="#第-24-课-管理大型数据中的良好软件工程原理" class="headerlink" title="第 24 课 管理大型数据中的良好软件工程原理"></a>第 24 课 管理大型数据中的良好软件工程原理</h3><p>很多企业成功的原因，就是出色的数据管理。</p><p>你要找出你的应用所在领域的相关名词，很多时候这个名词就是你的类。除了名词，我们还需要找到动词。动词代表着与类相关的方法，某个名词有某个动作，即动词，相当于某个类调用了某个方法。</p><p>唯一标识符，它指的是某条数据的唯一的标识符，它具有唯一性和不可改变性。</p><hr><h3 id="第-25-课-设计实用社交网络"><a href="#第-25-课-设计实用社交网络" class="headerlink" title="第 25 课 设计实用社交网络"></a>第 25 课 设计实用社交网络</h3><p>社交网络基本上就是记录一些人或者个人账户以及他们之间的关系的一种方式，这是最通俗的解释。</p><p>多线程其实是控制器不断的在不同的线程中快速切换。</p><hr><h3 id="第-26-课-介绍Java标准库"><a href="#第-26-课-介绍Java标准库" class="headerlink" title="第 26 课 介绍Java标准库"></a>第 26 课 介绍Java标准库</h3><p>main方法是java类中开始运行的地方。</p><p>jar文件的含义是Java ARchive。它可以包含许多不同的东西（实际上是类似zip的压缩包），大多数时候我们用它来打包java中那些已经编译的类，即“.class”文件。</p><hr><h3 id="第-27-课-CS106A后续课程介绍"><a href="#第-27-课-CS106A后续课程介绍" class="headerlink" title="第 27 课 CS106A后续课程介绍"></a>第 27 课 CS106A后续课程介绍</h3><p>抽象编程，由C++语言讲述。我们一直都在使用一些抽象概念，比如数组表和哈希图等。在这门课中，你需要思考如何实现一个哈希图或数组表、如何让程序运行得更快而尽可能少占用内存、以及更多的编程技巧比如递归。</p><p>离散数学，讲述计算机中的逻辑。图形、社交网络和六度分离等，它们都是离散数学的一部分。</p><p>人工智能，简称AI。它包含很多分支领域，比如机器人技术、计算生物学和数据分析。</p><p>操作系统，它是怎么处理文件系统的、如果有多项任务在同时进行，它是怎么处理的以及计算机内存是如何处理分配的。这些内容在操作系统都会讲到，你将学到很多基础知识。</p><p>数据结构，你将学到各种完成特定任务的数据结构。</p><p>图形，制作3D动画、各种特效和电影图形技术以及处理数码摄影。</p><p>处理大量数据、对网络安全有重大影响的密码学。</p><hr><h3 id="第-28-课-宣布图形比赛结果"><a href="#第-28-课-宣布图形比赛结果" class="headerlink" title="第 28 课 宣布图形比赛结果"></a>第 28 课 宣布图形比赛结果</h3><p>图形比赛，最佳算法奖是一个产生分形图的程序，你可以输入一个数学表达式来产生相应的分形图，而且可以无限放大。最佳艺术将是使用者绘出一个图片，然后可以设定颜色，产生多种颜色的图片，将屏幕铺满，最后在屏幕上每个图片会依次发生一个落下并弹起直到从屏幕上消失的动画效果，直到图片全部消失。最好的还是大众选择奖，经典的塞尔达传说。</p><p>如果程序员能下意识地认为自己是艺术家的话，他们实际上能做的更好。当你把一些东西放到一起的时候，不要认为自己正在做数学验证。能够进行逻辑分析固然很重要，但最后你实际上是把一些本身没有美感的东西，组合到了一起。这也正是计算机科学的美妙之处。</p>]]></content>
      
      
      <categories>
          
          <category> 公开课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
